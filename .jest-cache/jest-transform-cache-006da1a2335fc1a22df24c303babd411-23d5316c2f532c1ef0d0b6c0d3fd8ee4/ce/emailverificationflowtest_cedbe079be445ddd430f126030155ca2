4b1e09bc867c1e1530d04c9d951d6b43
/**
 * Email Verification Flow Integration Tests
 * Tests complete signup and verification process, resend functionality, and rate limiting
 * Requirements: 1.1, 1.4, 2.1, 2.2
 */ "use strict";
// Mock email service
jest.mock('@/lib/services/resend-email-service');
jest.mock('@/lib/services/email-service');
// Mock database
jest.mock('@/lib/db', ()=>({
        db: {
            select: jest.fn().mockReturnThis(),
            from: jest.fn().mockReturnThis(),
            where: jest.fn().mockReturnThis(),
            insert: jest.fn().mockReturnThis(),
            values: jest.fn().mockReturnThis(),
            update: jest.fn().mockReturnThis(),
            set: jest.fn().mockReturnThis(),
            delete: jest.fn().mockReturnThis(),
            returning: jest.fn(),
            execute: jest.fn()
        }
    }));
// Mock auth functions
jest.mock('@/lib/auth', ()=>({
        getUserByEmail: jest.fn(),
        getUserById: jest.fn()
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _emailverificationcodeservice = require("../../lib/services/email-verification-code-service");
const _resendemailservice = require("../../lib/services/resend-email-service");
const mockEmailService = {
    sendVerificationEmail: jest.fn()
};
const mockCreateEmailService = _resendemailservice.createEmailService;
const mockSendEmailWithRetry = require('@/lib/services/email-service').sendEmailWithRetry;
const mockDb = require('@/lib/db').db;
const mockGetUserByEmail = require('@/lib/auth').getUserByEmail;
const mockGetUserById = require('@/lib/auth').getUserById;
// Mock environment variables
const originalEnv = process.env;
beforeAll(()=>{
    process.env = {
        ...originalEnv,
        RESEND_API_KEY: 'test-api-key',
        FROM_EMAIL: 'test@example.com',
        FROM_NAME: 'Test App',
        VERIFICATION_CODE_EXPIRY_MINUTES: '10',
        MAX_VERIFICATION_ATTEMPTS: '5',
        RESEND_COOLDOWN_SECONDS: '60',
        MAX_RESEND_PER_HOUR: '5',
        NODE_ENV: 'test'
    };
});
afterAll(()=>{
    process.env = originalEnv;
});
describe('Email Verification Flow Integration Tests', ()=>{
    beforeEach(async ()=>{
        jest.clearAllMocks();
        // Mock email service to always succeed
        mockCreateEmailService.mockReturnValue(mockEmailService);
        mockSendEmailWithRetry.mockResolvedValue(true);
        mockEmailService.sendVerificationEmail.mockResolvedValue(true);
        // Setup default database mocks
        mockDb.returning.mockResolvedValue([]);
        mockDb.execute.mockResolvedValue([]);
    });
    describe('Complete Signup and Verification Process', ()=>{
        it('should complete full signup and verification workflow', async ()=>{
            // Mock user data
            const mockUser = {
                id: 1,
                email: 'test@example.com',
                name: 'Test User',
                isEmailVerified: false
            };
            // Mock database responses for user lookup
            mockGetUserByEmail.mockResolvedValue(mockUser);
            mockGetUserById.mockResolvedValue(mockUser);
            // Mock code insertion
            mockDb.returning.mockResolvedValueOnce([
                {
                    id: 1,
                    code: '123456',
                    userId: 1
                }
            ]);
            // Step 1: Generate verification code
            const verificationCode = await _emailverificationcodeservice.emailVerificationCodeService.generateCode(mockUser.id);
            expect(verificationCode).toMatch(/^\d{6}$/);
            // Step 2: Mock successful validation
            mockDb.returning.mockResolvedValueOnce([
                {
                    id: 1,
                    code: verificationCode,
                    userId: 1,
                    expiresAt: new Date(Date.now() + 600000),
                    attemptsUsed: 0
                }
            ]);
            // Mock user update to verified
            mockGetUserById.mockResolvedValueOnce({
                ...mockUser,
                isEmailVerified: true
            });
            // Step 3: Validate the verification code
            const isValid = await _emailverificationcodeservice.emailVerificationCodeService.validateCode('test@example.com', verificationCode);
            expect(isValid).toBe(true);
            // Verify database operations were called
            expect(mockDb.insert).toHaveBeenCalled();
            expect(mockDb.update).toHaveBeenCalled();
            expect(mockDb.delete).toHaveBeenCalled();
        });
        it('should handle email service failure gracefully during code generation', async ()=>{
            // Mock user data
            const mockUser = {
                id: 1,
                email: 'test@example.com',
                name: 'Test User',
                isEmailVerified: false
            };
            // Mock user lookup
            mockGetUserById.mockResolvedValue(mockUser);
            // Mock code insertion
            mockDb.returning.mockResolvedValueOnce([
                {
                    id: 1,
                    code: '123456',
                    userId: 1
                }
            ]);
            // Generate verification code (this should work even if email fails)
            const verificationCode = await _emailverificationcodeservice.emailVerificationCodeService.generateCode(mockUser.id);
            expect(verificationCode).toMatch(/^\d{6}$/);
            // Verify database insert was called
            expect(mockDb.insert).toHaveBeenCalled();
            expect(mockDb.values).toHaveBeenCalled();
        });
        it('should reject verification with invalid code', async ()=>{
            // Mock user data
            const mockUser = {
                id: 1,
                email: 'test@example.com',
                name: 'Test User',
                isEmailVerified: false
            };
            // Mock user lookup
            mockGetUserByEmail.mockResolvedValue(mockUser);
            // Mock code lookup - return empty array (no matching code)
            mockDb.returning.mockResolvedValueOnce([]);
            // Try to verify with wrong code using service directly
            try {
                await _emailverificationcodeservice.emailVerificationCodeService.validateCode('test@example.com', '654321');
                fail('Should have thrown an error for invalid code');
            } catch (error) {
                expect(error.code).toBe('CODE_INVALID');
            }
        });
        it('should reject verification with expired code', async ()=>{
            // Mock user data
            const mockUser = {
                id: 1,
                email: 'test@example.com',
                name: 'Test User',
                isEmailVerified: false
            };
            // Mock user lookup
            mockGetUserByEmail.mockResolvedValue(mockUser);
            // Mock expired code lookup
            mockDb.returning.mockResolvedValueOnce([
                {
                    id: 1,
                    code: '123456',
                    userId: 1,
                    expiresAt: new Date(Date.now() - 1000),
                    attemptsUsed: 0
                }
            ]);
            // Try to verify with expired code using service directly
            try {
                await _emailverificationcodeservice.emailVerificationCodeService.validateCode('test@example.com', '123456');
                fail('Should have thrown an error for expired code');
            } catch (error) {
                expect(error.code).toBe('CODE_EXPIRED');
            }
        });
    });
    describe('Resend Verification Code Functionality', ()=>{
        it('should resend verification code by generating new code', async ()=>{
            // Mock user data
            const mockUser = {
                id: 1,
                email: 'test@example.com',
                name: 'Test User',
                isEmailVerified: false
            };
            // Mock user lookup
            mockGetUserById.mockResolvedValue(mockUser);
            // Mock code insertion for new code
            mockDb.returning.mockResolvedValueOnce([
                {
                    id: 1,
                    code: '654321',
                    userId: 1
                }
            ]);
            // Generate new verification code (simulating resend)
            const newCode = await _emailverificationcodeservice.emailVerificationCodeService.generateCode(mockUser.id);
            expect(newCode).toMatch(/^\d{6}$/);
            // Verify database operations were called
            expect(mockDb.delete).toHaveBeenCalled(); // Old codes deleted
            expect(mockDb.insert).toHaveBeenCalled(); // New code inserted
        });
        it('should handle resend for already verified user', async ()=>{
            // Mock verified user
            const mockUser = {
                id: 1,
                email: 'test@example.com',
                name: 'Test User',
                isEmailVerified: true
            };
            // Mock user lookup
            mockGetUserById.mockResolvedValue(mockUser);
            // Try to generate code for already verified user
            try {
                await _emailverificationcodeservice.emailVerificationCodeService.generateCode(mockUser.id);
                fail('Should have thrown an error for already verified user');
            } catch (error) {
                expect(error.code).toBe('ALREADY_VERIFIED');
            }
        });
        it('should handle resend for non-existent user', async ()=>{
            // Mock user not found
            mockGetUserByEmail.mockResolvedValue(null);
            // Try to validate code for non-existent user
            try {
                await _emailverificationcodeservice.emailVerificationCodeService.validateCode('nonexistent@example.com', '123456');
                fail('Should have thrown an error for non-existent user');
            } catch (error) {
                expect(error.code).toBe('USER_NOT_FOUND');
            }
        });
    });
    describe('Rate Limiting Enforcement', ()=>{
        it('should enforce verification attempt limits', async ()=>{
            // Mock user data
            const mockUser = {
                id: 1,
                email: 'test@example.com',
                name: 'Test User',
                isEmailVerified: false
            };
            // Mock user lookup
            mockGetUserByEmail.mockResolvedValue(mockUser);
            // Mock code with max attempts reached
            mockDb.returning.mockResolvedValueOnce([
                {
                    id: 1,
                    code: '123456',
                    userId: 1,
                    expiresAt: new Date(Date.now() + 600000),
                    attemptsUsed: 5
                }
            ]);
            // Try to verify with max attempts reached
            try {
                await _emailverificationcodeservice.emailVerificationCodeService.validateCode('test@example.com', '123456');
                fail('Should have thrown an error for too many attempts');
            } catch (error) {
                expect(error.code).toBe('TOO_MANY_ATTEMPTS');
            }
        });
        it('should handle validation at service level', async ()=>{
            // Mock user data
            const mockUser = {
                id: 1,
                email: 'test@example.com',
                name: 'Test User',
                isEmailVerified: false
            };
            // Mock user lookup
            mockGetUserById.mockResolvedValue(mockUser);
            mockGetUserByEmail.mockResolvedValue(mockUser);
            // Mock code insertion
            mockDb.returning.mockResolvedValueOnce([
                {
                    id: 1,
                    code: '123456',
                    userId: 1
                }
            ]);
            // Generate valid code
            const validCode = await _emailverificationcodeservice.emailVerificationCodeService.generateCode(mockUser.id);
            expect(validCode).toMatch(/^\d{6}$/);
            // Mock successful validation
            mockDb.returning.mockResolvedValueOnce([
                {
                    id: 1,
                    code: validCode,
                    userId: 1,
                    expiresAt: new Date(Date.now() + 600000),
                    attemptsUsed: 0
                }
            ]);
            // Test that service validates codes properly
            const isValid = await _emailverificationcodeservice.emailVerificationCodeService.validateCode('test@example.com', validCode);
            expect(isValid).toBe(true);
            // Verify database operations were called
            expect(mockDb.update).toHaveBeenCalled(); // User marked as verified
            expect(mockDb.delete).toHaveBeenCalled(); // Code deleted
        });
    });
    describe('Edge Cases and Error Scenarios', ()=>{
        it('should handle duplicate verification code generation', async ()=>{
            // Create user
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Generate first code
            const firstCode = await _emailverificationcodeservice.emailVerificationCodeService.generateCode(user.id);
            expect(firstCode).toMatch(/^\d{6}$/);
            // Generate second code (should invalidate first)
            const secondCode = await _emailverificationcodeservice.emailVerificationCodeService.generateCode(user.id);
            expect(secondCode).toMatch(/^\d{6}$/);
            expect(secondCode).not.toBe(firstCode);
            // Verify only one code exists
            const emailCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(emailCodes).toHaveLength(1);
            expect(emailCodes[0].code).toBe(secondCode);
        });
        it('should handle service errors gracefully', async ()=>{
            // Test with non-existent user ID
            try {
                await _emailverificationcodeservice.emailVerificationCodeService.generateCode(99999); // Non-existent user ID
                fail('Should have thrown an error for non-existent user');
            } catch (error) {
                expect(error.code).toBe('USER_NOT_FOUND');
            }
        });
        it('should handle cleanup of expired codes', async ()=>{
            // Create user with expired code
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '123456',
                expiresAt: new Date(Date.now() - 60000),
                attemptsUsed: 0
            });
            // Run cleanup
            await _emailverificationcodeservice.emailVerificationCodeService.cleanupExpiredCodes();
            // Verify expired code was cleaned up
            const remainingCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(remainingCodes).toHaveLength(0);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdGVmYW5iZWtrZXIvcHJvamVjdHMvZmFuY3ktcGxhbnRpZXMvc3JjL19fdGVzdHNfXy9pbnRlZ3JhdGlvbi9lbWFpbC12ZXJpZmljYXRpb24tZmxvdy50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRW1haWwgVmVyaWZpY2F0aW9uIEZsb3cgSW50ZWdyYXRpb24gVGVzdHNcbiAqIFRlc3RzIGNvbXBsZXRlIHNpZ251cCBhbmQgdmVyaWZpY2F0aW9uIHByb2Nlc3MsIHJlc2VuZCBmdW5jdGlvbmFsaXR5LCBhbmQgcmF0ZSBsaW1pdGluZ1xuICogUmVxdWlyZW1lbnRzOiAxLjEsIDEuNCwgMi4xLCAyLjJcbiAqL1xuXG5pbXBvcnQgeyBlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlIH0gZnJvbSAnQC9saWIvc2VydmljZXMvZW1haWwtdmVyaWZpY2F0aW9uLWNvZGUtc2VydmljZSc7XG5pbXBvcnQgeyBjcmVhdGVFbWFpbFNlcnZpY2UgfSBmcm9tICdAL2xpYi9zZXJ2aWNlcy9yZXNlbmQtZW1haWwtc2VydmljZSc7XG5cbi8vIE1vY2sgZW1haWwgc2VydmljZVxuamVzdC5tb2NrKCdAL2xpYi9zZXJ2aWNlcy9yZXNlbmQtZW1haWwtc2VydmljZScpO1xuamVzdC5tb2NrKCdAL2xpYi9zZXJ2aWNlcy9lbWFpbC1zZXJ2aWNlJyk7XG5cbi8vIE1vY2sgZGF0YWJhc2Vcbmplc3QubW9jaygnQC9saWIvZGInLCAoKSA9PiAoe1xuICBkYjoge1xuICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgZnJvbTogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgd2hlcmU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxuICAgIGluc2VydDogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgdmFsdWVzOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgICB1cGRhdGU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxuICAgIHNldDogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgZGVsZXRlOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgICByZXR1cm5pbmc6IGplc3QuZm4oKSxcbiAgICBleGVjdXRlOiBqZXN0LmZuKCksXG4gIH0sXG59KSk7XG5cbi8vIE1vY2sgYXV0aCBmdW5jdGlvbnNcbmplc3QubW9jaygnQC9saWIvYXV0aCcsICgpID0+ICh7XG4gIGdldFVzZXJCeUVtYWlsOiBqZXN0LmZuKCksXG4gIGdldFVzZXJCeUlkOiBqZXN0LmZuKCksXG59KSk7XG5cbmNvbnN0IG1vY2tFbWFpbFNlcnZpY2UgPSB7XG4gIHNlbmRWZXJpZmljYXRpb25FbWFpbDogamVzdC5mbigpLFxufTtcblxuY29uc3QgbW9ja0NyZWF0ZUVtYWlsU2VydmljZSA9IGNyZWF0ZUVtYWlsU2VydmljZSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiBjcmVhdGVFbWFpbFNlcnZpY2U+O1xuY29uc3QgbW9ja1NlbmRFbWFpbFdpdGhSZXRyeSA9IHJlcXVpcmUoJ0AvbGliL3NlcnZpY2VzL2VtYWlsLXNlcnZpY2UnKS5zZW5kRW1haWxXaXRoUmV0cnkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+O1xuY29uc3QgbW9ja0RiID0gcmVxdWlyZSgnQC9saWIvZGInKS5kYjtcbmNvbnN0IG1vY2tHZXRVc2VyQnlFbWFpbCA9IHJlcXVpcmUoJ0AvbGliL2F1dGgnKS5nZXRVc2VyQnlFbWFpbCBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT47XG5jb25zdCBtb2NrR2V0VXNlckJ5SWQgPSByZXF1aXJlKCdAL2xpYi9hdXRoJykuZ2V0VXNlckJ5SWQgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+O1xuXG4vLyBNb2NrIGVudmlyb25tZW50IHZhcmlhYmxlc1xuY29uc3Qgb3JpZ2luYWxFbnYgPSBwcm9jZXNzLmVudjtcblxuYmVmb3JlQWxsKCgpID0+IHtcbiAgcHJvY2Vzcy5lbnYgPSB7XG4gICAgLi4ub3JpZ2luYWxFbnYsXG4gICAgUkVTRU5EX0FQSV9LRVk6ICd0ZXN0LWFwaS1rZXknLFxuICAgIEZST01fRU1BSUw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICBGUk9NX05BTUU6ICdUZXN0IEFwcCcsXG4gICAgVkVSSUZJQ0FUSU9OX0NPREVfRVhQSVJZX01JTlVURVM6ICcxMCcsXG4gICAgTUFYX1ZFUklGSUNBVElPTl9BVFRFTVBUUzogJzUnLFxuICAgIFJFU0VORF9DT09MRE9XTl9TRUNPTkRTOiAnNjAnLFxuICAgIE1BWF9SRVNFTkRfUEVSX0hPVVI6ICc1JyxcbiAgICBOT0RFX0VOVjogJ3Rlc3QnLFxuICB9O1xufSk7XG5cbmFmdGVyQWxsKCgpID0+IHtcbiAgcHJvY2Vzcy5lbnYgPSBvcmlnaW5hbEVudjtcbn0pO1xuXG5kZXNjcmliZSgnRW1haWwgVmVyaWZpY2F0aW9uIEZsb3cgSW50ZWdyYXRpb24gVGVzdHMnLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIFxuICAgIC8vIE1vY2sgZW1haWwgc2VydmljZSB0byBhbHdheXMgc3VjY2VlZFxuICAgIG1vY2tDcmVhdGVFbWFpbFNlcnZpY2UubW9ja1JldHVyblZhbHVlKG1vY2tFbWFpbFNlcnZpY2UpO1xuICAgIG1vY2tTZW5kRW1haWxXaXRoUmV0cnkubW9ja1Jlc29sdmVkVmFsdWUodHJ1ZSk7XG4gICAgbW9ja0VtYWlsU2VydmljZS5zZW5kVmVyaWZpY2F0aW9uRW1haWwubW9ja1Jlc29sdmVkVmFsdWUodHJ1ZSk7XG5cbiAgICAvLyBTZXR1cCBkZWZhdWx0IGRhdGFiYXNlIG1vY2tzXG4gICAgbW9ja0RiLnJldHVybmluZy5tb2NrUmVzb2x2ZWRWYWx1ZShbXSk7XG4gICAgbW9ja0RiLmV4ZWN1dGUubW9ja1Jlc29sdmVkVmFsdWUoW10pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ29tcGxldGUgU2lnbnVwIGFuZCBWZXJpZmljYXRpb24gUHJvY2VzcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGNvbXBsZXRlIGZ1bGwgc2lnbnVwIGFuZCB2ZXJpZmljYXRpb24gd29ya2Zsb3cnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIHVzZXIgZGF0YVxuICAgICAgY29uc3QgbW9ja1VzZXIgPSB7XG4gICAgICAgIGlkOiAxLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAnVGVzdCBVc2VyJyxcbiAgICAgICAgaXNFbWFpbFZlcmlmaWVkOiBmYWxzZSxcbiAgICAgIH07XG5cbiAgICAgIC8vIE1vY2sgZGF0YWJhc2UgcmVzcG9uc2VzIGZvciB1c2VyIGxvb2t1cFxuICAgICAgbW9ja0dldFVzZXJCeUVtYWlsLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tVc2VyKTtcbiAgICAgIG1vY2tHZXRVc2VyQnlJZC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVXNlcik7XG5cbiAgICAgIC8vIE1vY2sgY29kZSBpbnNlcnRpb25cbiAgICAgIG1vY2tEYi5yZXR1cm5pbmcubW9ja1Jlc29sdmVkVmFsdWVPbmNlKFt7IGlkOiAxLCBjb2RlOiAnMTIzNDU2JywgdXNlcklkOiAxIH1dKTtcblxuICAgICAgLy8gU3RlcCAxOiBHZW5lcmF0ZSB2ZXJpZmljYXRpb24gY29kZVxuICAgICAgY29uc3QgdmVyaWZpY2F0aW9uQ29kZSA9IGF3YWl0IGVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UuZ2VuZXJhdGVDb2RlKG1vY2tVc2VyLmlkKTtcbiAgICAgIGV4cGVjdCh2ZXJpZmljYXRpb25Db2RlKS50b01hdGNoKC9eXFxkezZ9JC8pO1xuXG4gICAgICAvLyBTdGVwIDI6IE1vY2sgc3VjY2Vzc2Z1bCB2YWxpZGF0aW9uXG4gICAgICBtb2NrRGIucmV0dXJuaW5nLm1vY2tSZXNvbHZlZFZhbHVlT25jZShbeyBcbiAgICAgICAgaWQ6IDEsIFxuICAgICAgICBjb2RlOiB2ZXJpZmljYXRpb25Db2RlLCBcbiAgICAgICAgdXNlcklkOiAxLCBcbiAgICAgICAgZXhwaXJlc0F0OiBuZXcgRGF0ZShEYXRlLm5vdygpICsgNjAwMDAwKSxcbiAgICAgICAgYXR0ZW1wdHNVc2VkOiAwIFxuICAgICAgfV0pO1xuICAgICAgXG4gICAgICAvLyBNb2NrIHVzZXIgdXBkYXRlIHRvIHZlcmlmaWVkXG4gICAgICBtb2NrR2V0VXNlckJ5SWQubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgLi4ubW9ja1VzZXIsIGlzRW1haWxWZXJpZmllZDogdHJ1ZSB9KTtcblxuICAgICAgLy8gU3RlcCAzOiBWYWxpZGF0ZSB0aGUgdmVyaWZpY2F0aW9uIGNvZGVcbiAgICAgIGNvbnN0IGlzVmFsaWQgPSBhd2FpdCBlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlLnZhbGlkYXRlQ29kZSgndGVzdEBleGFtcGxlLmNvbScsIHZlcmlmaWNhdGlvbkNvZGUpO1xuICAgICAgZXhwZWN0KGlzVmFsaWQpLnRvQmUodHJ1ZSk7XG5cbiAgICAgIC8vIFZlcmlmeSBkYXRhYmFzZSBvcGVyYXRpb25zIHdlcmUgY2FsbGVkXG4gICAgICBleHBlY3QobW9ja0RiLmluc2VydCkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgZXhwZWN0KG1vY2tEYi51cGRhdGUpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIGV4cGVjdChtb2NrRGIuZGVsZXRlKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBlbWFpbCBzZXJ2aWNlIGZhaWx1cmUgZ3JhY2VmdWxseSBkdXJpbmcgY29kZSBnZW5lcmF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayB1c2VyIGRhdGFcbiAgICAgIGNvbnN0IG1vY2tVc2VyID0ge1xuICAgICAgICBpZDogMSxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgICAgIGlzRW1haWxWZXJpZmllZDogZmFsc2UsXG4gICAgICB9O1xuXG4gICAgICAvLyBNb2NrIHVzZXIgbG9va3VwXG4gICAgICBtb2NrR2V0VXNlckJ5SWQubW9ja1Jlc29sdmVkVmFsdWUobW9ja1VzZXIpO1xuXG4gICAgICAvLyBNb2NrIGNvZGUgaW5zZXJ0aW9uXG4gICAgICBtb2NrRGIucmV0dXJuaW5nLm1vY2tSZXNvbHZlZFZhbHVlT25jZShbeyBpZDogMSwgY29kZTogJzEyMzQ1NicsIHVzZXJJZDogMSB9XSk7XG5cbiAgICAgIC8vIEdlbmVyYXRlIHZlcmlmaWNhdGlvbiBjb2RlICh0aGlzIHNob3VsZCB3b3JrIGV2ZW4gaWYgZW1haWwgZmFpbHMpXG4gICAgICBjb25zdCB2ZXJpZmljYXRpb25Db2RlID0gYXdhaXQgZW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS5nZW5lcmF0ZUNvZGUobW9ja1VzZXIuaWQpO1xuICAgICAgZXhwZWN0KHZlcmlmaWNhdGlvbkNvZGUpLnRvTWF0Y2goL15cXGR7Nn0kLyk7XG5cbiAgICAgIC8vIFZlcmlmeSBkYXRhYmFzZSBpbnNlcnQgd2FzIGNhbGxlZFxuICAgICAgZXhwZWN0KG1vY2tEYi5pbnNlcnQpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIGV4cGVjdChtb2NrRGIudmFsdWVzKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2ZXJpZmljYXRpb24gd2l0aCBpbnZhbGlkIGNvZGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIHVzZXIgZGF0YVxuICAgICAgY29uc3QgbW9ja1VzZXIgPSB7XG4gICAgICAgIGlkOiAxLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAnVGVzdCBVc2VyJyxcbiAgICAgICAgaXNFbWFpbFZlcmlmaWVkOiBmYWxzZSxcbiAgICAgIH07XG5cbiAgICAgIC8vIE1vY2sgdXNlciBsb29rdXBcbiAgICAgIG1vY2tHZXRVc2VyQnlFbWFpbC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVXNlcik7XG5cbiAgICAgIC8vIE1vY2sgY29kZSBsb29rdXAgLSByZXR1cm4gZW1wdHkgYXJyYXkgKG5vIG1hdGNoaW5nIGNvZGUpXG4gICAgICBtb2NrRGIucmV0dXJuaW5nLm1vY2tSZXNvbHZlZFZhbHVlT25jZShbXSk7XG5cbiAgICAgIC8vIFRyeSB0byB2ZXJpZnkgd2l0aCB3cm9uZyBjb2RlIHVzaW5nIHNlcnZpY2UgZGlyZWN0bHlcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UudmFsaWRhdGVDb2RlKCd0ZXN0QGV4YW1wbGUuY29tJywgJzY1NDMyMScpO1xuICAgICAgICBmYWlsKCdTaG91bGQgaGF2ZSB0aHJvd24gYW4gZXJyb3IgZm9yIGludmFsaWQgY29kZScpO1xuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBleHBlY3QoZXJyb3IuY29kZSkudG9CZSgnQ09ERV9JTlZBTElEJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2ZXJpZmljYXRpb24gd2l0aCBleHBpcmVkIGNvZGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIHVzZXIgZGF0YVxuICAgICAgY29uc3QgbW9ja1VzZXIgPSB7XG4gICAgICAgIGlkOiAxLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAnVGVzdCBVc2VyJyxcbiAgICAgICAgaXNFbWFpbFZlcmlmaWVkOiBmYWxzZSxcbiAgICAgIH07XG5cbiAgICAgIC8vIE1vY2sgdXNlciBsb29rdXBcbiAgICAgIG1vY2tHZXRVc2VyQnlFbWFpbC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVXNlcik7XG5cbiAgICAgIC8vIE1vY2sgZXhwaXJlZCBjb2RlIGxvb2t1cFxuICAgICAgbW9ja0RiLnJldHVybmluZy5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoW3tcbiAgICAgICAgaWQ6IDEsXG4gICAgICAgIGNvZGU6ICcxMjM0NTYnLFxuICAgICAgICB1c2VySWQ6IDEsXG4gICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDEwMDApLCAvLyBFeHBpcmVkIDEgc2Vjb25kIGFnb1xuICAgICAgICBhdHRlbXB0c1VzZWQ6IDAsXG4gICAgICB9XSk7XG5cbiAgICAgIC8vIFRyeSB0byB2ZXJpZnkgd2l0aCBleHBpcmVkIGNvZGUgdXNpbmcgc2VydmljZSBkaXJlY3RseVxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS52YWxpZGF0ZUNvZGUoJ3Rlc3RAZXhhbXBsZS5jb20nLCAnMTIzNDU2Jyk7XG4gICAgICAgIGZhaWwoJ1Nob3VsZCBoYXZlIHRocm93biBhbiBlcnJvciBmb3IgZXhwaXJlZCBjb2RlJyk7XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIGV4cGVjdChlcnJvci5jb2RlKS50b0JlKCdDT0RFX0VYUElSRUQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1Jlc2VuZCBWZXJpZmljYXRpb24gQ29kZSBGdW5jdGlvbmFsaXR5JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmVzZW5kIHZlcmlmaWNhdGlvbiBjb2RlIGJ5IGdlbmVyYXRpbmcgbmV3IGNvZGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIHVzZXIgZGF0YVxuICAgICAgY29uc3QgbW9ja1VzZXIgPSB7XG4gICAgICAgIGlkOiAxLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAnVGVzdCBVc2VyJyxcbiAgICAgICAgaXNFbWFpbFZlcmlmaWVkOiBmYWxzZSxcbiAgICAgIH07XG5cbiAgICAgIC8vIE1vY2sgdXNlciBsb29rdXBcbiAgICAgIG1vY2tHZXRVc2VyQnlJZC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVXNlcik7XG5cbiAgICAgIC8vIE1vY2sgY29kZSBpbnNlcnRpb24gZm9yIG5ldyBjb2RlXG4gICAgICBtb2NrRGIucmV0dXJuaW5nLm1vY2tSZXNvbHZlZFZhbHVlT25jZShbeyBpZDogMSwgY29kZTogJzY1NDMyMScsIHVzZXJJZDogMSB9XSk7XG5cbiAgICAgIC8vIEdlbmVyYXRlIG5ldyB2ZXJpZmljYXRpb24gY29kZSAoc2ltdWxhdGluZyByZXNlbmQpXG4gICAgICBjb25zdCBuZXdDb2RlID0gYXdhaXQgZW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS5nZW5lcmF0ZUNvZGUobW9ja1VzZXIuaWQpO1xuICAgICAgZXhwZWN0KG5ld0NvZGUpLnRvTWF0Y2goL15cXGR7Nn0kLyk7XG5cbiAgICAgIC8vIFZlcmlmeSBkYXRhYmFzZSBvcGVyYXRpb25zIHdlcmUgY2FsbGVkXG4gICAgICBleHBlY3QobW9ja0RiLmRlbGV0ZSkudG9IYXZlQmVlbkNhbGxlZCgpOyAvLyBPbGQgY29kZXMgZGVsZXRlZFxuICAgICAgZXhwZWN0KG1vY2tEYi5pbnNlcnQpLnRvSGF2ZUJlZW5DYWxsZWQoKTsgLy8gTmV3IGNvZGUgaW5zZXJ0ZWRcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHJlc2VuZCBmb3IgYWxyZWFkeSB2ZXJpZmllZCB1c2VyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayB2ZXJpZmllZCB1c2VyXG4gICAgICBjb25zdCBtb2NrVXNlciA9IHtcbiAgICAgICAgaWQ6IDEsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgICBpc0VtYWlsVmVyaWZpZWQ6IHRydWUsIC8vIEFscmVhZHkgdmVyaWZpZWRcbiAgICAgIH07XG5cbiAgICAgIC8vIE1vY2sgdXNlciBsb29rdXBcbiAgICAgIG1vY2tHZXRVc2VyQnlJZC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVXNlcik7XG5cbiAgICAgIC8vIFRyeSB0byBnZW5lcmF0ZSBjb2RlIGZvciBhbHJlYWR5IHZlcmlmaWVkIHVzZXJcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UuZ2VuZXJhdGVDb2RlKG1vY2tVc2VyLmlkKTtcbiAgICAgICAgZmFpbCgnU2hvdWxkIGhhdmUgdGhyb3duIGFuIGVycm9yIGZvciBhbHJlYWR5IHZlcmlmaWVkIHVzZXInKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgZXhwZWN0KGVycm9yLmNvZGUpLnRvQmUoJ0FMUkVBRFlfVkVSSUZJRUQnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHJlc2VuZCBmb3Igbm9uLWV4aXN0ZW50IHVzZXInLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIHVzZXIgbm90IGZvdW5kXG4gICAgICBtb2NrR2V0VXNlckJ5RW1haWwubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG5cbiAgICAgIC8vIFRyeSB0byB2YWxpZGF0ZSBjb2RlIGZvciBub24tZXhpc3RlbnQgdXNlclxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS52YWxpZGF0ZUNvZGUoJ25vbmV4aXN0ZW50QGV4YW1wbGUuY29tJywgJzEyMzQ1NicpO1xuICAgICAgICBmYWlsKCdTaG91bGQgaGF2ZSB0aHJvd24gYW4gZXJyb3IgZm9yIG5vbi1leGlzdGVudCB1c2VyJyk7XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIGV4cGVjdChlcnJvci5jb2RlKS50b0JlKCdVU0VSX05PVF9GT1VORCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUmF0ZSBMaW1pdGluZyBFbmZvcmNlbWVudCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGVuZm9yY2UgdmVyaWZpY2F0aW9uIGF0dGVtcHQgbGltaXRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayB1c2VyIGRhdGFcbiAgICAgIGNvbnN0IG1vY2tVc2VyID0ge1xuICAgICAgICBpZDogMSxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgICAgIGlzRW1haWxWZXJpZmllZDogZmFsc2UsXG4gICAgICB9O1xuXG4gICAgICAvLyBNb2NrIHVzZXIgbG9va3VwXG4gICAgICBtb2NrR2V0VXNlckJ5RW1haWwubW9ja1Jlc29sdmVkVmFsdWUobW9ja1VzZXIpO1xuXG4gICAgICAvLyBNb2NrIGNvZGUgd2l0aCBtYXggYXR0ZW1wdHMgcmVhY2hlZFxuICAgICAgbW9ja0RiLnJldHVybmluZy5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoW3tcbiAgICAgICAgaWQ6IDEsXG4gICAgICAgIGNvZGU6ICcxMjM0NTYnLFxuICAgICAgICB1c2VySWQ6IDEsXG4gICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIDYwMDAwMCksXG4gICAgICAgIGF0dGVtcHRzVXNlZDogNSwgLy8gTWF4IGF0dGVtcHRzIHJlYWNoZWRcbiAgICAgIH1dKTtcblxuICAgICAgLy8gVHJ5IHRvIHZlcmlmeSB3aXRoIG1heCBhdHRlbXB0cyByZWFjaGVkXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlLnZhbGlkYXRlQ29kZSgndGVzdEBleGFtcGxlLmNvbScsICcxMjM0NTYnKTtcbiAgICAgICAgZmFpbCgnU2hvdWxkIGhhdmUgdGhyb3duIGFuIGVycm9yIGZvciB0b28gbWFueSBhdHRlbXB0cycpO1xuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBleHBlY3QoZXJyb3IuY29kZSkudG9CZSgnVE9PX01BTllfQVRURU1QVFMnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHZhbGlkYXRpb24gYXQgc2VydmljZSBsZXZlbCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgdXNlciBkYXRhXG4gICAgICBjb25zdCBtb2NrVXNlciA9IHtcbiAgICAgICAgaWQ6IDEsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgICBpc0VtYWlsVmVyaWZpZWQ6IGZhbHNlLFxuICAgICAgfTtcblxuICAgICAgLy8gTW9jayB1c2VyIGxvb2t1cFxuICAgICAgbW9ja0dldFVzZXJCeUlkLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tVc2VyKTtcbiAgICAgIG1vY2tHZXRVc2VyQnlFbWFpbC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVXNlcik7XG5cbiAgICAgIC8vIE1vY2sgY29kZSBpbnNlcnRpb25cbiAgICAgIG1vY2tEYi5yZXR1cm5pbmcubW9ja1Jlc29sdmVkVmFsdWVPbmNlKFt7IGlkOiAxLCBjb2RlOiAnMTIzNDU2JywgdXNlcklkOiAxIH1dKTtcblxuICAgICAgLy8gR2VuZXJhdGUgdmFsaWQgY29kZVxuICAgICAgY29uc3QgdmFsaWRDb2RlID0gYXdhaXQgZW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS5nZW5lcmF0ZUNvZGUobW9ja1VzZXIuaWQpO1xuICAgICAgZXhwZWN0KHZhbGlkQ29kZSkudG9NYXRjaCgvXlxcZHs2fSQvKTtcblxuICAgICAgLy8gTW9jayBzdWNjZXNzZnVsIHZhbGlkYXRpb25cbiAgICAgIG1vY2tEYi5yZXR1cm5pbmcubW9ja1Jlc29sdmVkVmFsdWVPbmNlKFt7XG4gICAgICAgIGlkOiAxLFxuICAgICAgICBjb2RlOiB2YWxpZENvZGUsXG4gICAgICAgIHVzZXJJZDogMSxcbiAgICAgICAgZXhwaXJlc0F0OiBuZXcgRGF0ZShEYXRlLm5vdygpICsgNjAwMDAwKSxcbiAgICAgICAgYXR0ZW1wdHNVc2VkOiAwLFxuICAgICAgfV0pO1xuXG4gICAgICAvLyBUZXN0IHRoYXQgc2VydmljZSB2YWxpZGF0ZXMgY29kZXMgcHJvcGVybHlcbiAgICAgIGNvbnN0IGlzVmFsaWQgPSBhd2FpdCBlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlLnZhbGlkYXRlQ29kZSgndGVzdEBleGFtcGxlLmNvbScsIHZhbGlkQ29kZSk7XG4gICAgICBleHBlY3QoaXNWYWxpZCkudG9CZSh0cnVlKTtcblxuICAgICAgLy8gVmVyaWZ5IGRhdGFiYXNlIG9wZXJhdGlvbnMgd2VyZSBjYWxsZWRcbiAgICAgIGV4cGVjdChtb2NrRGIudXBkYXRlKS50b0hhdmVCZWVuQ2FsbGVkKCk7IC8vIFVzZXIgbWFya2VkIGFzIHZlcmlmaWVkXG4gICAgICBleHBlY3QobW9ja0RiLmRlbGV0ZSkudG9IYXZlQmVlbkNhbGxlZCgpOyAvLyBDb2RlIGRlbGV0ZWRcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0VkZ2UgQ2FzZXMgYW5kIEVycm9yIFNjZW5hcmlvcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBkdXBsaWNhdGUgdmVyaWZpY2F0aW9uIGNvZGUgZ2VuZXJhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSB1c2VyXG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RVc2VyKHtcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgICAgIHBhc3N3b3JkSGFzaDogJ2hhc2hlZF9wYXNzd29yZCcsXG4gICAgICAgIGlzRW1haWxWZXJpZmllZDogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgLy8gR2VuZXJhdGUgZmlyc3QgY29kZVxuICAgICAgY29uc3QgZmlyc3RDb2RlID0gYXdhaXQgZW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS5nZW5lcmF0ZUNvZGUodXNlci5pZCk7XG4gICAgICBleHBlY3QoZmlyc3RDb2RlKS50b01hdGNoKC9eXFxkezZ9JC8pO1xuXG4gICAgICAvLyBHZW5lcmF0ZSBzZWNvbmQgY29kZSAoc2hvdWxkIGludmFsaWRhdGUgZmlyc3QpXG4gICAgICBjb25zdCBzZWNvbmRDb2RlID0gYXdhaXQgZW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS5nZW5lcmF0ZUNvZGUodXNlci5pZCk7XG4gICAgICBleHBlY3Qoc2Vjb25kQ29kZSkudG9NYXRjaCgvXlxcZHs2fSQvKTtcbiAgICAgIGV4cGVjdChzZWNvbmRDb2RlKS5ub3QudG9CZShmaXJzdENvZGUpO1xuXG4gICAgICAvLyBWZXJpZnkgb25seSBvbmUgY29kZSBleGlzdHNcbiAgICAgIGNvbnN0IGVtYWlsQ29kZXMgPSBhd2FpdCBkYk1hbmFnZXIuZ2V0RW1haWxDb2Rlc0J5VXNlcklkKHVzZXIuaWQpO1xuICAgICAgZXhwZWN0KGVtYWlsQ29kZXMpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChlbWFpbENvZGVzWzBdLmNvZGUpLnRvQmUoc2Vjb25kQ29kZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBzZXJ2aWNlIGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gVGVzdCB3aXRoIG5vbi1leGlzdGVudCB1c2VyIElEXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlLmdlbmVyYXRlQ29kZSg5OTk5OSk7IC8vIE5vbi1leGlzdGVudCB1c2VyIElEXG4gICAgICAgIGZhaWwoJ1Nob3VsZCBoYXZlIHRocm93biBhbiBlcnJvciBmb3Igbm9uLWV4aXN0ZW50IHVzZXInKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgZXhwZWN0KGVycm9yLmNvZGUpLnRvQmUoJ1VTRVJfTk9UX0ZPVU5EJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjbGVhbnVwIG9mIGV4cGlyZWQgY29kZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBDcmVhdGUgdXNlciB3aXRoIGV4cGlyZWQgY29kZVxuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0VXNlcih7XG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgICBwYXNzd29yZEhhc2g6ICdoYXNoZWRfcGFzc3dvcmQnLFxuICAgICAgICBpc0VtYWlsVmVyaWZpZWQ6IGZhbHNlLFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0RW1haWxDb2RlKHtcbiAgICAgICAgdXNlcklkOiB1c2VyLmlkLFxuICAgICAgICBjb2RlOiAnMTIzNDU2JyxcbiAgICAgICAgZXhwaXJlc0F0OiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gNjAwMDApLCAvLyBFeHBpcmVkIDEgbWludXRlIGFnb1xuICAgICAgICBhdHRlbXB0c1VzZWQ6IDAsXG4gICAgICB9KTtcblxuICAgICAgLy8gUnVuIGNsZWFudXBcbiAgICAgIGF3YWl0IGVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UuY2xlYW51cEV4cGlyZWRDb2RlcygpO1xuXG4gICAgICAvLyBWZXJpZnkgZXhwaXJlZCBjb2RlIHdhcyBjbGVhbmVkIHVwXG4gICAgICBjb25zdCByZW1haW5pbmdDb2RlcyA9IGF3YWl0IGRiTWFuYWdlci5nZXRFbWFpbENvZGVzQnlVc2VySWQodXNlci5pZCk7XG4gICAgICBleHBlY3QocmVtYWluaW5nQ29kZXMpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICB9KTtcbiAgfSk7XG59KTsiXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJkYiIsInNlbGVjdCIsImZuIiwibW9ja1JldHVyblRoaXMiLCJmcm9tIiwid2hlcmUiLCJpbnNlcnQiLCJ2YWx1ZXMiLCJ1cGRhdGUiLCJzZXQiLCJkZWxldGUiLCJyZXR1cm5pbmciLCJleGVjdXRlIiwiZ2V0VXNlckJ5RW1haWwiLCJnZXRVc2VyQnlJZCIsIm1vY2tFbWFpbFNlcnZpY2UiLCJzZW5kVmVyaWZpY2F0aW9uRW1haWwiLCJtb2NrQ3JlYXRlRW1haWxTZXJ2aWNlIiwiY3JlYXRlRW1haWxTZXJ2aWNlIiwibW9ja1NlbmRFbWFpbFdpdGhSZXRyeSIsInJlcXVpcmUiLCJzZW5kRW1haWxXaXRoUmV0cnkiLCJtb2NrRGIiLCJtb2NrR2V0VXNlckJ5RW1haWwiLCJtb2NrR2V0VXNlckJ5SWQiLCJvcmlnaW5hbEVudiIsInByb2Nlc3MiLCJlbnYiLCJiZWZvcmVBbGwiLCJSRVNFTkRfQVBJX0tFWSIsIkZST01fRU1BSUwiLCJGUk9NX05BTUUiLCJWRVJJRklDQVRJT05fQ09ERV9FWFBJUllfTUlOVVRFUyIsIk1BWF9WRVJJRklDQVRJT05fQVRURU1QVFMiLCJSRVNFTkRfQ09PTERPV05fU0VDT05EUyIsIk1BWF9SRVNFTkRfUEVSX0hPVVIiLCJOT0RFX0VOViIsImFmdGVyQWxsIiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIm1vY2tSZXR1cm5WYWx1ZSIsIm1vY2tSZXNvbHZlZFZhbHVlIiwiaXQiLCJtb2NrVXNlciIsImlkIiwiZW1haWwiLCJuYW1lIiwiaXNFbWFpbFZlcmlmaWVkIiwibW9ja1Jlc29sdmVkVmFsdWVPbmNlIiwiY29kZSIsInVzZXJJZCIsInZlcmlmaWNhdGlvbkNvZGUiLCJlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlIiwiZ2VuZXJhdGVDb2RlIiwiZXhwZWN0IiwidG9NYXRjaCIsImV4cGlyZXNBdCIsIkRhdGUiLCJub3ciLCJhdHRlbXB0c1VzZWQiLCJpc1ZhbGlkIiwidmFsaWRhdGVDb2RlIiwidG9CZSIsInRvSGF2ZUJlZW5DYWxsZWQiLCJmYWlsIiwiZXJyb3IiLCJuZXdDb2RlIiwidmFsaWRDb2RlIiwidXNlciIsImRiTWFuYWdlciIsImNyZWF0ZVRlc3RVc2VyIiwicGFzc3dvcmRIYXNoIiwiZmlyc3RDb2RlIiwic2Vjb25kQ29kZSIsIm5vdCIsImVtYWlsQ29kZXMiLCJnZXRFbWFpbENvZGVzQnlVc2VySWQiLCJ0b0hhdmVMZW5ndGgiLCJjcmVhdGVUZXN0RW1haWxDb2RlIiwiY2xlYW51cEV4cGlyZWRDb2RlcyIsInJlbWFpbmluZ0NvZGVzIl0sIm1hcHBpbmdzIjoiQUFBQTs7OztDQUlDO0FBS0QscUJBQXFCO0FBQ3JCQSxLQUFLQyxJQUFJLENBQUM7QUFDVkQsS0FBS0MsSUFBSSxDQUFDO0FBRVYsZ0JBQWdCO0FBQ2hCRCxLQUFLQyxJQUFJLENBQUMsWUFBWSxJQUFPLENBQUE7UUFDM0JDLElBQUk7WUFDRkMsUUFBUUgsS0FBS0ksRUFBRSxHQUFHQyxjQUFjO1lBQ2hDQyxNQUFNTixLQUFLSSxFQUFFLEdBQUdDLGNBQWM7WUFDOUJFLE9BQU9QLEtBQUtJLEVBQUUsR0FBR0MsY0FBYztZQUMvQkcsUUFBUVIsS0FBS0ksRUFBRSxHQUFHQyxjQUFjO1lBQ2hDSSxRQUFRVCxLQUFLSSxFQUFFLEdBQUdDLGNBQWM7WUFDaENLLFFBQVFWLEtBQUtJLEVBQUUsR0FBR0MsY0FBYztZQUNoQ00sS0FBS1gsS0FBS0ksRUFBRSxHQUFHQyxjQUFjO1lBQzdCTyxRQUFRWixLQUFLSSxFQUFFLEdBQUdDLGNBQWM7WUFDaENRLFdBQVdiLEtBQUtJLEVBQUU7WUFDbEJVLFNBQVNkLEtBQUtJLEVBQUU7UUFDbEI7SUFDRixDQUFBO0FBRUEsc0JBQXNCO0FBQ3RCSixLQUFLQyxJQUFJLENBQUMsY0FBYyxJQUFPLENBQUE7UUFDN0JjLGdCQUFnQmYsS0FBS0ksRUFBRTtRQUN2QlksYUFBYWhCLEtBQUtJLEVBQUU7SUFDdEIsQ0FBQTs7Ozs4Q0EzQjZDO29DQUNWO0FBNEJuQyxNQUFNYSxtQkFBbUI7SUFDdkJDLHVCQUF1QmxCLEtBQUtJLEVBQUU7QUFDaEM7QUFFQSxNQUFNZSx5QkFBeUJDLHNDQUFrQjtBQUNqRCxNQUFNQyx5QkFBeUJDLFFBQVEsZ0NBQWdDQyxrQkFBa0I7QUFDekYsTUFBTUMsU0FBU0YsUUFBUSxZQUFZcEIsRUFBRTtBQUNyQyxNQUFNdUIscUJBQXFCSCxRQUFRLGNBQWNQLGNBQWM7QUFDL0QsTUFBTVcsa0JBQWtCSixRQUFRLGNBQWNOLFdBQVc7QUFFekQsNkJBQTZCO0FBQzdCLE1BQU1XLGNBQWNDLFFBQVFDLEdBQUc7QUFFL0JDLFVBQVU7SUFDUkYsUUFBUUMsR0FBRyxHQUFHO1FBQ1osR0FBR0YsV0FBVztRQUNkSSxnQkFBZ0I7UUFDaEJDLFlBQVk7UUFDWkMsV0FBVztRQUNYQyxrQ0FBa0M7UUFDbENDLDJCQUEyQjtRQUMzQkMseUJBQXlCO1FBQ3pCQyxxQkFBcUI7UUFDckJDLFVBQVU7SUFDWjtBQUNGO0FBRUFDLFNBQVM7SUFDUFgsUUFBUUMsR0FBRyxHQUFHRjtBQUNoQjtBQUVBYSxTQUFTLDZDQUE2QztJQUNwREMsV0FBVztRQUNUekMsS0FBSzBDLGFBQWE7UUFFbEIsdUNBQXVDO1FBQ3ZDdkIsdUJBQXVCd0IsZUFBZSxDQUFDMUI7UUFDdkNJLHVCQUF1QnVCLGlCQUFpQixDQUFDO1FBQ3pDM0IsaUJBQWlCQyxxQkFBcUIsQ0FBQzBCLGlCQUFpQixDQUFDO1FBRXpELCtCQUErQjtRQUMvQnBCLE9BQU9YLFNBQVMsQ0FBQytCLGlCQUFpQixDQUFDLEVBQUU7UUFDckNwQixPQUFPVixPQUFPLENBQUM4QixpQkFBaUIsQ0FBQyxFQUFFO0lBQ3JDO0lBRUFKLFNBQVMsNENBQTRDO1FBQ25ESyxHQUFHLHlEQUF5RDtZQUMxRCxpQkFBaUI7WUFDakIsTUFBTUMsV0FBVztnQkFDZkMsSUFBSTtnQkFDSkMsT0FBTztnQkFDUEMsTUFBTTtnQkFDTkMsaUJBQWlCO1lBQ25CO1lBRUEsMENBQTBDO1lBQzFDekIsbUJBQW1CbUIsaUJBQWlCLENBQUNFO1lBQ3JDcEIsZ0JBQWdCa0IsaUJBQWlCLENBQUNFO1lBRWxDLHNCQUFzQjtZQUN0QnRCLE9BQU9YLFNBQVMsQ0FBQ3NDLHFCQUFxQixDQUFDO2dCQUFDO29CQUFFSixJQUFJO29CQUFHSyxNQUFNO29CQUFVQyxRQUFRO2dCQUFFO2FBQUU7WUFFN0UscUNBQXFDO1lBQ3JDLE1BQU1DLG1CQUFtQixNQUFNQywwREFBNEIsQ0FBQ0MsWUFBWSxDQUFDVixTQUFTQyxFQUFFO1lBQ3BGVSxPQUFPSCxrQkFBa0JJLE9BQU8sQ0FBQztZQUVqQyxxQ0FBcUM7WUFDckNsQyxPQUFPWCxTQUFTLENBQUNzQyxxQkFBcUIsQ0FBQztnQkFBQztvQkFDdENKLElBQUk7b0JBQ0pLLE1BQU1FO29CQUNORCxRQUFRO29CQUNSTSxXQUFXLElBQUlDLEtBQUtBLEtBQUtDLEdBQUcsS0FBSztvQkFDakNDLGNBQWM7Z0JBQ2hCO2FBQUU7WUFFRiwrQkFBK0I7WUFDL0JwQyxnQkFBZ0J5QixxQkFBcUIsQ0FBQztnQkFBRSxHQUFHTCxRQUFRO2dCQUFFSSxpQkFBaUI7WUFBSztZQUUzRSx5Q0FBeUM7WUFDekMsTUFBTWEsVUFBVSxNQUFNUiwwREFBNEIsQ0FBQ1MsWUFBWSxDQUFDLG9CQUFvQlY7WUFDcEZHLE9BQU9NLFNBQVNFLElBQUksQ0FBQztZQUVyQix5Q0FBeUM7WUFDekNSLE9BQU9qQyxPQUFPaEIsTUFBTSxFQUFFMEQsZ0JBQWdCO1lBQ3RDVCxPQUFPakMsT0FBT2QsTUFBTSxFQUFFd0QsZ0JBQWdCO1lBQ3RDVCxPQUFPakMsT0FBT1osTUFBTSxFQUFFc0QsZ0JBQWdCO1FBQ3hDO1FBRUFyQixHQUFHLHlFQUF5RTtZQUMxRSxpQkFBaUI7WUFDakIsTUFBTUMsV0FBVztnQkFDZkMsSUFBSTtnQkFDSkMsT0FBTztnQkFDUEMsTUFBTTtnQkFDTkMsaUJBQWlCO1lBQ25CO1lBRUEsbUJBQW1CO1lBQ25CeEIsZ0JBQWdCa0IsaUJBQWlCLENBQUNFO1lBRWxDLHNCQUFzQjtZQUN0QnRCLE9BQU9YLFNBQVMsQ0FBQ3NDLHFCQUFxQixDQUFDO2dCQUFDO29CQUFFSixJQUFJO29CQUFHSyxNQUFNO29CQUFVQyxRQUFRO2dCQUFFO2FBQUU7WUFFN0Usb0VBQW9FO1lBQ3BFLE1BQU1DLG1CQUFtQixNQUFNQywwREFBNEIsQ0FBQ0MsWUFBWSxDQUFDVixTQUFTQyxFQUFFO1lBQ3BGVSxPQUFPSCxrQkFBa0JJLE9BQU8sQ0FBQztZQUVqQyxvQ0FBb0M7WUFDcENELE9BQU9qQyxPQUFPaEIsTUFBTSxFQUFFMEQsZ0JBQWdCO1lBQ3RDVCxPQUFPakMsT0FBT2YsTUFBTSxFQUFFeUQsZ0JBQWdCO1FBQ3hDO1FBRUFyQixHQUFHLGdEQUFnRDtZQUNqRCxpQkFBaUI7WUFDakIsTUFBTUMsV0FBVztnQkFDZkMsSUFBSTtnQkFDSkMsT0FBTztnQkFDUEMsTUFBTTtnQkFDTkMsaUJBQWlCO1lBQ25CO1lBRUEsbUJBQW1CO1lBQ25CekIsbUJBQW1CbUIsaUJBQWlCLENBQUNFO1lBRXJDLDJEQUEyRDtZQUMzRHRCLE9BQU9YLFNBQVMsQ0FBQ3NDLHFCQUFxQixDQUFDLEVBQUU7WUFFekMsdURBQXVEO1lBQ3ZELElBQUk7Z0JBQ0YsTUFBTUksMERBQTRCLENBQUNTLFlBQVksQ0FBQyxvQkFBb0I7Z0JBQ3BFRyxLQUFLO1lBQ1AsRUFBRSxPQUFPQyxPQUFZO2dCQUNuQlgsT0FBT1csTUFBTWhCLElBQUksRUFBRWEsSUFBSSxDQUFDO1lBQzFCO1FBQ0Y7UUFFQXBCLEdBQUcsZ0RBQWdEO1lBQ2pELGlCQUFpQjtZQUNqQixNQUFNQyxXQUFXO2dCQUNmQyxJQUFJO2dCQUNKQyxPQUFPO2dCQUNQQyxNQUFNO2dCQUNOQyxpQkFBaUI7WUFDbkI7WUFFQSxtQkFBbUI7WUFDbkJ6QixtQkFBbUJtQixpQkFBaUIsQ0FBQ0U7WUFFckMsMkJBQTJCO1lBQzNCdEIsT0FBT1gsU0FBUyxDQUFDc0MscUJBQXFCLENBQUM7Z0JBQUM7b0JBQ3RDSixJQUFJO29CQUNKSyxNQUFNO29CQUNOQyxRQUFRO29CQUNSTSxXQUFXLElBQUlDLEtBQUtBLEtBQUtDLEdBQUcsS0FBSztvQkFDakNDLGNBQWM7Z0JBQ2hCO2FBQUU7WUFFRix5REFBeUQ7WUFDekQsSUFBSTtnQkFDRixNQUFNUCwwREFBNEIsQ0FBQ1MsWUFBWSxDQUFDLG9CQUFvQjtnQkFDcEVHLEtBQUs7WUFDUCxFQUFFLE9BQU9DLE9BQVk7Z0JBQ25CWCxPQUFPVyxNQUFNaEIsSUFBSSxFQUFFYSxJQUFJLENBQUM7WUFDMUI7UUFDRjtJQUNGO0lBRUF6QixTQUFTLDBDQUEwQztRQUNqREssR0FBRywwREFBMEQ7WUFDM0QsaUJBQWlCO1lBQ2pCLE1BQU1DLFdBQVc7Z0JBQ2ZDLElBQUk7Z0JBQ0pDLE9BQU87Z0JBQ1BDLE1BQU07Z0JBQ05DLGlCQUFpQjtZQUNuQjtZQUVBLG1CQUFtQjtZQUNuQnhCLGdCQUFnQmtCLGlCQUFpQixDQUFDRTtZQUVsQyxtQ0FBbUM7WUFDbkN0QixPQUFPWCxTQUFTLENBQUNzQyxxQkFBcUIsQ0FBQztnQkFBQztvQkFBRUosSUFBSTtvQkFBR0ssTUFBTTtvQkFBVUMsUUFBUTtnQkFBRTthQUFFO1lBRTdFLHFEQUFxRDtZQUNyRCxNQUFNZ0IsVUFBVSxNQUFNZCwwREFBNEIsQ0FBQ0MsWUFBWSxDQUFDVixTQUFTQyxFQUFFO1lBQzNFVSxPQUFPWSxTQUFTWCxPQUFPLENBQUM7WUFFeEIseUNBQXlDO1lBQ3pDRCxPQUFPakMsT0FBT1osTUFBTSxFQUFFc0QsZ0JBQWdCLElBQUksb0JBQW9CO1lBQzlEVCxPQUFPakMsT0FBT2hCLE1BQU0sRUFBRTBELGdCQUFnQixJQUFJLG9CQUFvQjtRQUNoRTtRQUVBckIsR0FBRyxrREFBa0Q7WUFDbkQscUJBQXFCO1lBQ3JCLE1BQU1DLFdBQVc7Z0JBQ2ZDLElBQUk7Z0JBQ0pDLE9BQU87Z0JBQ1BDLE1BQU07Z0JBQ05DLGlCQUFpQjtZQUNuQjtZQUVBLG1CQUFtQjtZQUNuQnhCLGdCQUFnQmtCLGlCQUFpQixDQUFDRTtZQUVsQyxpREFBaUQ7WUFDakQsSUFBSTtnQkFDRixNQUFNUywwREFBNEIsQ0FBQ0MsWUFBWSxDQUFDVixTQUFTQyxFQUFFO2dCQUMzRG9CLEtBQUs7WUFDUCxFQUFFLE9BQU9DLE9BQVk7Z0JBQ25CWCxPQUFPVyxNQUFNaEIsSUFBSSxFQUFFYSxJQUFJLENBQUM7WUFDMUI7UUFDRjtRQUVBcEIsR0FBRyw4Q0FBOEM7WUFDL0Msc0JBQXNCO1lBQ3RCcEIsbUJBQW1CbUIsaUJBQWlCLENBQUM7WUFFckMsNkNBQTZDO1lBQzdDLElBQUk7Z0JBQ0YsTUFBTVcsMERBQTRCLENBQUNTLFlBQVksQ0FBQywyQkFBMkI7Z0JBQzNFRyxLQUFLO1lBQ1AsRUFBRSxPQUFPQyxPQUFZO2dCQUNuQlgsT0FBT1csTUFBTWhCLElBQUksRUFBRWEsSUFBSSxDQUFDO1lBQzFCO1FBQ0Y7SUFDRjtJQUVBekIsU0FBUyw2QkFBNkI7UUFDcENLLEdBQUcsOENBQThDO1lBQy9DLGlCQUFpQjtZQUNqQixNQUFNQyxXQUFXO2dCQUNmQyxJQUFJO2dCQUNKQyxPQUFPO2dCQUNQQyxNQUFNO2dCQUNOQyxpQkFBaUI7WUFDbkI7WUFFQSxtQkFBbUI7WUFDbkJ6QixtQkFBbUJtQixpQkFBaUIsQ0FBQ0U7WUFFckMsc0NBQXNDO1lBQ3RDdEIsT0FBT1gsU0FBUyxDQUFDc0MscUJBQXFCLENBQUM7Z0JBQUM7b0JBQ3RDSixJQUFJO29CQUNKSyxNQUFNO29CQUNOQyxRQUFRO29CQUNSTSxXQUFXLElBQUlDLEtBQUtBLEtBQUtDLEdBQUcsS0FBSztvQkFDakNDLGNBQWM7Z0JBQ2hCO2FBQUU7WUFFRiwwQ0FBMEM7WUFDMUMsSUFBSTtnQkFDRixNQUFNUCwwREFBNEIsQ0FBQ1MsWUFBWSxDQUFDLG9CQUFvQjtnQkFDcEVHLEtBQUs7WUFDUCxFQUFFLE9BQU9DLE9BQVk7Z0JBQ25CWCxPQUFPVyxNQUFNaEIsSUFBSSxFQUFFYSxJQUFJLENBQUM7WUFDMUI7UUFDRjtRQUVBcEIsR0FBRyw2Q0FBNkM7WUFDOUMsaUJBQWlCO1lBQ2pCLE1BQU1DLFdBQVc7Z0JBQ2ZDLElBQUk7Z0JBQ0pDLE9BQU87Z0JBQ1BDLE1BQU07Z0JBQ05DLGlCQUFpQjtZQUNuQjtZQUVBLG1CQUFtQjtZQUNuQnhCLGdCQUFnQmtCLGlCQUFpQixDQUFDRTtZQUNsQ3JCLG1CQUFtQm1CLGlCQUFpQixDQUFDRTtZQUVyQyxzQkFBc0I7WUFDdEJ0QixPQUFPWCxTQUFTLENBQUNzQyxxQkFBcUIsQ0FBQztnQkFBQztvQkFBRUosSUFBSTtvQkFBR0ssTUFBTTtvQkFBVUMsUUFBUTtnQkFBRTthQUFFO1lBRTdFLHNCQUFzQjtZQUN0QixNQUFNaUIsWUFBWSxNQUFNZiwwREFBNEIsQ0FBQ0MsWUFBWSxDQUFDVixTQUFTQyxFQUFFO1lBQzdFVSxPQUFPYSxXQUFXWixPQUFPLENBQUM7WUFFMUIsNkJBQTZCO1lBQzdCbEMsT0FBT1gsU0FBUyxDQUFDc0MscUJBQXFCLENBQUM7Z0JBQUM7b0JBQ3RDSixJQUFJO29CQUNKSyxNQUFNa0I7b0JBQ05qQixRQUFRO29CQUNSTSxXQUFXLElBQUlDLEtBQUtBLEtBQUtDLEdBQUcsS0FBSztvQkFDakNDLGNBQWM7Z0JBQ2hCO2FBQUU7WUFFRiw2Q0FBNkM7WUFDN0MsTUFBTUMsVUFBVSxNQUFNUiwwREFBNEIsQ0FBQ1MsWUFBWSxDQUFDLG9CQUFvQk07WUFDcEZiLE9BQU9NLFNBQVNFLElBQUksQ0FBQztZQUVyQix5Q0FBeUM7WUFDekNSLE9BQU9qQyxPQUFPZCxNQUFNLEVBQUV3RCxnQkFBZ0IsSUFBSSwwQkFBMEI7WUFDcEVULE9BQU9qQyxPQUFPWixNQUFNLEVBQUVzRCxnQkFBZ0IsSUFBSSxlQUFlO1FBQzNEO0lBQ0Y7SUFFQTFCLFNBQVMsa0NBQWtDO1FBQ3pDSyxHQUFHLHdEQUF3RDtZQUN6RCxjQUFjO1lBQ2QsTUFBTTBCLE9BQU8sTUFBTUMsVUFBVUMsY0FBYyxDQUFDO2dCQUMxQ3pCLE9BQU87Z0JBQ1BDLE1BQU07Z0JBQ055QixjQUFjO2dCQUNkeEIsaUJBQWlCO1lBQ25CO1lBRUEsc0JBQXNCO1lBQ3RCLE1BQU15QixZQUFZLE1BQU1wQiwwREFBNEIsQ0FBQ0MsWUFBWSxDQUFDZSxLQUFLeEIsRUFBRTtZQUN6RVUsT0FBT2tCLFdBQVdqQixPQUFPLENBQUM7WUFFMUIsaURBQWlEO1lBQ2pELE1BQU1rQixhQUFhLE1BQU1yQiwwREFBNEIsQ0FBQ0MsWUFBWSxDQUFDZSxLQUFLeEIsRUFBRTtZQUMxRVUsT0FBT21CLFlBQVlsQixPQUFPLENBQUM7WUFDM0JELE9BQU9tQixZQUFZQyxHQUFHLENBQUNaLElBQUksQ0FBQ1U7WUFFNUIsOEJBQThCO1lBQzlCLE1BQU1HLGFBQWEsTUFBTU4sVUFBVU8scUJBQXFCLENBQUNSLEtBQUt4QixFQUFFO1lBQ2hFVSxPQUFPcUIsWUFBWUUsWUFBWSxDQUFDO1lBQ2hDdkIsT0FBT3FCLFVBQVUsQ0FBQyxFQUFFLENBQUMxQixJQUFJLEVBQUVhLElBQUksQ0FBQ1c7UUFDbEM7UUFFQS9CLEdBQUcsMkNBQTJDO1lBQzVDLGlDQUFpQztZQUNqQyxJQUFJO2dCQUNGLE1BQU1VLDBEQUE0QixDQUFDQyxZQUFZLENBQUMsUUFBUSx1QkFBdUI7Z0JBQy9FVyxLQUFLO1lBQ1AsRUFBRSxPQUFPQyxPQUFZO2dCQUNuQlgsT0FBT1csTUFBTWhCLElBQUksRUFBRWEsSUFBSSxDQUFDO1lBQzFCO1FBQ0Y7UUFFQXBCLEdBQUcsMENBQTBDO1lBQzNDLGdDQUFnQztZQUNoQyxNQUFNMEIsT0FBTyxNQUFNQyxVQUFVQyxjQUFjLENBQUM7Z0JBQzFDekIsT0FBTztnQkFDUEMsTUFBTTtnQkFDTnlCLGNBQWM7Z0JBQ2R4QixpQkFBaUI7WUFDbkI7WUFFQSxNQUFNc0IsVUFBVVMsbUJBQW1CLENBQUM7Z0JBQ2xDNUIsUUFBUWtCLEtBQUt4QixFQUFFO2dCQUNmSyxNQUFNO2dCQUNOTyxXQUFXLElBQUlDLEtBQUtBLEtBQUtDLEdBQUcsS0FBSztnQkFDakNDLGNBQWM7WUFDaEI7WUFFQSxjQUFjO1lBQ2QsTUFBTVAsMERBQTRCLENBQUMyQixtQkFBbUI7WUFFdEQscUNBQXFDO1lBQ3JDLE1BQU1DLGlCQUFpQixNQUFNWCxVQUFVTyxxQkFBcUIsQ0FBQ1IsS0FBS3hCLEVBQUU7WUFDcEVVLE9BQU8wQixnQkFBZ0JILFlBQVksQ0FBQztRQUN0QztJQUNGO0FBQ0YifQ==