e13b1dc9a671ae567cd645bd60c54a98
// Component render test helpers
"use strict";
// Mock useRouter hook
jest.mock('next/navigation', ()=>({
        useRouter: ()=>mockRouter,
        usePathname: ()=>'/',
        useSearchParams: ()=>new URLSearchParams()
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get TestProviders () {
        return TestProviders;
    },
    get createTestQueryClient () {
        return createTestQueryClient;
    },
    get mockApiError () {
        return mockApiError;
    },
    get mockApiResponses () {
        return mockApiResponses;
    },
    get renderAndWaitForLoading () {
        return renderAndWaitForLoading;
    },
    get renderWithAuthenticatedUser () {
        return renderWithAuthenticatedUser;
    },
    get renderWithCuratorUser () {
        return renderWithCuratorUser;
    },
    get renderWithProviders () {
        return renderWithProviders;
    },
    get resetTestState () {
        return resetTestState;
    },
    get testUtils () {
        return testUtils;
    },
    get userInteractions () {
        return userInteractions;
    },
    get waitForElement () {
        return waitForElement;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
const _userevent = /*#__PURE__*/ _interop_require_default(require("@testing-library/user-event"));
const _reactquery = require("@tanstack/react-query");
const _UserProvider = require("../../components/auth/UserProvider");
const _userfactory = require("../factories/user-factory.js");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Mock Next.js router
const mockRouter = {
    push: jest.fn(),
    replace: jest.fn(),
    back: jest.fn(),
    forward: jest.fn(),
    refresh: jest.fn(),
    prefetch: jest.fn(),
    pathname: '/',
    route: '/',
    query: {},
    asPath: '/',
    basePath: '',
    isLocaleDomain: true,
    isReady: true,
    isPreview: false
};
const createTestQueryClient = ()=>{
    return new _reactquery.QueryClient({
        defaultOptions: {
            queries: {
                retry: false,
                gcTime: 0,
                staleTime: 0
            },
            mutations: {
                retry: false
            }
        },
        logger: {
            log: ()=>{},
            warn: ()=>{},
            error: ()=>{}
        }
    });
};
const TestProviders = ({ children, user = null, queryClient = createTestQueryClient() })=>{
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_reactquery.QueryClientProvider, {
        client: queryClient,
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_UserProvider.UserProvider, {
            user: user,
            children: children
        })
    });
};
const renderWithProviders = (ui, options = {})=>{
    const { user = null, queryClient = createTestQueryClient(), route = '/', routerMock = {}, ...renderOptions } = options;
    // Update router mock with custom values
    Object.assign(mockRouter, {
        pathname: route,
        asPath: route,
        route: route,
        ...routerMock
    });
    // Create wrapper with providers
    const Wrapper = ({ children })=>/*#__PURE__*/ (0, _jsxruntime.jsx)(TestProviders, {
            user: user,
            queryClient: queryClient,
            children: children
        });
    // Render component
    const renderResult = (0, _react1.render)(ui, {
        wrapper: Wrapper,
        ...renderOptions
    });
    // Return enhanced result with utilities
    return {
        ...renderResult,
        user: _userevent.default.setup(),
        queryClient,
        router: mockRouter
    };
};
const renderWithAuthenticatedUser = (ui, options = {})=>{
    const { userOverrides = {}, sessionOverrides = {}, ...renderOptions } = options;
    const { user, session } = (0, _userfactory.createAuthenticatedTestUser)(userOverrides, sessionOverrides);
    const result = renderWithProviders(ui, {
        user,
        ...renderOptions
    });
    return {
        ...result,
        testUser: user,
        testSession: session
    };
};
const renderWithCuratorUser = (ui, options = {})=>{
    return renderWithAuthenticatedUser(ui, {
        userOverrides: {
            isCurator: true
        },
        ...options
    });
};
const renderAndWaitForLoading = async (ui, options = {})=>{
    const result = renderWithProviders(ui, options);
    // Wait for any loading indicators to disappear
    await (0, _react1.waitFor)(()=>{
        expect(_react1.screen.queryByText(/loading/i)).not.toBeInTheDocument();
        expect(_react1.screen.queryByRole('progressbar')).not.toBeInTheDocument();
    }, {
        timeout: 5000
    });
    return result;
};
const mockApiResponses = (responses)=>{
    global.fetch = jest.fn((url)=>{
        const endpoint = url.toString();
        for (const [pattern, response] of Object.entries(responses)){
            if (endpoint.includes(pattern)) {
                return Promise.resolve({
                    ok: true,
                    status: 200,
                    json: ()=>Promise.resolve(response),
                    text: ()=>Promise.resolve(JSON.stringify(response))
                });
            }
        }
        // Default response for unmatched endpoints
        return Promise.resolve({
            ok: false,
            status: 404,
            json: ()=>Promise.resolve({
                    error: 'Not found'
                })
        });
    });
};
const mockApiError = (endpoint, status = 500, error = {
    error: 'Internal server error'
})=>{
    global.fetch = jest.fn((url)=>{
        if (url.toString().includes(endpoint)) {
            return Promise.resolve({
                ok: false,
                status,
                json: ()=>Promise.resolve(error),
                text: ()=>Promise.resolve(JSON.stringify(error))
            });
        }
        // Call original fetch for other endpoints
        return jest.requireActual('node-fetch')(url);
    });
};
const waitForElement = async (query, options = {})=>{
    const { timeout = 5000, interval = 50 } = options;
    return (0, _react1.waitFor)(query, {
        timeout,
        interval
    });
};
const userInteractions = {
    /**
   * Fill out a form with provided data
   * @param {Object} formData - Object with field names and values
   * @param {Object} user - userEvent instance
   */ fillForm: async (formData, user)=>{
        for (const [fieldName, value] of Object.entries(formData)){
            const field = _react1.screen.getByLabelText(new RegExp(fieldName, 'i')) || _react1.screen.getByPlaceholderText(new RegExp(fieldName, 'i')) || _react1.screen.getByRole('textbox', {
                name: new RegExp(fieldName, 'i')
            });
            if (field) {
                await user.clear(field);
                await user.type(field, value);
            }
        }
    },
    /**
   * Submit a form by clicking submit button
   * @param {Object} user - userEvent instance
   * @param {string} buttonText - Submit button text (default: 'submit')
   */ submitForm: async (user, buttonText = 'submit')=>{
        const submitButton = _react1.screen.getByRole('button', {
            name: new RegExp(buttonText, 'i')
        });
        await user.click(submitButton);
    },
    /**
   * Navigate using router mock
   * @param {string} path - Path to navigate to
   */ navigate: (path)=>{
        mockRouter.push(path);
    },
    /**
   * Select option from dropdown/select
   * @param {string} selectLabel - Label of the select element
   * @param {string} optionText - Text of the option to select
   * @param {Object} user - userEvent instance
   */ selectOption: async (selectLabel, optionText, user)=>{
        const select = _react1.screen.getByLabelText(new RegExp(selectLabel, 'i'));
        await user.selectOptions(select, optionText);
    },
    /**
   * Upload file to file input
   * @param {string} inputLabel - Label of the file input
   * @param {File} file - File object to upload
   * @param {Object} user - userEvent instance
   */ uploadFile: async (inputLabel, file, user)=>{
        const fileInput = _react1.screen.getByLabelText(new RegExp(inputLabel, 'i'));
        await user.upload(fileInput, file);
    }
};
const testUtils = {
    /**
   * Assert that an element has specific text content
   * @param {string} text - Text to search for
   * @param {Object} options - Query options
   */ expectTextToBeInDocument: (text, options = {})=>{
        expect(_react1.screen.getByText(text, options)).toBeInTheDocument();
    },
    /**
   * Assert that an element is not in the document
   * @param {string} text - Text to search for
   */ expectTextNotToBeInDocument: (text)=>{
        expect(_react1.screen.queryByText(text)).not.toBeInTheDocument();
    },
    /**
   * Assert that a form field has specific value
   * @param {string} fieldName - Field label or placeholder
   * @param {string} expectedValue - Expected field value
   */ expectFieldValue: (fieldName, expectedValue)=>{
        const field = _react1.screen.getByLabelText(new RegExp(fieldName, 'i')) || _react1.screen.getByPlaceholderText(new RegExp(fieldName, 'i'));
        expect(field).toHaveValue(expectedValue);
    },
    /**
   * Assert that an API call was made with specific parameters
   * @param {string} endpoint - Endpoint pattern
   * @param {Object} expectedData - Expected request data
   */ expectApiCall: (endpoint, expectedData = null)=>{
        expect(global.fetch).toHaveBeenCalledWith(expect.stringContaining(endpoint), expectedData ? expect.objectContaining({
            body: JSON.stringify(expectedData)
        }) : expect.any(Object));
    }
};
const resetTestState = ()=>{
    jest.clearAllMocks();
    mockRouter.push.mockClear();
    mockRouter.replace.mockClear();
    // Reset fetch mock
    if (global.fetch && global.fetch.mockRestore) {
        global.fetch.mockRestore();
    }
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdGVmYW5iZWtrZXIvcHJvamVjdHMvZmFuY3ktcGxhbnRpZXMvc3JjL3Rlc3QtdXRpbHMvaGVscGVycy9yZW5kZXItaGVscGVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb21wb25lbnQgcmVuZGVyIHRlc3QgaGVscGVyc1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgcmVuZGVyLCBzY3JlZW4sIHdhaXRGb3IgfSBmcm9tICdAdGVzdGluZy1saWJyYXJ5L3JlYWN0JztcbmltcG9ydCB1c2VyRXZlbnQgZnJvbSAnQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50JztcbmltcG9ydCB7IFF1ZXJ5Q2xpZW50LCBRdWVyeUNsaWVudFByb3ZpZGVyIH0gZnJvbSAnQHRhbnN0YWNrL3JlYWN0LXF1ZXJ5JztcbmltcG9ydCB7IFVzZXJQcm92aWRlciB9IGZyb20gJ0AvY29tcG9uZW50cy9hdXRoL1VzZXJQcm92aWRlcic7XG5pbXBvcnQgeyBjcmVhdGVUZXN0VXNlciwgY3JlYXRlQXV0aGVudGljYXRlZFRlc3RVc2VyIH0gZnJvbSAnLi4vZmFjdG9yaWVzL3VzZXItZmFjdG9yeSc7XG5cbi8vIE1vY2sgTmV4dC5qcyByb3V0ZXJcbmNvbnN0IG1vY2tSb3V0ZXIgPSB7XG4gIHB1c2g6IGplc3QuZm4oKSxcbiAgcmVwbGFjZTogamVzdC5mbigpLFxuICBiYWNrOiBqZXN0LmZuKCksXG4gIGZvcndhcmQ6IGplc3QuZm4oKSxcbiAgcmVmcmVzaDogamVzdC5mbigpLFxuICBwcmVmZXRjaDogamVzdC5mbigpLFxuICBwYXRobmFtZTogJy8nLFxuICByb3V0ZTogJy8nLFxuICBxdWVyeToge30sXG4gIGFzUGF0aDogJy8nLFxuICBiYXNlUGF0aDogJycsXG4gIGlzTG9jYWxlRG9tYWluOiB0cnVlLFxuICBpc1JlYWR5OiB0cnVlLFxuICBpc1ByZXZpZXc6IGZhbHNlLFxufTtcblxuLy8gTW9jayB1c2VSb3V0ZXIgaG9va1xuamVzdC5tb2NrKCduZXh0L25hdmlnYXRpb24nLCAoKSA9PiAoe1xuICB1c2VSb3V0ZXI6ICgpID0+IG1vY2tSb3V0ZXIsXG4gIHVzZVBhdGhuYW1lOiAoKSA9PiAnLycsXG4gIHVzZVNlYXJjaFBhcmFtczogKCkgPT4gbmV3IFVSTFNlYXJjaFBhcmFtcygpLFxufSkpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0ZXN0IFF1ZXJ5Q2xpZW50IHdpdGggb3B0aW1pemVkIHNldHRpbmdzIGZvciB0ZXN0aW5nXG4gKiBAcmV0dXJucyB7UXVlcnlDbGllbnR9IENvbmZpZ3VyZWQgUXVlcnlDbGllbnQgZm9yIHRlc3RpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVRlc3RRdWVyeUNsaWVudCA9ICgpID0+IHtcbiAgcmV0dXJuIG5ldyBRdWVyeUNsaWVudCh7XG4gICAgZGVmYXVsdE9wdGlvbnM6IHtcbiAgICAgIHF1ZXJpZXM6IHtcbiAgICAgICAgcmV0cnk6IGZhbHNlLFxuICAgICAgICBnY1RpbWU6IDAsXG4gICAgICAgIHN0YWxlVGltZTogMCxcbiAgICAgIH0sXG4gICAgICBtdXRhdGlvbnM6IHtcbiAgICAgICAgcmV0cnk6IGZhbHNlLFxuICAgICAgfSxcbiAgICB9LFxuICAgIGxvZ2dlcjoge1xuICAgICAgbG9nOiAoKSA9PiB7fSxcbiAgICAgIHdhcm46ICgpID0+IHt9LFxuICAgICAgZXJyb3I6ICgpID0+IHt9LFxuICAgIH0sXG4gIH0pO1xufTtcblxuLyoqXG4gKiBXcmFwcGVyIGNvbXBvbmVudCB0aGF0IHByb3ZpZGVzIGFsbCBuZWNlc3NhcnkgcHJvdmlkZXJzIGZvciB0ZXN0aW5nXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBXcmFwcGVyIHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0LlJlYWN0Tm9kZX0gcHJvcHMuY2hpbGRyZW4gLSBDaGlsZCBjb21wb25lbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMudXNlciAtIFVzZXIgb2JqZWN0IGZvciBVc2VyUHJvdmlkZXJcbiAqIEBwYXJhbSB7UXVlcnlDbGllbnR9IHByb3BzLnF1ZXJ5Q2xpZW50IC0gUXVlcnlDbGllbnQgaW5zdGFuY2VcbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudH0gV3JhcHBlZCBjb21wb25lbnRcbiAqL1xuZXhwb3J0IGNvbnN0IFRlc3RQcm92aWRlcnMgPSAoeyBcbiAgY2hpbGRyZW4sIFxuICB1c2VyID0gbnVsbCwgXG4gIHF1ZXJ5Q2xpZW50ID0gY3JlYXRlVGVzdFF1ZXJ5Q2xpZW50KCkgXG59KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPFF1ZXJ5Q2xpZW50UHJvdmlkZXIgY2xpZW50PXtxdWVyeUNsaWVudH0+XG4gICAgICA8VXNlclByb3ZpZGVyIHVzZXI9e3VzZXJ9PlxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8L1VzZXJQcm92aWRlcj5cbiAgICA8L1F1ZXJ5Q2xpZW50UHJvdmlkZXI+XG4gICk7XG59O1xuXG4vKipcbiAqIEVuaGFuY2VkIHJlbmRlciBmdW5jdGlvbiB3aXRoIGFsbCBwcm92aWRlcnMgYW5kIHV0aWxpdGllc1xuICogQHBhcmFtIHtSZWFjdC5SZWFjdEVsZW1lbnR9IHVpIC0gQ29tcG9uZW50IHRvIHJlbmRlclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBSZW5kZXIgb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMudXNlciAtIFVzZXIgb2JqZWN0IGZvciBhdXRoZW50aWNhdGlvbiBjb250ZXh0XG4gKiBAcGFyYW0ge1F1ZXJ5Q2xpZW50fSBvcHRpb25zLnF1ZXJ5Q2xpZW50IC0gQ3VzdG9tIFF1ZXJ5Q2xpZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5yb3V0ZSAtIEluaXRpYWwgcm91dGUgZm9yIHJvdXRlciBtb2NrXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5yb3V0ZXJNb2NrIC0gQ3VzdG9tIHJvdXRlciBtb2NrIG92ZXJyaWRlc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucmVuZGVyT3B0aW9ucyAtIEFkZGl0aW9uYWwgcmVuZGVyIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlbmRlciByZXN1bHQgd2l0aCBhZGRpdGlvbmFsIHV0aWxpdGllc1xuICovXG5leHBvcnQgY29uc3QgcmVuZGVyV2l0aFByb3ZpZGVycyA9ICh1aSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IHtcbiAgICB1c2VyID0gbnVsbCxcbiAgICBxdWVyeUNsaWVudCA9IGNyZWF0ZVRlc3RRdWVyeUNsaWVudCgpLFxuICAgIHJvdXRlID0gJy8nLFxuICAgIHJvdXRlck1vY2sgPSB7fSxcbiAgICAuLi5yZW5kZXJPcHRpb25zXG4gIH0gPSBvcHRpb25zO1xuXG4gIC8vIFVwZGF0ZSByb3V0ZXIgbW9jayB3aXRoIGN1c3RvbSB2YWx1ZXNcbiAgT2JqZWN0LmFzc2lnbihtb2NrUm91dGVyLCB7XG4gICAgcGF0aG5hbWU6IHJvdXRlLFxuICAgIGFzUGF0aDogcm91dGUsXG4gICAgcm91dGU6IHJvdXRlLFxuICAgIC4uLnJvdXRlck1vY2ssXG4gIH0pO1xuXG4gIC8vIENyZWF0ZSB3cmFwcGVyIHdpdGggcHJvdmlkZXJzXG4gIGNvbnN0IFdyYXBwZXIgPSAoeyBjaGlsZHJlbiB9KSA9PiAoXG4gICAgPFRlc3RQcm92aWRlcnMgdXNlcj17dXNlcn0gcXVlcnlDbGllbnQ9e3F1ZXJ5Q2xpZW50fT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L1Rlc3RQcm92aWRlcnM+XG4gICk7XG5cbiAgLy8gUmVuZGVyIGNvbXBvbmVudFxuICBjb25zdCByZW5kZXJSZXN1bHQgPSByZW5kZXIodWksIHsgd3JhcHBlcjogV3JhcHBlciwgLi4ucmVuZGVyT3B0aW9ucyB9KTtcblxuICAvLyBSZXR1cm4gZW5oYW5jZWQgcmVzdWx0IHdpdGggdXRpbGl0aWVzXG4gIHJldHVybiB7XG4gICAgLi4ucmVuZGVyUmVzdWx0LFxuICAgIHVzZXI6IHVzZXJFdmVudC5zZXR1cCgpLFxuICAgIHF1ZXJ5Q2xpZW50LFxuICAgIHJvdXRlcjogbW9ja1JvdXRlcixcbiAgfTtcbn07XG5cbi8qKlxuICogUmVuZGVyIGNvbXBvbmVudCB3aXRoIGF1dGhlbnRpY2F0ZWQgdXNlciBjb250ZXh0XG4gKiBAcGFyYW0ge1JlYWN0LlJlYWN0RWxlbWVudH0gdWkgLSBDb21wb25lbnQgdG8gcmVuZGVyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFJlbmRlciBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy51c2VyT3ZlcnJpZGVzIC0gVXNlciBvYmplY3Qgb3ZlcnJpZGVzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5zZXNzaW9uT3ZlcnJpZGVzIC0gU2Vzc2lvbiBvYmplY3Qgb3ZlcnJpZGVzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZW5kZXIgcmVzdWx0IHdpdGggdXNlciBhbmQgc2Vzc2lvbiBkYXRhXG4gKi9cbmV4cG9ydCBjb25zdCByZW5kZXJXaXRoQXV0aGVudGljYXRlZFVzZXIgPSAodWksIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCB7IHVzZXJPdmVycmlkZXMgPSB7fSwgc2Vzc2lvbk92ZXJyaWRlcyA9IHt9LCAuLi5yZW5kZXJPcHRpb25zIH0gPSBvcHRpb25zO1xuICBcbiAgY29uc3QgeyB1c2VyLCBzZXNzaW9uIH0gPSBjcmVhdGVBdXRoZW50aWNhdGVkVGVzdFVzZXIodXNlck92ZXJyaWRlcywgc2Vzc2lvbk92ZXJyaWRlcyk7XG4gIFxuICBjb25zdCByZXN1bHQgPSByZW5kZXJXaXRoUHJvdmlkZXJzKHVpLCB7XG4gICAgdXNlcixcbiAgICAuLi5yZW5kZXJPcHRpb25zLFxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIC4uLnJlc3VsdCxcbiAgICB0ZXN0VXNlcjogdXNlcixcbiAgICB0ZXN0U2Vzc2lvbjogc2Vzc2lvbixcbiAgfTtcbn07XG5cbi8qKlxuICogUmVuZGVyIGNvbXBvbmVudCB3aXRoIGN1cmF0b3IvYWRtaW4gdXNlciBjb250ZXh0XG4gKiBAcGFyYW0ge1JlYWN0LlJlYWN0RWxlbWVudH0gdWkgLSBDb21wb25lbnQgdG8gcmVuZGVyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFJlbmRlciBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZW5kZXIgcmVzdWx0IHdpdGggY3VyYXRvciB1c2VyIGRhdGFcbiAqL1xuZXhwb3J0IGNvbnN0IHJlbmRlcldpdGhDdXJhdG9yVXNlciA9ICh1aSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIHJldHVybiByZW5kZXJXaXRoQXV0aGVudGljYXRlZFVzZXIodWksIHtcbiAgICB1c2VyT3ZlcnJpZGVzOiB7IGlzQ3VyYXRvcjogdHJ1ZSB9LFxuICAgIC4uLm9wdGlvbnMsXG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZW5kZXIgY29tcG9uZW50IGFuZCB3YWl0IGZvciBsb2FkaW5nIHN0YXRlcyB0byBjb21wbGV0ZVxuICogQHBhcmFtIHtSZWFjdC5SZWFjdEVsZW1lbnR9IHVpIC0gQ29tcG9uZW50IHRvIHJlbmRlclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBSZW5kZXIgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gUmVuZGVyIHJlc3VsdCBhZnRlciBsb2FkaW5nIGNvbXBsZXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHJlbmRlckFuZFdhaXRGb3JMb2FkaW5nID0gYXN5bmMgKHVpLCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gcmVuZGVyV2l0aFByb3ZpZGVycyh1aSwgb3B0aW9ucyk7XG4gIFxuICAvLyBXYWl0IGZvciBhbnkgbG9hZGluZyBpbmRpY2F0b3JzIHRvIGRpc2FwcGVhclxuICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICBleHBlY3Qoc2NyZWVuLnF1ZXJ5QnlUZXh0KC9sb2FkaW5nL2kpKS5ub3QudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICBleHBlY3Qoc2NyZWVuLnF1ZXJ5QnlSb2xlKCdwcm9ncmVzc2JhcicpKS5ub3QudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgfSwgeyB0aW1lb3V0OiA1MDAwIH0pO1xuICBcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogTW9jayBBUEkgcmVzcG9uc2VzIGZvciB0ZXN0aW5nXG4gKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2VzIC0gT2JqZWN0IG1hcHBpbmcgZW5kcG9pbnRzIHRvIHJlc3BvbnNlIGRhdGFcbiAqL1xuZXhwb3J0IGNvbnN0IG1vY2tBcGlSZXNwb25zZXMgPSAocmVzcG9uc2VzKSA9PiB7XG4gIGdsb2JhbC5mZXRjaCA9IGplc3QuZm4oKHVybCkgPT4ge1xuICAgIGNvbnN0IGVuZHBvaW50ID0gdXJsLnRvU3RyaW5nKCk7XG4gICAgXG4gICAgZm9yIChjb25zdCBbcGF0dGVybiwgcmVzcG9uc2VdIG9mIE9iamVjdC5lbnRyaWVzKHJlc3BvbnNlcykpIHtcbiAgICAgIGlmIChlbmRwb2ludC5pbmNsdWRlcyhwYXR0ZXJuKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUocmVzcG9uc2UpLFxuICAgICAgICAgIHRleHQ6ICgpID0+IFByb21pc2UucmVzb2x2ZShKU09OLnN0cmluZ2lmeShyZXNwb25zZSkpLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gRGVmYXVsdCByZXNwb25zZSBmb3IgdW5tYXRjaGVkIGVuZHBvaW50c1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgb2s6IGZhbHNlLFxuICAgICAgc3RhdHVzOiA0MDQsXG4gICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoeyBlcnJvcjogJ05vdCBmb3VuZCcgfSksXG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBNb2NrIEFQSSBlcnJvciByZXNwb25zZXMgZm9yIHRlc3RpbmcgZXJyb3IgaGFuZGxpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmRwb2ludCAtIEVuZHBvaW50IHBhdHRlcm4gdG8gbW9ja1xuICogQHBhcmFtIHtudW1iZXJ9IHN0YXR1cyAtIEhUVFAgc3RhdHVzIGNvZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBlcnJvciAtIEVycm9yIHJlc3BvbnNlIGRhdGFcbiAqL1xuZXhwb3J0IGNvbnN0IG1vY2tBcGlFcnJvciA9IChlbmRwb2ludCwgc3RhdHVzID0gNTAwLCBlcnJvciA9IHsgZXJyb3I6ICdJbnRlcm5hbCBzZXJ2ZXIgZXJyb3InIH0pID0+IHtcbiAgZ2xvYmFsLmZldGNoID0gamVzdC5mbigodXJsKSA9PiB7XG4gICAgaWYgKHVybC50b1N0cmluZygpLmluY2x1ZGVzKGVuZHBvaW50KSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoZXJyb3IpLFxuICAgICAgICB0ZXh0OiAoKSA9PiBQcm9taXNlLnJlc29sdmUoSlNPTi5zdHJpbmdpZnkoZXJyb3IpKSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBDYWxsIG9yaWdpbmFsIGZldGNoIGZvciBvdGhlciBlbmRwb2ludHNcbiAgICByZXR1cm4gamVzdC5yZXF1aXJlQWN0dWFsKCdub2RlLWZldGNoJykodXJsKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFdhaXQgZm9yIGVsZW1lbnQgdG8gYXBwZWFyIHdpdGggY3VzdG9tIHRpbWVvdXRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHF1ZXJ5IC0gUXVlcnkgZnVuY3Rpb24gKGUuZy4sICgpID0+IHNjcmVlbi5nZXRCeVRleHQoJ3RleHQnKSlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gV2FpdCBvcHRpb25zXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gZWxlbWVudCBhcHBlYXJzXG4gKi9cbmV4cG9ydCBjb25zdCB3YWl0Rm9yRWxlbWVudCA9IGFzeW5jIChxdWVyeSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IHsgdGltZW91dCA9IDUwMDAsIGludGVydmFsID0gNTAgfSA9IG9wdGlvbnM7XG4gIFxuICByZXR1cm4gd2FpdEZvcihxdWVyeSwgeyB0aW1lb3V0LCBpbnRlcnZhbCB9KTtcbn07XG5cbi8qKlxuICogU2ltdWxhdGUgdXNlciBpbnRlcmFjdGlvbnMgd2l0aCBjb21tb24gcGF0dGVybnNcbiAqL1xuZXhwb3J0IGNvbnN0IHVzZXJJbnRlcmFjdGlvbnMgPSB7XG4gIC8qKlxuICAgKiBGaWxsIG91dCBhIGZvcm0gd2l0aCBwcm92aWRlZCBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmb3JtRGF0YSAtIE9iamVjdCB3aXRoIGZpZWxkIG5hbWVzIGFuZCB2YWx1ZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IHVzZXIgLSB1c2VyRXZlbnQgaW5zdGFuY2VcbiAgICovXG4gIGZpbGxGb3JtOiBhc3luYyAoZm9ybURhdGEsIHVzZXIpID0+IHtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhmb3JtRGF0YSkpIHtcbiAgICAgIGNvbnN0IGZpZWxkID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KG5ldyBSZWdFeHAoZmllbGROYW1lLCAnaScpKSB8fCBcbiAgICAgICAgICAgICAgICAgICBzY3JlZW4uZ2V0QnlQbGFjZWhvbGRlclRleHQobmV3IFJlZ0V4cChmaWVsZE5hbWUsICdpJykpIHx8XG4gICAgICAgICAgICAgICAgICAgc2NyZWVuLmdldEJ5Um9sZSgndGV4dGJveCcsIHsgbmFtZTogbmV3IFJlZ0V4cChmaWVsZE5hbWUsICdpJykgfSk7XG4gICAgICBcbiAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICBhd2FpdCB1c2VyLmNsZWFyKGZpZWxkKTtcbiAgICAgICAgYXdhaXQgdXNlci50eXBlKGZpZWxkLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTdWJtaXQgYSBmb3JtIGJ5IGNsaWNraW5nIHN1Ym1pdCBidXR0b25cbiAgICogQHBhcmFtIHtPYmplY3R9IHVzZXIgLSB1c2VyRXZlbnQgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJ1dHRvblRleHQgLSBTdWJtaXQgYnV0dG9uIHRleHQgKGRlZmF1bHQ6ICdzdWJtaXQnKVxuICAgKi9cbiAgc3VibWl0Rm9ybTogYXN5bmMgKHVzZXIsIGJ1dHRvblRleHQgPSAnc3VibWl0JykgPT4ge1xuICAgIGNvbnN0IHN1Ym1pdEJ1dHRvbiA9IHNjcmVlbi5nZXRCeVJvbGUoJ2J1dHRvbicsIHsgbmFtZTogbmV3IFJlZ0V4cChidXR0b25UZXh0LCAnaScpIH0pO1xuICAgIGF3YWl0IHVzZXIuY2xpY2soc3VibWl0QnV0dG9uKTtcbiAgfSxcblxuICAvKipcbiAgICogTmF2aWdhdGUgdXNpbmcgcm91dGVyIG1vY2tcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSBQYXRoIHRvIG5hdmlnYXRlIHRvXG4gICAqL1xuICBuYXZpZ2F0ZTogKHBhdGgpID0+IHtcbiAgICBtb2NrUm91dGVyLnB1c2gocGF0aCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNlbGVjdCBvcHRpb24gZnJvbSBkcm9wZG93bi9zZWxlY3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdExhYmVsIC0gTGFiZWwgb2YgdGhlIHNlbGVjdCBlbGVtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25UZXh0IC0gVGV4dCBvZiB0aGUgb3B0aW9uIHRvIHNlbGVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gdXNlciAtIHVzZXJFdmVudCBpbnN0YW5jZVxuICAgKi9cbiAgc2VsZWN0T3B0aW9uOiBhc3luYyAoc2VsZWN0TGFiZWwsIG9wdGlvblRleHQsIHVzZXIpID0+IHtcbiAgICBjb25zdCBzZWxlY3QgPSBzY3JlZW4uZ2V0QnlMYWJlbFRleHQobmV3IFJlZ0V4cChzZWxlY3RMYWJlbCwgJ2knKSk7XG4gICAgYXdhaXQgdXNlci5zZWxlY3RPcHRpb25zKHNlbGVjdCwgb3B0aW9uVGV4dCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwbG9hZCBmaWxlIHRvIGZpbGUgaW5wdXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0TGFiZWwgLSBMYWJlbCBvZiB0aGUgZmlsZSBpbnB1dFxuICAgKiBAcGFyYW0ge0ZpbGV9IGZpbGUgLSBGaWxlIG9iamVjdCB0byB1cGxvYWRcbiAgICogQHBhcmFtIHtPYmplY3R9IHVzZXIgLSB1c2VyRXZlbnQgaW5zdGFuY2VcbiAgICovXG4gIHVwbG9hZEZpbGU6IGFzeW5jIChpbnB1dExhYmVsLCBmaWxlLCB1c2VyKSA9PiB7XG4gICAgY29uc3QgZmlsZUlucHV0ID0gc2NyZWVuLmdldEJ5TGFiZWxUZXh0KG5ldyBSZWdFeHAoaW5wdXRMYWJlbCwgJ2knKSk7XG4gICAgYXdhaXQgdXNlci51cGxvYWQoZmlsZUlucHV0LCBmaWxlKTtcbiAgfSxcbn07XG5cbi8qKlxuICogQ29tbW9uIHRlc3QgdXRpbGl0aWVzIGZvciBhc3NlcnRpb25zXG4gKi9cbmV4cG9ydCBjb25zdCB0ZXN0VXRpbHMgPSB7XG4gIC8qKlxuICAgKiBBc3NlcnQgdGhhdCBhbiBlbGVtZW50IGhhcyBzcGVjaWZpYyB0ZXh0IGNvbnRlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUZXh0IHRvIHNlYXJjaCBmb3JcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBRdWVyeSBvcHRpb25zXG4gICAqL1xuICBleHBlY3RUZXh0VG9CZUluRG9jdW1lbnQ6ICh0ZXh0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCh0ZXh0LCBvcHRpb25zKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgfSxcblxuICAvKipcbiAgICogQXNzZXJ0IHRoYXQgYW4gZWxlbWVudCBpcyBub3QgaW4gdGhlIGRvY3VtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gVGV4dCB0byBzZWFyY2ggZm9yXG4gICAqL1xuICBleHBlY3RUZXh0Tm90VG9CZUluRG9jdW1lbnQ6ICh0ZXh0KSA9PiB7XG4gICAgZXhwZWN0KHNjcmVlbi5xdWVyeUJ5VGV4dCh0ZXh0KSkubm90LnRvQmVJblRoZURvY3VtZW50KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFzc2VydCB0aGF0IGEgZm9ybSBmaWVsZCBoYXMgc3BlY2lmaWMgdmFsdWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkTmFtZSAtIEZpZWxkIGxhYmVsIG9yIHBsYWNlaG9sZGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBleHBlY3RlZFZhbHVlIC0gRXhwZWN0ZWQgZmllbGQgdmFsdWVcbiAgICovXG4gIGV4cGVjdEZpZWxkVmFsdWU6IChmaWVsZE5hbWUsIGV4cGVjdGVkVmFsdWUpID0+IHtcbiAgICBjb25zdCBmaWVsZCA9IHNjcmVlbi5nZXRCeUxhYmVsVGV4dChuZXcgUmVnRXhwKGZpZWxkTmFtZSwgJ2knKSkgfHwgXG4gICAgICAgICAgICAgICAgIHNjcmVlbi5nZXRCeVBsYWNlaG9sZGVyVGV4dChuZXcgUmVnRXhwKGZpZWxkTmFtZSwgJ2knKSk7XG4gICAgZXhwZWN0KGZpZWxkKS50b0hhdmVWYWx1ZShleHBlY3RlZFZhbHVlKTtcbiAgfSxcblxuICAvKipcbiAgICogQXNzZXJ0IHRoYXQgYW4gQVBJIGNhbGwgd2FzIG1hZGUgd2l0aCBzcGVjaWZpYyBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbmRwb2ludCAtIEVuZHBvaW50IHBhdHRlcm5cbiAgICogQHBhcmFtIHtPYmplY3R9IGV4cGVjdGVkRGF0YSAtIEV4cGVjdGVkIHJlcXVlc3QgZGF0YVxuICAgKi9cbiAgZXhwZWN0QXBpQ2FsbDogKGVuZHBvaW50LCBleHBlY3RlZERhdGEgPSBudWxsKSA9PiB7XG4gICAgZXhwZWN0KGdsb2JhbC5mZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZyhlbmRwb2ludCksXG4gICAgICBleHBlY3RlZERhdGEgPyBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkRGF0YSlcbiAgICAgIH0pIDogZXhwZWN0LmFueShPYmplY3QpXG4gICAgKTtcbiAgfSxcbn07XG5cbi8qKlxuICogUmVzZXQgYWxsIG1vY2tzIGFuZCB0ZXN0IHN0YXRlXG4gKi9cbmV4cG9ydCBjb25zdCByZXNldFRlc3RTdGF0ZSA9ICgpID0+IHtcbiAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gIG1vY2tSb3V0ZXIucHVzaC5tb2NrQ2xlYXIoKTtcbiAgbW9ja1JvdXRlci5yZXBsYWNlLm1vY2tDbGVhcigpO1xuICBcbiAgLy8gUmVzZXQgZmV0Y2ggbW9ja1xuICBpZiAoZ2xvYmFsLmZldGNoICYmIGdsb2JhbC5mZXRjaC5tb2NrUmVzdG9yZSkge1xuICAgIGdsb2JhbC5mZXRjaC5tb2NrUmVzdG9yZSgpO1xuICB9XG59OyJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsInVzZVJvdXRlciIsIm1vY2tSb3V0ZXIiLCJ1c2VQYXRobmFtZSIsInVzZVNlYXJjaFBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsIlRlc3RQcm92aWRlcnMiLCJjcmVhdGVUZXN0UXVlcnlDbGllbnQiLCJtb2NrQXBpRXJyb3IiLCJtb2NrQXBpUmVzcG9uc2VzIiwicmVuZGVyQW5kV2FpdEZvckxvYWRpbmciLCJyZW5kZXJXaXRoQXV0aGVudGljYXRlZFVzZXIiLCJyZW5kZXJXaXRoQ3VyYXRvclVzZXIiLCJyZW5kZXJXaXRoUHJvdmlkZXJzIiwicmVzZXRUZXN0U3RhdGUiLCJ0ZXN0VXRpbHMiLCJ1c2VySW50ZXJhY3Rpb25zIiwid2FpdEZvckVsZW1lbnQiLCJwdXNoIiwiZm4iLCJyZXBsYWNlIiwiYmFjayIsImZvcndhcmQiLCJyZWZyZXNoIiwicHJlZmV0Y2giLCJwYXRobmFtZSIsInJvdXRlIiwicXVlcnkiLCJhc1BhdGgiLCJiYXNlUGF0aCIsImlzTG9jYWxlRG9tYWluIiwiaXNSZWFkeSIsImlzUHJldmlldyIsIlF1ZXJ5Q2xpZW50IiwiZGVmYXVsdE9wdGlvbnMiLCJxdWVyaWVzIiwicmV0cnkiLCJnY1RpbWUiLCJzdGFsZVRpbWUiLCJtdXRhdGlvbnMiLCJsb2dnZXIiLCJsb2ciLCJ3YXJuIiwiZXJyb3IiLCJjaGlsZHJlbiIsInVzZXIiLCJxdWVyeUNsaWVudCIsIlF1ZXJ5Q2xpZW50UHJvdmlkZXIiLCJjbGllbnQiLCJVc2VyUHJvdmlkZXIiLCJ1aSIsIm9wdGlvbnMiLCJyb3V0ZXJNb2NrIiwicmVuZGVyT3B0aW9ucyIsIk9iamVjdCIsImFzc2lnbiIsIldyYXBwZXIiLCJyZW5kZXJSZXN1bHQiLCJyZW5kZXIiLCJ3cmFwcGVyIiwidXNlckV2ZW50Iiwic2V0dXAiLCJyb3V0ZXIiLCJ1c2VyT3ZlcnJpZGVzIiwic2Vzc2lvbk92ZXJyaWRlcyIsInNlc3Npb24iLCJjcmVhdGVBdXRoZW50aWNhdGVkVGVzdFVzZXIiLCJyZXN1bHQiLCJ0ZXN0VXNlciIsInRlc3RTZXNzaW9uIiwiaXNDdXJhdG9yIiwid2FpdEZvciIsImV4cGVjdCIsInNjcmVlbiIsInF1ZXJ5QnlUZXh0Iiwibm90IiwidG9CZUluVGhlRG9jdW1lbnQiLCJxdWVyeUJ5Um9sZSIsInRpbWVvdXQiLCJyZXNwb25zZXMiLCJnbG9iYWwiLCJmZXRjaCIsInVybCIsImVuZHBvaW50IiwidG9TdHJpbmciLCJwYXR0ZXJuIiwicmVzcG9uc2UiLCJlbnRyaWVzIiwiaW5jbHVkZXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsIm9rIiwic3RhdHVzIiwianNvbiIsInRleHQiLCJKU09OIiwic3RyaW5naWZ5IiwicmVxdWlyZUFjdHVhbCIsImludGVydmFsIiwiZmlsbEZvcm0iLCJmb3JtRGF0YSIsImZpZWxkTmFtZSIsInZhbHVlIiwiZmllbGQiLCJnZXRCeUxhYmVsVGV4dCIsIlJlZ0V4cCIsImdldEJ5UGxhY2Vob2xkZXJUZXh0IiwiZ2V0QnlSb2xlIiwibmFtZSIsImNsZWFyIiwidHlwZSIsInN1Ym1pdEZvcm0iLCJidXR0b25UZXh0Iiwic3VibWl0QnV0dG9uIiwiY2xpY2siLCJuYXZpZ2F0ZSIsInBhdGgiLCJzZWxlY3RPcHRpb24iLCJzZWxlY3RMYWJlbCIsIm9wdGlvblRleHQiLCJzZWxlY3QiLCJzZWxlY3RPcHRpb25zIiwidXBsb2FkRmlsZSIsImlucHV0TGFiZWwiLCJmaWxlIiwiZmlsZUlucHV0IiwidXBsb2FkIiwiZXhwZWN0VGV4dFRvQmVJbkRvY3VtZW50IiwiZ2V0QnlUZXh0IiwiZXhwZWN0VGV4dE5vdFRvQmVJbkRvY3VtZW50IiwiZXhwZWN0RmllbGRWYWx1ZSIsImV4cGVjdGVkVmFsdWUiLCJ0b0hhdmVWYWx1ZSIsImV4cGVjdEFwaUNhbGwiLCJleHBlY3RlZERhdGEiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsInN0cmluZ0NvbnRhaW5pbmciLCJvYmplY3RDb250YWluaW5nIiwiYm9keSIsImFueSIsImNsZWFyQWxsTW9ja3MiLCJtb2NrQ2xlYXIiLCJtb2NrUmVzdG9yZSJdLCJtYXBwaW5ncyI6IkFBQUEsZ0NBQWdDOztBQTJCaEMsc0JBQXNCO0FBQ3RCQSxLQUFLQyxJQUFJLENBQUMsbUJBQW1CLElBQU8sQ0FBQTtRQUNsQ0MsV0FBVyxJQUFNQztRQUNqQkMsYUFBYSxJQUFNO1FBQ25CQyxpQkFBaUIsSUFBTSxJQUFJQztJQUM3QixDQUFBOzs7Ozs7Ozs7OztRQWtDYUM7ZUFBQUE7O1FBNUJBQztlQUFBQTs7UUFtTEFDO2VBQUFBOztRQTlCQUM7ZUFBQUE7O1FBaEJBQztlQUFBQTs7UUFwQ0FDO2VBQUFBOztRQXVCQUM7ZUFBQUE7O1FBbkVBQztlQUFBQTs7UUEyUUFDO2VBQUFBOztRQS9DQUM7ZUFBQUE7O1FBL0RBQztlQUFBQTs7UUFUQUM7ZUFBQUE7Ozs7OERBN09LO3dCQUNzQjtrRUFDbEI7NEJBQzJCOzhCQUNwQjs2QkFDK0I7Ozs7OztBQUU1RCxzQkFBc0I7QUFDdEIsTUFBTWYsYUFBYTtJQUNqQmdCLE1BQU1uQixLQUFLb0IsRUFBRTtJQUNiQyxT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