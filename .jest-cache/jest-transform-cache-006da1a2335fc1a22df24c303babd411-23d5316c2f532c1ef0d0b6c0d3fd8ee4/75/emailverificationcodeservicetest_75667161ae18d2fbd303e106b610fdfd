979db4f3698856457866bae0e2fdc3d1
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _emailverificationcodeservice = require("../email-verification-code-service");
// Mock the database BEFORE importing the service
const mockDb = {
    insert: _globals.jest.fn(),
    select: _globals.jest.fn(),
    update: _globals.jest.fn(),
    delete: _globals.jest.fn(),
    transaction: _globals.jest.fn()
};
_globals.jest.mock('@/lib/db', ()=>({
        db: mockDb
    }));
(0, _globals.describe)('EmailVerificationCodeService', ()=>{
    let service;
    const mockUserId = 1;
    const mockEmail = 'test@example.com';
    const mockCode = '123456';
    (0, _globals.beforeEach)(()=>{
        service = new _emailverificationcodeservice.EmailVerificationCodeService();
        _globals.jest.clearAllMocks();
    });
    (0, _globals.afterEach)(()=>{
        _globals.jest.restoreAllMocks();
    });
    (0, _globals.describe)('generateCode', ()=>{
        (0, _globals.it)('should generate a 6-digit code', async ()=>{
            // Mock deleteUserCodes to resolve
            const deleteUserCodesSpy = _globals.jest.spyOn(service, 'deleteUserCodes').mockResolvedValue();
            // Mock insert chain
            const mockValues = _globals.jest.fn().mockResolvedValue(undefined);
            mockDb.insert.mockReturnValue({
                values: mockValues
            });
            const code = await service.generateCode(mockUserId);
            (0, _globals.expect)(code).toMatch(/^\d{6}$/);
            (0, _globals.expect)(deleteUserCodesSpy).toHaveBeenCalledWith(mockUserId);
            (0, _globals.expect)(mockDb.insert).toHaveBeenCalled();
            (0, _globals.expect)(mockValues).toHaveBeenCalledWith(_globals.expect.objectContaining({
                userId: mockUserId,
                code: _globals.expect.stringMatching(/^\d{6}$/),
                expiresAt: _globals.expect.any(Date),
                attemptsUsed: 0
            }));
        });
        (0, _globals.it)('should delete existing codes before generating new one', async ()=>{
            const deleteUserCodesSpy = _globals.jest.spyOn(service, 'deleteUserCodes').mockResolvedValue();
            const mockValues = _globals.jest.fn().mockResolvedValue(undefined);
            mockDb.insert.mockReturnValue({
                values: mockValues
            });
            await service.generateCode(mockUserId);
            (0, _globals.expect)(deleteUserCodesSpy).toHaveBeenCalledWith(mockUserId);
        });
        (0, _globals.it)('should store code with correct expiration time', async ()=>{
            _globals.jest.spyOn(service, 'deleteUserCodes').mockResolvedValue();
            const mockValues = _globals.jest.fn().mockResolvedValue(undefined);
            mockDb.insert.mockReturnValue({
                values: mockValues
            });
            const beforeTime = Date.now();
            await service.generateCode(mockUserId);
            const afterTime = Date.now();
            (0, _globals.expect)(mockValues).toHaveBeenCalledWith(_globals.expect.objectContaining({
                userId: mockUserId,
                code: _globals.expect.stringMatching(/^\d{6}$/),
                expiresAt: _globals.expect.any(Date),
                attemptsUsed: 0
            }));
            // Check that expiration is approximately 10 minutes from now
            const callArgs = mockValues.mock.calls[0][0];
            const expirationTime = callArgs.expiresAt.getTime();
            const expectedMin = beforeTime + 9.5 * 60 * 1000; // 9.5 minutes
            const expectedMax = afterTime + 10.5 * 60 * 1000; // 10.5 minutes
            (0, _globals.expect)(expirationTime).toBeGreaterThan(expectedMin);
            (0, _globals.expect)(expirationTime).toBeLessThan(expectedMax);
        });
    });
    (0, _globals.describe)('validateCode', ()=>{
        const mockUser = {
            id: mockUserId,
            isEmailVerified: false
        };
        const mockVerificationCode = {
            id: 1,
            userId: mockUserId,
            code: mockCode,
            expiresAt: new Date(Date.now() + 5 * 60 * 1000),
            createdAt: new Date(),
            attemptsUsed: 0
        };
        (0, _globals.it)('should validate correct code successfully', async ()=>{
            // Mock user lookup
            const mockUserLimit = _globals.jest.fn().mockResolvedValue([
                mockUser
            ]);
            const mockUserWhere = _globals.jest.fn().mockReturnValue({
                limit: mockUserLimit
            });
            const mockUserFrom = _globals.jest.fn().mockReturnValue({
                where: mockUserWhere
            });
            mockDb.select.mockReturnValueOnce({
                from: mockUserFrom
            });
            // Mock verification code lookup
            const mockCodeLimit = _globals.jest.fn().mockResolvedValue([
                mockVerificationCode
            ]);
            const mockCodeWhere = _globals.jest.fn().mockReturnValue({
                limit: mockCodeLimit
            });
            const mockCodeFrom = _globals.jest.fn().mockReturnValue({
                where: mockCodeWhere
            });
            mockDb.select.mockReturnValueOnce({
                from: mockCodeFrom
            });
            // Mock transaction
            const mockTx = {
                update: _globals.jest.fn().mockReturnValue({
                    set: _globals.jest.fn().mockReturnValue({
                        where: _globals.jest.fn().mockResolvedValue(undefined)
                    })
                }),
                delete: _globals.jest.fn().mockReturnValue({
                    where: _globals.jest.fn().mockResolvedValue(undefined)
                })
            };
            mockDb.transaction.mockImplementation(async (callback)=>callback(mockTx));
            const result = await service.validateCode(mockEmail, mockCode);
            (0, _globals.expect)(result).toBe(true);
            (0, _globals.expect)(mockDb.transaction).toHaveBeenCalled();
        });
        (0, _globals.it)('should throw USER_NOT_FOUND when user does not exist', async ()=>{
            // Mock user lookup to return empty array
            const mockUserLimit = _globals.jest.fn().mockResolvedValue([]);
            const mockUserWhere = _globals.jest.fn().mockReturnValue({
                limit: mockUserLimit
            });
            const mockUserFrom = _globals.jest.fn().mockReturnValue({
                where: mockUserWhere
            });
            mockDb.select.mockReturnValueOnce({
                from: mockUserFrom
            });
            await (0, _globals.expect)(service.validateCode(mockEmail, mockCode)).rejects.toThrow(new _emailverificationcodeservice.VerificationCodeError('User not found', _emailverificationcodeservice.VerificationError.USER_NOT_FOUND));
        });
        (0, _globals.it)('should throw ALREADY_VERIFIED when user is already verified', async ()=>{
            // Mock user lookup to return verified user
            const mockUserLimit = _globals.jest.fn().mockResolvedValue([
                {
                    ...mockUser,
                    isEmailVerified: true
                }
            ]);
            const mockUserWhere = _globals.jest.fn().mockReturnValue({
                limit: mockUserLimit
            });
            const mockUserFrom = _globals.jest.fn().mockReturnValue({
                where: mockUserWhere
            });
            mockDb.select.mockReturnValueOnce({
                from: mockUserFrom
            });
            await (0, _globals.expect)(service.validateCode(mockEmail, mockCode)).rejects.toThrow(new _emailverificationcodeservice.VerificationCodeError('Email already verified', _emailverificationcodeservice.VerificationError.ALREADY_VERIFIED));
        });
        (0, _globals.it)('should throw CODE_INVALID when code does not exist', async ()=>{
            // Mock user lookup
            const mockUserLimit = _globals.jest.fn().mockResolvedValue([
                mockUser
            ]);
            const mockUserWhere = _globals.jest.fn().mockReturnValue({
                limit: mockUserLimit
            });
            const mockUserFrom = _globals.jest.fn().mockReturnValue({
                where: mockUserWhere
            });
            mockDb.select.mockReturnValueOnce({
                from: mockUserFrom
            });
            // Mock verification code lookup to return empty array
            const mockCodeLimit = _globals.jest.fn().mockResolvedValue([]);
            const mockCodeWhere = _globals.jest.fn().mockReturnValue({
                limit: mockCodeLimit
            });
            const mockCodeFrom = _globals.jest.fn().mockReturnValue({
                where: mockCodeWhere
            });
            mockDb.select.mockReturnValueOnce({
                from: mockCodeFrom
            });
            await (0, _globals.expect)(service.validateCode(mockEmail, mockCode)).rejects.toThrow(new _emailverificationcodeservice.VerificationCodeError('Invalid verification code', _emailverificationcodeservice.VerificationError.CODE_INVALID));
        });
        (0, _globals.it)('should throw CODE_EXPIRED when code has expired', async ()=>{
            const expiredCode = {
                ...mockVerificationCode,
                expiresAt: new Date(Date.now() - 5 * 60 * 1000)
            };
            // Mock user lookup
            const mockUserLimit = _globals.jest.fn().mockResolvedValue([
                mockUser
            ]);
            const mockUserWhere = _globals.jest.fn().mockReturnValue({
                limit: mockUserLimit
            });
            const mockUserFrom = _globals.jest.fn().mockReturnValue({
                where: mockUserWhere
            });
            mockDb.select.mockReturnValueOnce({
                from: mockUserFrom
            });
            // Mock verification code lookup
            const mockCodeLimit = _globals.jest.fn().mockResolvedValue([
                expiredCode
            ]);
            const mockCodeWhere = _globals.jest.fn().mockReturnValue({
                limit: mockCodeLimit
            });
            const mockCodeFrom = _globals.jest.fn().mockReturnValue({
                where: mockCodeWhere
            });
            mockDb.select.mockReturnValueOnce({
                from: mockCodeFrom
            });
            // Mock delete for expired code cleanup
            const mockDeleteWhere = _globals.jest.fn().mockResolvedValue(undefined);
            mockDb.delete.mockReturnValue({
                where: mockDeleteWhere
            });
            await (0, _globals.expect)(service.validateCode(mockEmail, mockCode)).rejects.toThrow(new _emailverificationcodeservice.VerificationCodeError('Verification code has expired', _emailverificationcodeservice.VerificationError.CODE_EXPIRED));
            (0, _globals.expect)(mockDb.delete).toHaveBeenCalled();
        });
        (0, _globals.it)('should throw TOO_MANY_ATTEMPTS when max attempts exceeded', async ()=>{
            const maxAttemptsCode = {
                ...mockVerificationCode,
                attemptsUsed: 5
            };
            // Mock user lookup
            const mockUserLimit = _globals.jest.fn().mockResolvedValue([
                mockUser
            ]);
            const mockUserWhere = _globals.jest.fn().mockReturnValue({
                limit: mockUserLimit
            });
            const mockUserFrom = _globals.jest.fn().mockReturnValue({
                where: mockUserWhere
            });
            mockDb.select.mockReturnValueOnce({
                from: mockUserFrom
            });
            // Mock verification code lookup
            const mockCodeLimit = _globals.jest.fn().mockResolvedValue([
                maxAttemptsCode
            ]);
            const mockCodeWhere = _globals.jest.fn().mockReturnValue({
                limit: mockCodeLimit
            });
            const mockCodeFrom = _globals.jest.fn().mockReturnValue({
                where: mockCodeWhere
            });
            mockDb.select.mockReturnValueOnce({
                from: mockCodeFrom
            });
            // Mock delete for code invalidation
            const mockDeleteWhere = _globals.jest.fn().mockResolvedValue(undefined);
            mockDb.delete.mockReturnValue({
                where: mockDeleteWhere
            });
            await (0, _globals.expect)(service.validateCode(mockEmail, mockCode)).rejects.toThrow(new _emailverificationcodeservice.VerificationCodeError('Too many verification attempts', _emailverificationcodeservice.VerificationError.TOO_MANY_ATTEMPTS));
            (0, _globals.expect)(mockDb.delete).toHaveBeenCalled();
        });
    });
    (0, _globals.describe)('incrementAttempts', ()=>{
        const mockUser = {
            id: mockUserId
        };
        const mockVerificationCode = {
            id: 1,
            attemptsUsed: 2
        };
        (0, _globals.it)('should increment attempts for valid code', async ()=>{
            // Mock user lookup
            const mockUserLimit = _globals.jest.fn().mockResolvedValue([
                mockUser
            ]);
            const mockUserWhere = _globals.jest.fn().mockReturnValue({
                limit: mockUserLimit
            });
            const mockUserFrom = _globals.jest.fn().mockReturnValue({
                where: mockUserWhere
            });
            mockDb.select.mockReturnValueOnce({
                from: mockUserFrom
            });
            // Mock verification code lookup
            const mockCodeLimit = _globals.jest.fn().mockResolvedValue([
                mockVerificationCode
            ]);
            const mockCodeWhere = _globals.jest.fn().mockReturnValue({
                limit: mockCodeLimit
            });
            const mockCodeFrom = _globals.jest.fn().mockReturnValue({
                where: mockCodeWhere
            });
            mockDb.select.mockReturnValueOnce({
                from: mockCodeFrom
            });
            // Mock update
            const mockUpdateWhere = _globals.jest.fn().mockResolvedValue(undefined);
            const mockUpdateSet = _globals.jest.fn().mockReturnValue({
                where: mockUpdateWhere
            });
            mockDb.update.mockReturnValue({
                set: mockUpdateSet
            });
            await service.incrementAttempts(mockEmail, mockCode);
            (0, _globals.expect)(mockDb.update).toHaveBeenCalled();
            (0, _globals.expect)(mockUpdateSet).toHaveBeenCalledWith({
                attemptsUsed: 3
            });
        });
        (0, _globals.it)('should handle user not found gracefully', async ()=>{
            // Mock user lookup to return empty array
            const mockUserLimit = _globals.jest.fn().mockResolvedValue([]);
            const mockUserWhere = _globals.jest.fn().mockReturnValue({
                limit: mockUserLimit
            });
            const mockUserFrom = _globals.jest.fn().mockReturnValue({
                where: mockUserWhere
            });
            mockDb.select.mockReturnValueOnce({
                from: mockUserFrom
            });
            await (0, _globals.expect)(service.incrementAttempts(mockEmail, mockCode)).resolves.toBeUndefined();
            (0, _globals.expect)(mockDb.update).not.toHaveBeenCalled();
        });
        (0, _globals.it)('should handle code not found gracefully', async ()=>{
            // Mock user lookup
            const mockUserLimit = _globals.jest.fn().mockResolvedValue([
                mockUser
            ]);
            const mockUserWhere = _globals.jest.fn().mockReturnValue({
                limit: mockUserLimit
            });
            const mockUserFrom = _globals.jest.fn().mockReturnValue({
                where: mockUserWhere
            });
            mockDb.select.mockReturnValueOnce({
                from: mockUserFrom
            });
            // Mock verification code lookup to return empty array
            const mockCodeLimit = _globals.jest.fn().mockResolvedValue([]);
            const mockCodeWhere = _globals.jest.fn().mockReturnValue({
                limit: mockCodeLimit
            });
            const mockCodeFrom = _globals.jest.fn().mockReturnValue({
                where: mockCodeWhere
            });
            mockDb.select.mockReturnValueOnce({
                from: mockCodeFrom
            });
            await (0, _globals.expect)(service.incrementAttempts(mockEmail, mockCode)).resolves.toBeUndefined();
            (0, _globals.expect)(mockDb.update).not.toHaveBeenCalled();
        });
    });
    (0, _globals.describe)('cleanupExpiredCodes', ()=>{
        (0, _globals.it)('should delete expired codes and return count', async ()=>{
            const mockDeleteResult = {
                rowCount: 5
            };
            const mockDeleteWhere = _globals.jest.fn().mockResolvedValue(mockDeleteResult);
            mockDb.delete.mockReturnValue({
                where: mockDeleteWhere
            });
            const result = await service.cleanupExpiredCodes();
            (0, _globals.expect)(result).toBe(5);
            (0, _globals.expect)(mockDb.delete).toHaveBeenCalled();
        });
        (0, _globals.it)('should handle missing rowCount gracefully', async ()=>{
            const mockDeleteResult = {}; // No rowCount property
            const mockDeleteWhere = _globals.jest.fn().mockResolvedValue(mockDeleteResult);
            mockDb.delete.mockReturnValue({
                where: mockDeleteWhere
            });
            const result = await service.cleanupExpiredCodes();
            (0, _globals.expect)(result).toBe(0);
        });
    });
    (0, _globals.describe)('deleteUserCodes', ()=>{
        (0, _globals.it)('should delete all codes for a user', async ()=>{
            const mockDeleteWhere = _globals.jest.fn().mockResolvedValue(undefined);
            mockDb.delete.mockReturnValue({
                where: mockDeleteWhere
            });
            await service.deleteUserCodes(mockUserId);
            (0, _globals.expect)(mockDb.delete).toHaveBeenCalled();
        });
    });
    (0, _globals.describe)('getUserActiveCode', ()=>{
        (0, _globals.it)('should return active code for user', async ()=>{
            const mockActiveCode = {
                id: 1,
                userId: mockUserId,
                code: mockCode,
                expiresAt: new Date(Date.now() + 5 * 60 * 1000),
                createdAt: new Date(),
                attemptsUsed: 0
            };
            const mockLimit = _globals.jest.fn().mockResolvedValue([
                mockActiveCode
            ]);
            const mockWhere = _globals.jest.fn().mockReturnValue({
                limit: mockLimit
            });
            const mockFrom = _globals.jest.fn().mockReturnValue({
                where: mockWhere
            });
            mockDb.select.mockReturnValue({
                from: mockFrom
            });
            const result = await service.getUserActiveCode(mockUserId);
            (0, _globals.expect)(result).toEqual(mockActiveCode);
        });
        (0, _globals.it)('should return null when no active code exists', async ()=>{
            const mockLimit = _globals.jest.fn().mockResolvedValue([]);
            const mockWhere = _globals.jest.fn().mockReturnValue({
                limit: mockLimit
            });
            const mockFrom = _globals.jest.fn().mockReturnValue({
                where: mockWhere
            });
            mockDb.select.mockReturnValue({
                from: mockFrom
            });
            const result = await service.getUserActiveCode(mockUserId);
            (0, _globals.expect)(result).toBeNull();
        });
    });
    (0, _globals.describe)('hasActiveCode', ()=>{
        (0, _globals.it)('should return true when user has active code', async ()=>{
            _globals.jest.spyOn(service, 'getUserActiveCode').mockResolvedValue({
                id: 1,
                userId: mockUserId,
                code: mockCode,
                expiresAt: new Date(),
                createdAt: new Date(),
                attemptsUsed: 0
            });
            const result = await service.hasActiveCode(mockUserId);
            (0, _globals.expect)(result).toBe(true);
        });
        (0, _globals.it)('should return false when user has no active code', async ()=>{
            _globals.jest.spyOn(service, 'getUserActiveCode').mockResolvedValue(null);
            const result = await service.hasActiveCode(mockUserId);
            (0, _globals.expect)(result).toBe(false);
        });
    });
    (0, _globals.describe)('getCodeStats', ()=>{
        (0, _globals.it)('should return code statistics', async ()=>{
            // Mock the three select queries for stats
            const mockFrom1 = _globals.jest.fn().mockReturnValue({
                where: _globals.jest.fn().mockResolvedValue([
                    1,
                    2,
                    3
                ])
            });
            const mockFrom2 = _globals.jest.fn().mockReturnValue({
                where: _globals.jest.fn().mockResolvedValue([
                    1,
                    2
                ])
            });
            const mockFrom3 = _globals.jest.fn().mockReturnValue({
                where: _globals.jest.fn().mockResolvedValue([
                    1
                ])
            });
            mockDb.select.mockReturnValueOnce({
                from: mockFrom1
            }).mockReturnValueOnce({
                from: mockFrom2
            }).mockReturnValueOnce({
                from: mockFrom3
            });
            const result = await service.getCodeStats();
            (0, _globals.expect)(result).toEqual({
                totalActive: 3,
                expiredCount: 2,
                highAttemptCount: 1
            });
        });
    });
    (0, _globals.describe)('code generation security', ()=>{
        (0, _globals.it)('should generate unique codes', async ()=>{
            _globals.jest.spyOn(service, 'deleteUserCodes').mockResolvedValue();
            const mockValues = _globals.jest.fn().mockResolvedValue(undefined);
            mockDb.insert.mockReturnValue({
                values: mockValues
            });
            const codes = new Set();
            for(let i = 0; i < 100; i++){
                const code = await service.generateCode(mockUserId);
                codes.add(code);
            }
            // Should have generated 100 unique codes (very high probability)
            (0, _globals.expect)(codes.size).toBeGreaterThan(95);
        });
        (0, _globals.it)('should always generate 6-digit codes', async ()=>{
            _globals.jest.spyOn(service, 'deleteUserCodes').mockResolvedValue();
            const mockValues = _globals.jest.fn().mockResolvedValue(undefined);
            mockDb.insert.mockReturnValue({
                values: mockValues
            });
            for(let i = 0; i < 50; i++){
                const code = await service.generateCode(mockUserId);
                (0, _globals.expect)(code).toMatch(/^\d{6}$/);
                (0, _globals.expect)(code.length).toBe(6);
            }
        });
        (0, _globals.it)('should pad codes with leading zeros', async ()=>{
            _globals.jest.spyOn(service, 'deleteUserCodes').mockResolvedValue();
            const mockValues = _globals.jest.fn().mockResolvedValue(undefined);
            mockDb.insert.mockReturnValue({
                values: mockValues
            });
            // Mock crypto.randomBytes to return a small number
            const originalRandomBytes = require('crypto').randomBytes;
            const mockRandomBytes = _globals.jest.fn().mockReturnValue(Buffer.from([
                0,
                0,
                0,
                1
            ])); // Very small number
            require('crypto').randomBytes = mockRandomBytes;
            const code = await service.generateCode(mockUserId);
            (0, _globals.expect)(code).toMatch(/^\d{6}$/);
            (0, _globals.expect)(code.length).toBe(6);
            // Restore original function
            require('crypto').randomBytes = originalRandomBytes;
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdGVmYW5iZWtrZXIvcHJvamVjdHMvZmFuY3ktcGxhbnRpZXMvc3JjL2xpYi9zZXJ2aWNlcy9fX3Rlc3RzX18vZW1haWwtdmVyaWZpY2F0aW9uLWNvZGUtc2VydmljZS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlc2NyaWJlLCBpdCwgZXhwZWN0LCBiZWZvcmVFYWNoLCBhZnRlckVhY2gsIGplc3QgfSBmcm9tICdAamVzdC9nbG9iYWxzJztcblxuLy8gTW9jayB0aGUgZGF0YWJhc2UgQkVGT1JFIGltcG9ydGluZyB0aGUgc2VydmljZVxuY29uc3QgbW9ja0RiID0ge1xuICBpbnNlcnQ6IGplc3QuZm4oKSxcbiAgc2VsZWN0OiBqZXN0LmZuKCksXG4gIHVwZGF0ZTogamVzdC5mbigpLFxuICBkZWxldGU6IGplc3QuZm4oKSxcbiAgdHJhbnNhY3Rpb246IGplc3QuZm4oKSxcbn07XG5cbmplc3QubW9jaygnQC9saWIvZGInLCAoKSA9PiAoe1xuICBkYjogbW9ja0RiLFxufSkpO1xuXG4vLyBJbXBvcnQgYWZ0ZXIgbW9ja2luZ1xuaW1wb3J0IHsgRW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZSwgVmVyaWZpY2F0aW9uRXJyb3IsIFZlcmlmaWNhdGlvbkNvZGVFcnJvciB9IGZyb20gJy4uL2VtYWlsLXZlcmlmaWNhdGlvbi1jb2RlLXNlcnZpY2UnO1xuXG5kZXNjcmliZSgnRW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZScsICgpID0+IHtcbiAgbGV0IHNlcnZpY2U6IEVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2U7XG4gIGNvbnN0IG1vY2tVc2VySWQgPSAxO1xuICBjb25zdCBtb2NrRW1haWwgPSAndGVzdEBleGFtcGxlLmNvbSc7XG4gIGNvbnN0IG1vY2tDb2RlID0gJzEyMzQ1Nic7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgc2VydmljZSA9IG5ldyBFbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlKCk7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgamVzdC5yZXN0b3JlQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dlbmVyYXRlQ29kZScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGdlbmVyYXRlIGEgNi1kaWdpdCBjb2RlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBkZWxldGVVc2VyQ29kZXMgdG8gcmVzb2x2ZVxuICAgICAgY29uc3QgZGVsZXRlVXNlckNvZGVzU3B5ID0gamVzdC5zcHlPbihzZXJ2aWNlLCAnZGVsZXRlVXNlckNvZGVzJykubW9ja1Jlc29sdmVkVmFsdWUoKTtcbiAgICAgIFxuICAgICAgLy8gTW9jayBpbnNlcnQgY2hhaW5cbiAgICAgIGNvbnN0IG1vY2tWYWx1ZXMgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcbiAgICAgIG1vY2tEYi5pbnNlcnQubW9ja1JldHVyblZhbHVlKHsgdmFsdWVzOiBtb2NrVmFsdWVzIH0pO1xuICAgICAgXG4gICAgICBjb25zdCBjb2RlID0gYXdhaXQgc2VydmljZS5nZW5lcmF0ZUNvZGUobW9ja1VzZXJJZCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChjb2RlKS50b01hdGNoKC9eXFxkezZ9JC8pO1xuICAgICAgZXhwZWN0KGRlbGV0ZVVzZXJDb2Rlc1NweSkudG9IYXZlQmVlbkNhbGxlZFdpdGgobW9ja1VzZXJJZCk7XG4gICAgICBleHBlY3QobW9ja0RiLmluc2VydCkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgZXhwZWN0KG1vY2tWYWx1ZXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgdXNlcklkOiBtb2NrVXNlcklkLFxuICAgICAgICAgIGNvZGU6IGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXlxcZHs2fSQvKSxcbiAgICAgICAgICBleHBpcmVzQXQ6IGV4cGVjdC5hbnkoRGF0ZSksXG4gICAgICAgICAgYXR0ZW1wdHNVc2VkOiAwLFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZGVsZXRlIGV4aXN0aW5nIGNvZGVzIGJlZm9yZSBnZW5lcmF0aW5nIG5ldyBvbmUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBkZWxldGVVc2VyQ29kZXNTcHkgPSBqZXN0LnNweU9uKHNlcnZpY2UsICdkZWxldGVVc2VyQ29kZXMnKS5tb2NrUmVzb2x2ZWRWYWx1ZSgpO1xuICAgICAgY29uc3QgbW9ja1ZhbHVlcyA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xuICAgICAgbW9ja0RiLmluc2VydC5tb2NrUmV0dXJuVmFsdWUoeyB2YWx1ZXM6IG1vY2tWYWx1ZXMgfSk7XG4gICAgICBcbiAgICAgIGF3YWl0IHNlcnZpY2UuZ2VuZXJhdGVDb2RlKG1vY2tVc2VySWQpO1xuICAgICAgXG4gICAgICBleHBlY3QoZGVsZXRlVXNlckNvZGVzU3B5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChtb2NrVXNlcklkKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgc3RvcmUgY29kZSB3aXRoIGNvcnJlY3QgZXhwaXJhdGlvbiB0aW1lJywgYXN5bmMgKCkgPT4ge1xuICAgICAgamVzdC5zcHlPbihzZXJ2aWNlLCAnZGVsZXRlVXNlckNvZGVzJykubW9ja1Jlc29sdmVkVmFsdWUoKTtcbiAgICAgIGNvbnN0IG1vY2tWYWx1ZXMgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcbiAgICAgIG1vY2tEYi5pbnNlcnQubW9ja1JldHVyblZhbHVlKHsgdmFsdWVzOiBtb2NrVmFsdWVzIH0pO1xuICAgICAgXG4gICAgICBjb25zdCBiZWZvcmVUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGF3YWl0IHNlcnZpY2UuZ2VuZXJhdGVDb2RlKG1vY2tVc2VySWQpO1xuICAgICAgY29uc3QgYWZ0ZXJUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tWYWx1ZXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgdXNlcklkOiBtb2NrVXNlcklkLFxuICAgICAgICAgIGNvZGU6IGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXlxcZHs2fSQvKSxcbiAgICAgICAgICBleHBpcmVzQXQ6IGV4cGVjdC5hbnkoRGF0ZSksXG4gICAgICAgICAgYXR0ZW1wdHNVc2VkOiAwLFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgdGhhdCBleHBpcmF0aW9uIGlzIGFwcHJveGltYXRlbHkgMTAgbWludXRlcyBmcm9tIG5vd1xuICAgICAgY29uc3QgY2FsbEFyZ3MgPSBtb2NrVmFsdWVzLm1vY2suY2FsbHNbMF1bMF07XG4gICAgICBjb25zdCBleHBpcmF0aW9uVGltZSA9IGNhbGxBcmdzLmV4cGlyZXNBdC5nZXRUaW1lKCk7XG4gICAgICBjb25zdCBleHBlY3RlZE1pbiA9IGJlZm9yZVRpbWUgKyA5LjUgKiA2MCAqIDEwMDA7IC8vIDkuNSBtaW51dGVzXG4gICAgICBjb25zdCBleHBlY3RlZE1heCA9IGFmdGVyVGltZSArIDEwLjUgKiA2MCAqIDEwMDA7IC8vIDEwLjUgbWludXRlc1xuICAgICAgXG4gICAgICBleHBlY3QoZXhwaXJhdGlvblRpbWUpLnRvQmVHcmVhdGVyVGhhbihleHBlY3RlZE1pbik7XG4gICAgICBleHBlY3QoZXhwaXJhdGlvblRpbWUpLnRvQmVMZXNzVGhhbihleHBlY3RlZE1heCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCd2YWxpZGF0ZUNvZGUnLCAoKSA9PiB7XG4gICAgY29uc3QgbW9ja1VzZXIgPSB7IGlkOiBtb2NrVXNlcklkLCBpc0VtYWlsVmVyaWZpZWQ6IGZhbHNlIH07XG4gICAgY29uc3QgbW9ja1ZlcmlmaWNhdGlvbkNvZGUgPSB7XG4gICAgICBpZDogMSxcbiAgICAgIHVzZXJJZDogbW9ja1VzZXJJZCxcbiAgICAgIGNvZGU6IG1vY2tDb2RlLFxuICAgICAgZXhwaXJlc0F0OiBuZXcgRGF0ZShEYXRlLm5vdygpICsgNSAqIDYwICogMTAwMCksIC8vIDUgbWludXRlcyBmcm9tIG5vd1xuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgYXR0ZW1wdHNVc2VkOiAwLFxuICAgIH07XG5cbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIGNvcnJlY3QgY29kZSBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIHVzZXIgbG9va3VwXG4gICAgICBjb25zdCBtb2NrVXNlckxpbWl0ID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKFttb2NrVXNlcl0pO1xuICAgICAgY29uc3QgbW9ja1VzZXJXaGVyZSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBsaW1pdDogbW9ja1VzZXJMaW1pdCB9KTtcbiAgICAgIGNvbnN0IG1vY2tVc2VyRnJvbSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyB3aGVyZTogbW9ja1VzZXJXaGVyZSB9KTtcbiAgICAgIG1vY2tEYi5zZWxlY3QubW9ja1JldHVyblZhbHVlT25jZSh7IGZyb206IG1vY2tVc2VyRnJvbSB9KTtcblxuICAgICAgLy8gTW9jayB2ZXJpZmljYXRpb24gY29kZSBsb29rdXBcbiAgICAgIGNvbnN0IG1vY2tDb2RlTGltaXQgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoW21vY2tWZXJpZmljYXRpb25Db2RlXSk7XG4gICAgICBjb25zdCBtb2NrQ29kZVdoZXJlID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGxpbWl0OiBtb2NrQ29kZUxpbWl0IH0pO1xuICAgICAgY29uc3QgbW9ja0NvZGVGcm9tID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHdoZXJlOiBtb2NrQ29kZVdoZXJlIH0pO1xuICAgICAgbW9ja0RiLnNlbGVjdC5tb2NrUmV0dXJuVmFsdWVPbmNlKHsgZnJvbTogbW9ja0NvZGVGcm9tIH0pO1xuXG4gICAgICAvLyBNb2NrIHRyYW5zYWN0aW9uXG4gICAgICBjb25zdCBtb2NrVHggPSB7XG4gICAgICAgIHVwZGF0ZTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgc2V0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgIHdoZXJlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSksXG4gICAgICAgIGRlbGV0ZTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgd2hlcmU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpLFxuICAgICAgICB9KSxcbiAgICAgIH07XG4gICAgICBtb2NrRGIudHJhbnNhY3Rpb24ubW9ja0ltcGxlbWVudGF0aW9uKGFzeW5jIChjYWxsYmFjaykgPT4gY2FsbGJhY2sobW9ja1R4KSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlcnZpY2UudmFsaWRhdGVDb2RlKG1vY2tFbWFpbCwgbW9ja0NvZGUpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KG1vY2tEYi50cmFuc2FjdGlvbikudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBVU0VSX05PVF9GT1VORCB3aGVuIHVzZXIgZG9lcyBub3QgZXhpc3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIHVzZXIgbG9va3VwIHRvIHJldHVybiBlbXB0eSBhcnJheVxuICAgICAgY29uc3QgbW9ja1VzZXJMaW1pdCA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShbXSk7XG4gICAgICBjb25zdCBtb2NrVXNlcldoZXJlID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGxpbWl0OiBtb2NrVXNlckxpbWl0IH0pO1xuICAgICAgY29uc3QgbW9ja1VzZXJGcm9tID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHdoZXJlOiBtb2NrVXNlcldoZXJlIH0pO1xuICAgICAgbW9ja0RiLnNlbGVjdC5tb2NrUmV0dXJuVmFsdWVPbmNlKHsgZnJvbTogbW9ja1VzZXJGcm9tIH0pO1xuXG4gICAgICBhd2FpdCBleHBlY3Qoc2VydmljZS52YWxpZGF0ZUNvZGUobW9ja0VtYWlsLCBtb2NrQ29kZSkpXG4gICAgICAgIC5yZWplY3RzXG4gICAgICAgIC50b1Rocm93KG5ldyBWZXJpZmljYXRpb25Db2RlRXJyb3IoJ1VzZXIgbm90IGZvdW5kJywgVmVyaWZpY2F0aW9uRXJyb3IuVVNFUl9OT1RfRk9VTkQpKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgQUxSRUFEWV9WRVJJRklFRCB3aGVuIHVzZXIgaXMgYWxyZWFkeSB2ZXJpZmllZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgdXNlciBsb29rdXAgdG8gcmV0dXJuIHZlcmlmaWVkIHVzZXJcbiAgICAgIGNvbnN0IG1vY2tVc2VyTGltaXQgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoW3sgLi4ubW9ja1VzZXIsIGlzRW1haWxWZXJpZmllZDogdHJ1ZSB9XSk7XG4gICAgICBjb25zdCBtb2NrVXNlcldoZXJlID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGxpbWl0OiBtb2NrVXNlckxpbWl0IH0pO1xuICAgICAgY29uc3QgbW9ja1VzZXJGcm9tID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHdoZXJlOiBtb2NrVXNlcldoZXJlIH0pO1xuICAgICAgbW9ja0RiLnNlbGVjdC5tb2NrUmV0dXJuVmFsdWVPbmNlKHsgZnJvbTogbW9ja1VzZXJGcm9tIH0pO1xuXG4gICAgICBhd2FpdCBleHBlY3Qoc2VydmljZS52YWxpZGF0ZUNvZGUobW9ja0VtYWlsLCBtb2NrQ29kZSkpXG4gICAgICAgIC5yZWplY3RzXG4gICAgICAgIC50b1Rocm93KG5ldyBWZXJpZmljYXRpb25Db2RlRXJyb3IoJ0VtYWlsIGFscmVhZHkgdmVyaWZpZWQnLCBWZXJpZmljYXRpb25FcnJvci5BTFJFQURZX1ZFUklGSUVEKSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHRocm93IENPREVfSU5WQUxJRCB3aGVuIGNvZGUgZG9lcyBub3QgZXhpc3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIHVzZXIgbG9va3VwXG4gICAgICBjb25zdCBtb2NrVXNlckxpbWl0ID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKFttb2NrVXNlcl0pO1xuICAgICAgY29uc3QgbW9ja1VzZXJXaGVyZSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBsaW1pdDogbW9ja1VzZXJMaW1pdCB9KTtcbiAgICAgIGNvbnN0IG1vY2tVc2VyRnJvbSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyB3aGVyZTogbW9ja1VzZXJXaGVyZSB9KTtcbiAgICAgIG1vY2tEYi5zZWxlY3QubW9ja1JldHVyblZhbHVlT25jZSh7IGZyb206IG1vY2tVc2VyRnJvbSB9KTtcblxuICAgICAgLy8gTW9jayB2ZXJpZmljYXRpb24gY29kZSBsb29rdXAgdG8gcmV0dXJuIGVtcHR5IGFycmF5XG4gICAgICBjb25zdCBtb2NrQ29kZUxpbWl0ID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKFtdKTtcbiAgICAgIGNvbnN0IG1vY2tDb2RlV2hlcmUgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgbGltaXQ6IG1vY2tDb2RlTGltaXQgfSk7XG4gICAgICBjb25zdCBtb2NrQ29kZUZyb20gPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgd2hlcmU6IG1vY2tDb2RlV2hlcmUgfSk7XG4gICAgICBtb2NrRGIuc2VsZWN0Lm1vY2tSZXR1cm5WYWx1ZU9uY2UoeyBmcm9tOiBtb2NrQ29kZUZyb20gfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChzZXJ2aWNlLnZhbGlkYXRlQ29kZShtb2NrRW1haWwsIG1vY2tDb2RlKSlcbiAgICAgICAgLnJlamVjdHNcbiAgICAgICAgLnRvVGhyb3cobmV3IFZlcmlmaWNhdGlvbkNvZGVFcnJvcignSW52YWxpZCB2ZXJpZmljYXRpb24gY29kZScsIFZlcmlmaWNhdGlvbkVycm9yLkNPREVfSU5WQUxJRCkpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBDT0RFX0VYUElSRUQgd2hlbiBjb2RlIGhhcyBleHBpcmVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZXhwaXJlZENvZGUgPSB7XG4gICAgICAgIC4uLm1vY2tWZXJpZmljYXRpb25Db2RlLFxuICAgICAgICBleHBpcmVzQXQ6IG5ldyBEYXRlKERhdGUubm93KCkgLSA1ICogNjAgKiAxMDAwKSwgLy8gNSBtaW51dGVzIGFnb1xuICAgICAgfTtcblxuICAgICAgLy8gTW9jayB1c2VyIGxvb2t1cFxuICAgICAgY29uc3QgbW9ja1VzZXJMaW1pdCA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShbbW9ja1VzZXJdKTtcbiAgICAgIGNvbnN0IG1vY2tVc2VyV2hlcmUgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgbGltaXQ6IG1vY2tVc2VyTGltaXQgfSk7XG4gICAgICBjb25zdCBtb2NrVXNlckZyb20gPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgd2hlcmU6IG1vY2tVc2VyV2hlcmUgfSk7XG4gICAgICBtb2NrRGIuc2VsZWN0Lm1vY2tSZXR1cm5WYWx1ZU9uY2UoeyBmcm9tOiBtb2NrVXNlckZyb20gfSk7XG5cbiAgICAgIC8vIE1vY2sgdmVyaWZpY2F0aW9uIGNvZGUgbG9va3VwXG4gICAgICBjb25zdCBtb2NrQ29kZUxpbWl0ID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKFtleHBpcmVkQ29kZV0pO1xuICAgICAgY29uc3QgbW9ja0NvZGVXaGVyZSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBsaW1pdDogbW9ja0NvZGVMaW1pdCB9KTtcbiAgICAgIGNvbnN0IG1vY2tDb2RlRnJvbSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyB3aGVyZTogbW9ja0NvZGVXaGVyZSB9KTtcbiAgICAgIG1vY2tEYi5zZWxlY3QubW9ja1JldHVyblZhbHVlT25jZSh7IGZyb206IG1vY2tDb2RlRnJvbSB9KTtcblxuICAgICAgLy8gTW9jayBkZWxldGUgZm9yIGV4cGlyZWQgY29kZSBjbGVhbnVwXG4gICAgICBjb25zdCBtb2NrRGVsZXRlV2hlcmUgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcbiAgICAgIG1vY2tEYi5kZWxldGUubW9ja1JldHVyblZhbHVlKHsgd2hlcmU6IG1vY2tEZWxldGVXaGVyZSB9KTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHNlcnZpY2UudmFsaWRhdGVDb2RlKG1vY2tFbWFpbCwgbW9ja0NvZGUpKVxuICAgICAgICAucmVqZWN0c1xuICAgICAgICAudG9UaHJvdyhuZXcgVmVyaWZpY2F0aW9uQ29kZUVycm9yKCdWZXJpZmljYXRpb24gY29kZSBoYXMgZXhwaXJlZCcsIFZlcmlmaWNhdGlvbkVycm9yLkNPREVfRVhQSVJFRCkpO1xuXG4gICAgICBleHBlY3QobW9ja0RiLmRlbGV0ZSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBUT09fTUFOWV9BVFRFTVBUUyB3aGVuIG1heCBhdHRlbXB0cyBleGNlZWRlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1heEF0dGVtcHRzQ29kZSA9IHtcbiAgICAgICAgLi4ubW9ja1ZlcmlmaWNhdGlvbkNvZGUsXG4gICAgICAgIGF0dGVtcHRzVXNlZDogNSwgLy8gTWF4IGF0dGVtcHRzXG4gICAgICB9O1xuXG4gICAgICAvLyBNb2NrIHVzZXIgbG9va3VwXG4gICAgICBjb25zdCBtb2NrVXNlckxpbWl0ID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKFttb2NrVXNlcl0pO1xuICAgICAgY29uc3QgbW9ja1VzZXJXaGVyZSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBsaW1pdDogbW9ja1VzZXJMaW1pdCB9KTtcbiAgICAgIGNvbnN0IG1vY2tVc2VyRnJvbSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyB3aGVyZTogbW9ja1VzZXJXaGVyZSB9KTtcbiAgICAgIG1vY2tEYi5zZWxlY3QubW9ja1JldHVyblZhbHVlT25jZSh7IGZyb206IG1vY2tVc2VyRnJvbSB9KTtcblxuICAgICAgLy8gTW9jayB2ZXJpZmljYXRpb24gY29kZSBsb29rdXBcbiAgICAgIGNvbnN0IG1vY2tDb2RlTGltaXQgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoW21heEF0dGVtcHRzQ29kZV0pO1xuICAgICAgY29uc3QgbW9ja0NvZGVXaGVyZSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBsaW1pdDogbW9ja0NvZGVMaW1pdCB9KTtcbiAgICAgIGNvbnN0IG1vY2tDb2RlRnJvbSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyB3aGVyZTogbW9ja0NvZGVXaGVyZSB9KTtcbiAgICAgIG1vY2tEYi5zZWxlY3QubW9ja1JldHVyblZhbHVlT25jZSh7IGZyb206IG1vY2tDb2RlRnJvbSB9KTtcblxuICAgICAgLy8gTW9jayBkZWxldGUgZm9yIGNvZGUgaW52YWxpZGF0aW9uXG4gICAgICBjb25zdCBtb2NrRGVsZXRlV2hlcmUgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcbiAgICAgIG1vY2tEYi5kZWxldGUubW9ja1JldHVyblZhbHVlKHsgd2hlcmU6IG1vY2tEZWxldGVXaGVyZSB9KTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHNlcnZpY2UudmFsaWRhdGVDb2RlKG1vY2tFbWFpbCwgbW9ja0NvZGUpKVxuICAgICAgICAucmVqZWN0c1xuICAgICAgICAudG9UaHJvdyhuZXcgVmVyaWZpY2F0aW9uQ29kZUVycm9yKCdUb28gbWFueSB2ZXJpZmljYXRpb24gYXR0ZW1wdHMnLCBWZXJpZmljYXRpb25FcnJvci5UT09fTUFOWV9BVFRFTVBUUykpO1xuXG4gICAgICBleHBlY3QobW9ja0RiLmRlbGV0ZSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnaW5jcmVtZW50QXR0ZW1wdHMnLCAoKSA9PiB7XG4gICAgY29uc3QgbW9ja1VzZXIgPSB7IGlkOiBtb2NrVXNlcklkIH07XG4gICAgY29uc3QgbW9ja1ZlcmlmaWNhdGlvbkNvZGUgPSB7IGlkOiAxLCBhdHRlbXB0c1VzZWQ6IDIgfTtcblxuICAgIGl0KCdzaG91bGQgaW5jcmVtZW50IGF0dGVtcHRzIGZvciB2YWxpZCBjb2RlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayB1c2VyIGxvb2t1cFxuICAgICAgY29uc3QgbW9ja1VzZXJMaW1pdCA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShbbW9ja1VzZXJdKTtcbiAgICAgIGNvbnN0IG1vY2tVc2VyV2hlcmUgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgbGltaXQ6IG1vY2tVc2VyTGltaXQgfSk7XG4gICAgICBjb25zdCBtb2NrVXNlckZyb20gPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgd2hlcmU6IG1vY2tVc2VyV2hlcmUgfSk7XG4gICAgICBtb2NrRGIuc2VsZWN0Lm1vY2tSZXR1cm5WYWx1ZU9uY2UoeyBmcm9tOiBtb2NrVXNlckZyb20gfSk7XG5cbiAgICAgIC8vIE1vY2sgdmVyaWZpY2F0aW9uIGNvZGUgbG9va3VwXG4gICAgICBjb25zdCBtb2NrQ29kZUxpbWl0ID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKFttb2NrVmVyaWZpY2F0aW9uQ29kZV0pO1xuICAgICAgY29uc3QgbW9ja0NvZGVXaGVyZSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBsaW1pdDogbW9ja0NvZGVMaW1pdCB9KTtcbiAgICAgIGNvbnN0IG1vY2tDb2RlRnJvbSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyB3aGVyZTogbW9ja0NvZGVXaGVyZSB9KTtcbiAgICAgIG1vY2tEYi5zZWxlY3QubW9ja1JldHVyblZhbHVlT25jZSh7IGZyb206IG1vY2tDb2RlRnJvbSB9KTtcblxuICAgICAgLy8gTW9jayB1cGRhdGVcbiAgICAgIGNvbnN0IG1vY2tVcGRhdGVXaGVyZSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xuICAgICAgY29uc3QgbW9ja1VwZGF0ZVNldCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyB3aGVyZTogbW9ja1VwZGF0ZVdoZXJlIH0pO1xuICAgICAgbW9ja0RiLnVwZGF0ZS5tb2NrUmV0dXJuVmFsdWUoeyBzZXQ6IG1vY2tVcGRhdGVTZXQgfSk7XG5cbiAgICAgIGF3YWl0IHNlcnZpY2UuaW5jcmVtZW50QXR0ZW1wdHMobW9ja0VtYWlsLCBtb2NrQ29kZSk7XG5cbiAgICAgIGV4cGVjdChtb2NrRGIudXBkYXRlKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICBleHBlY3QobW9ja1VwZGF0ZVNldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyBhdHRlbXB0c1VzZWQ6IDMgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSB1c2VyIG5vdCBmb3VuZCBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayB1c2VyIGxvb2t1cCB0byByZXR1cm4gZW1wdHkgYXJyYXlcbiAgICAgIGNvbnN0IG1vY2tVc2VyTGltaXQgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoW10pO1xuICAgICAgY29uc3QgbW9ja1VzZXJXaGVyZSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBsaW1pdDogbW9ja1VzZXJMaW1pdCB9KTtcbiAgICAgIGNvbnN0IG1vY2tVc2VyRnJvbSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyB3aGVyZTogbW9ja1VzZXJXaGVyZSB9KTtcbiAgICAgIG1vY2tEYi5zZWxlY3QubW9ja1JldHVyblZhbHVlT25jZSh7IGZyb206IG1vY2tVc2VyRnJvbSB9KTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHNlcnZpY2UuaW5jcmVtZW50QXR0ZW1wdHMobW9ja0VtYWlsLCBtb2NrQ29kZSkpLnJlc29sdmVzLnRvQmVVbmRlZmluZWQoKTtcbiAgICAgIGV4cGVjdChtb2NrRGIudXBkYXRlKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY29kZSBub3QgZm91bmQgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgdXNlciBsb29rdXBcbiAgICAgIGNvbnN0IG1vY2tVc2VyTGltaXQgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoW21vY2tVc2VyXSk7XG4gICAgICBjb25zdCBtb2NrVXNlcldoZXJlID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGxpbWl0OiBtb2NrVXNlckxpbWl0IH0pO1xuICAgICAgY29uc3QgbW9ja1VzZXJGcm9tID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHdoZXJlOiBtb2NrVXNlcldoZXJlIH0pO1xuICAgICAgbW9ja0RiLnNlbGVjdC5tb2NrUmV0dXJuVmFsdWVPbmNlKHsgZnJvbTogbW9ja1VzZXJGcm9tIH0pO1xuXG4gICAgICAvLyBNb2NrIHZlcmlmaWNhdGlvbiBjb2RlIGxvb2t1cCB0byByZXR1cm4gZW1wdHkgYXJyYXlcbiAgICAgIGNvbnN0IG1vY2tDb2RlTGltaXQgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoW10pO1xuICAgICAgY29uc3QgbW9ja0NvZGVXaGVyZSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBsaW1pdDogbW9ja0NvZGVMaW1pdCB9KTtcbiAgICAgIGNvbnN0IG1vY2tDb2RlRnJvbSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyB3aGVyZTogbW9ja0NvZGVXaGVyZSB9KTtcbiAgICAgIG1vY2tEYi5zZWxlY3QubW9ja1JldHVyblZhbHVlT25jZSh7IGZyb206IG1vY2tDb2RlRnJvbSB9KTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHNlcnZpY2UuaW5jcmVtZW50QXR0ZW1wdHMobW9ja0VtYWlsLCBtb2NrQ29kZSkpLnJlc29sdmVzLnRvQmVVbmRlZmluZWQoKTtcbiAgICAgIGV4cGVjdChtb2NrRGIudXBkYXRlKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnY2xlYW51cEV4cGlyZWRDb2RlcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGRlbGV0ZSBleHBpcmVkIGNvZGVzIGFuZCByZXR1cm4gY291bnQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrRGVsZXRlUmVzdWx0ID0geyByb3dDb3VudDogNSB9O1xuICAgICAgY29uc3QgbW9ja0RlbGV0ZVdoZXJlID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tEZWxldGVSZXN1bHQpO1xuICAgICAgbW9ja0RiLmRlbGV0ZS5tb2NrUmV0dXJuVmFsdWUoeyB3aGVyZTogbW9ja0RlbGV0ZVdoZXJlIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXJ2aWNlLmNsZWFudXBFeHBpcmVkQ29kZXMoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSg1KTtcbiAgICAgIGV4cGVjdChtb2NrRGIuZGVsZXRlKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBtaXNzaW5nIHJvd0NvdW50IGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrRGVsZXRlUmVzdWx0ID0ge307IC8vIE5vIHJvd0NvdW50IHByb3BlcnR5XG4gICAgICBjb25zdCBtb2NrRGVsZXRlV2hlcmUgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUobW9ja0RlbGV0ZVJlc3VsdCk7XG4gICAgICBtb2NrRGIuZGVsZXRlLm1vY2tSZXR1cm5WYWx1ZSh7IHdoZXJlOiBtb2NrRGVsZXRlV2hlcmUgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlcnZpY2UuY2xlYW51cEV4cGlyZWRDb2RlcygpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKDApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZGVsZXRlVXNlckNvZGVzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZGVsZXRlIGFsbCBjb2RlcyBmb3IgYSB1c2VyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0RlbGV0ZVdoZXJlID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XG4gICAgICBtb2NrRGIuZGVsZXRlLm1vY2tSZXR1cm5WYWx1ZSh7IHdoZXJlOiBtb2NrRGVsZXRlV2hlcmUgfSk7XG5cbiAgICAgIGF3YWl0IHNlcnZpY2UuZGVsZXRlVXNlckNvZGVzKG1vY2tVc2VySWQpO1xuXG4gICAgICBleHBlY3QobW9ja0RiLmRlbGV0ZSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0VXNlckFjdGl2ZUNvZGUnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gYWN0aXZlIGNvZGUgZm9yIHVzZXInLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQWN0aXZlQ29kZSA9IHtcbiAgICAgICAgaWQ6IDEsXG4gICAgICAgIHVzZXJJZDogbW9ja1VzZXJJZCxcbiAgICAgICAgY29kZTogbW9ja0NvZGUsXG4gICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIDUgKiA2MCAqIDEwMDApLFxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgIGF0dGVtcHRzVXNlZDogMCxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG1vY2tMaW1pdCA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShbbW9ja0FjdGl2ZUNvZGVdKTtcbiAgICAgIGNvbnN0IG1vY2tXaGVyZSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBsaW1pdDogbW9ja0xpbWl0IH0pO1xuICAgICAgY29uc3QgbW9ja0Zyb20gPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgd2hlcmU6IG1vY2tXaGVyZSB9KTtcbiAgICAgIG1vY2tEYi5zZWxlY3QubW9ja1JldHVyblZhbHVlKHsgZnJvbTogbW9ja0Zyb20gfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlcnZpY2UuZ2V0VXNlckFjdGl2ZUNvZGUobW9ja1VzZXJJZCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwobW9ja0FjdGl2ZUNvZGUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gbnVsbCB3aGVuIG5vIGFjdGl2ZSBjb2RlIGV4aXN0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tMaW1pdCA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShbXSk7XG4gICAgICBjb25zdCBtb2NrV2hlcmUgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgbGltaXQ6IG1vY2tMaW1pdCB9KTtcbiAgICAgIGNvbnN0IG1vY2tGcm9tID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHdoZXJlOiBtb2NrV2hlcmUgfSk7XG4gICAgICBtb2NrRGIuc2VsZWN0Lm1vY2tSZXR1cm5WYWx1ZSh7IGZyb206IG1vY2tGcm9tIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXJ2aWNlLmdldFVzZXJBY3RpdmVDb2RlKG1vY2tVc2VySWQpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnaGFzQWN0aXZlQ29kZScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiB0cnVlIHdoZW4gdXNlciBoYXMgYWN0aXZlIGNvZGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBqZXN0LnNweU9uKHNlcnZpY2UsICdnZXRVc2VyQWN0aXZlQ29kZScpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgaWQ6IDEsXG4gICAgICAgIHVzZXJJZDogbW9ja1VzZXJJZCxcbiAgICAgICAgY29kZTogbW9ja0NvZGUsXG4gICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoKSxcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICBhdHRlbXB0c1VzZWQ6IDAsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2VydmljZS5oYXNBY3RpdmVDb2RlKG1vY2tVc2VySWQpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gZmFsc2Ugd2hlbiB1c2VyIGhhcyBubyBhY3RpdmUgY29kZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGplc3Quc3B5T24oc2VydmljZSwgJ2dldFVzZXJBY3RpdmVDb2RlJykubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlcnZpY2UuaGFzQWN0aXZlQ29kZShtb2NrVXNlcklkKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShmYWxzZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdnZXRDb2RlU3RhdHMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gY29kZSBzdGF0aXN0aWNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayB0aGUgdGhyZWUgc2VsZWN0IHF1ZXJpZXMgZm9yIHN0YXRzXG4gICAgICBjb25zdCBtb2NrRnJvbTEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgd2hlcmU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShbMSwgMiwgM10pLCAvLyAzIGFjdGl2ZSBjb2Rlc1xuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrRnJvbTIgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgd2hlcmU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShbMSwgMl0pLCAvLyAyIGV4cGlyZWQgY29kZXNcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbW9ja0Zyb20zID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHdoZXJlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoWzFdKSwgLy8gMSBoaWdoIGF0dGVtcHQgY29kZVxuICAgICAgfSk7XG5cbiAgICAgIG1vY2tEYi5zZWxlY3RcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoeyBmcm9tOiBtb2NrRnJvbTEgfSlcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoeyBmcm9tOiBtb2NrRnJvbTIgfSlcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoeyBmcm9tOiBtb2NrRnJvbTMgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlcnZpY2UuZ2V0Q29kZVN0YXRzKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoe1xuICAgICAgICB0b3RhbEFjdGl2ZTogMyxcbiAgICAgICAgZXhwaXJlZENvdW50OiAyLFxuICAgICAgICBoaWdoQXR0ZW1wdENvdW50OiAxLFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdjb2RlIGdlbmVyYXRpb24gc2VjdXJpdHknLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBnZW5lcmF0ZSB1bmlxdWUgY29kZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBqZXN0LnNweU9uKHNlcnZpY2UsICdkZWxldGVVc2VyQ29kZXMnKS5tb2NrUmVzb2x2ZWRWYWx1ZSgpO1xuICAgICAgY29uc3QgbW9ja1ZhbHVlcyA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xuICAgICAgbW9ja0RiLmluc2VydC5tb2NrUmV0dXJuVmFsdWUoeyB2YWx1ZXM6IG1vY2tWYWx1ZXMgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGNvZGVzID0gbmV3IFNldCgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDA7IGkrKykge1xuICAgICAgICBjb25zdCBjb2RlID0gYXdhaXQgc2VydmljZS5nZW5lcmF0ZUNvZGUobW9ja1VzZXJJZCk7XG4gICAgICAgIGNvZGVzLmFkZChjb2RlKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIGhhdmUgZ2VuZXJhdGVkIDEwMCB1bmlxdWUgY29kZXMgKHZlcnkgaGlnaCBwcm9iYWJpbGl0eSlcbiAgICAgIGV4cGVjdChjb2Rlcy5zaXplKS50b0JlR3JlYXRlclRoYW4oOTUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBhbHdheXMgZ2VuZXJhdGUgNi1kaWdpdCBjb2RlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGplc3Quc3B5T24oc2VydmljZSwgJ2RlbGV0ZVVzZXJDb2RlcycpLm1vY2tSZXNvbHZlZFZhbHVlKCk7XG4gICAgICBjb25zdCBtb2NrVmFsdWVzID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XG4gICAgICBtb2NrRGIuaW5zZXJ0Lm1vY2tSZXR1cm5WYWx1ZSh7IHZhbHVlczogbW9ja1ZhbHVlcyB9KTtcbiAgICAgIFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1MDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCBzZXJ2aWNlLmdlbmVyYXRlQ29kZShtb2NrVXNlcklkKTtcbiAgICAgICAgZXhwZWN0KGNvZGUpLnRvTWF0Y2goL15cXGR7Nn0kLyk7XG4gICAgICAgIGV4cGVjdChjb2RlLmxlbmd0aCkudG9CZSg2KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcGFkIGNvZGVzIHdpdGggbGVhZGluZyB6ZXJvcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGplc3Quc3B5T24oc2VydmljZSwgJ2RlbGV0ZVVzZXJDb2RlcycpLm1vY2tSZXNvbHZlZFZhbHVlKCk7XG4gICAgICBjb25zdCBtb2NrVmFsdWVzID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XG4gICAgICBtb2NrRGIuaW5zZXJ0Lm1vY2tSZXR1cm5WYWx1ZSh7IHZhbHVlczogbW9ja1ZhbHVlcyB9KTtcbiAgICAgIFxuICAgICAgLy8gTW9jayBjcnlwdG8ucmFuZG9tQnl0ZXMgdG8gcmV0dXJuIGEgc21hbGwgbnVtYmVyXG4gICAgICBjb25zdCBvcmlnaW5hbFJhbmRvbUJ5dGVzID0gcmVxdWlyZSgnY3J5cHRvJykucmFuZG9tQnl0ZXM7XG4gICAgICBjb25zdCBtb2NrUmFuZG9tQnl0ZXMgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKEJ1ZmZlci5mcm9tKFswLCAwLCAwLCAxXSkpOyAvLyBWZXJ5IHNtYWxsIG51bWJlclxuICAgICAgcmVxdWlyZSgnY3J5cHRvJykucmFuZG9tQnl0ZXMgPSBtb2NrUmFuZG9tQnl0ZXM7XG4gICAgICBcbiAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCBzZXJ2aWNlLmdlbmVyYXRlQ29kZShtb2NrVXNlcklkKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGNvZGUpLnRvTWF0Y2goL15cXGR7Nn0kLyk7XG4gICAgICBleHBlY3QoY29kZS5sZW5ndGgpLnRvQmUoNik7XG4gICAgICBcbiAgICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgZnVuY3Rpb25cbiAgICAgIHJlcXVpcmUoJ2NyeXB0bycpLnJhbmRvbUJ5dGVzID0gb3JpZ2luYWxSYW5kb21CeXRlcztcbiAgICB9KTtcbiAgfSk7XG59KTsiXSwibmFtZXMiOlsibW9ja0RiIiwiaW5zZXJ0IiwiamVzdCIsImZuIiwic2VsZWN0IiwidXBkYXRlIiwiZGVsZXRlIiwidHJhbnNhY3Rpb24iLCJtb2NrIiwiZGIiLCJkZXNjcmliZSIsInNlcnZpY2UiLCJtb2NrVXNlcklkIiwibW9ja0VtYWlsIiwibW9ja0NvZGUiLCJiZWZvcmVFYWNoIiwiRW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZSIsImNsZWFyQWxsTW9ja3MiLCJhZnRlckVhY2giLCJyZXN0b3JlQWxsTW9ja3MiLCJpdCIsImRlbGV0ZVVzZXJDb2Rlc1NweSIsInNweU9uIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJtb2NrVmFsdWVzIiwidW5kZWZpbmVkIiwibW9ja1JldHVyblZhbHVlIiwidmFsdWVzIiwiY29kZSIsImdlbmVyYXRlQ29kZSIsImV4cGVjdCIsInRvTWF0Y2giLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsInRvSGF2ZUJlZW5DYWxsZWQiLCJvYmplY3RDb250YWluaW5nIiwidXNlcklkIiwic3RyaW5nTWF0Y2hpbmciLCJleHBpcmVzQXQiLCJhbnkiLCJEYXRlIiwiYXR0ZW1wdHNVc2VkIiwiYmVmb3JlVGltZSIsIm5vdyIsImFmdGVyVGltZSIsImNhbGxBcmdzIiwiY2FsbHMiLCJleHBpcmF0aW9uVGltZSIsImdldFRpbWUiLCJleHBlY3RlZE1pbiIsImV4cGVjdGVkTWF4IiwidG9CZUdyZWF0ZXJUaGFuIiwidG9CZUxlc3NUaGFuIiwibW9ja1VzZXIiLCJpZCIsImlzRW1haWxWZXJpZmllZCIsIm1vY2tWZXJpZmljYXRpb25Db2RlIiwiY3JlYXRlZEF0IiwibW9ja1VzZXJMaW1pdCIsIm1vY2tVc2VyV2hlcmUiLCJsaW1pdCIsIm1vY2tVc2VyRnJvbSIsIndoZXJlIiwibW9ja1JldHVyblZhbHVlT25jZSIsImZyb20iLCJtb2NrQ29kZUxpbWl0IiwibW9ja0NvZGVXaGVyZSIsIm1vY2tDb2RlRnJvbSIsIm1vY2tUeCIsInNldCIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsImNhbGxiYWNrIiwicmVzdWx0IiwidmFsaWRhdGVDb2RlIiwidG9CZSIsInJlamVjdHMiLCJ0b1Rocm93IiwiVmVyaWZpY2F0aW9uQ29kZUVycm9yIiwiVmVyaWZpY2F0aW9uRXJyb3IiLCJVU0VSX05PVF9GT1VORCIsIkFMUkVBRFlfVkVSSUZJRUQiLCJDT0RFX0lOVkFMSUQiLCJleHBpcmVkQ29kZSIsIm1vY2tEZWxldGVXaGVyZSIsIkNPREVfRVhQSVJFRCIsIm1heEF0dGVtcHRzQ29kZSIsIlRPT19NQU5ZX0FUVEVNUFRTIiwibW9ja1VwZGF0ZVdoZXJlIiwibW9ja1VwZGF0ZVNldCIsImluY3JlbWVudEF0dGVtcHRzIiwicmVzb2x2ZXMiLCJ0b0JlVW5kZWZpbmVkIiwibm90IiwibW9ja0RlbGV0ZVJlc3VsdCIsInJvd0NvdW50IiwiY2xlYW51cEV4cGlyZWRDb2RlcyIsImRlbGV0ZVVzZXJDb2RlcyIsIm1vY2tBY3RpdmVDb2RlIiwibW9ja0xpbWl0IiwibW9ja1doZXJlIiwibW9ja0Zyb20iLCJnZXRVc2VyQWN0aXZlQ29kZSIsInRvRXF1YWwiLCJ0b0JlTnVsbCIsImhhc0FjdGl2ZUNvZGUiLCJtb2NrRnJvbTEiLCJtb2NrRnJvbTIiLCJtb2NrRnJvbTMiLCJnZXRDb2RlU3RhdHMiLCJ0b3RhbEFjdGl2ZSIsImV4cGlyZWRDb3VudCIsImhpZ2hBdHRlbXB0Q291bnQiLCJjb2RlcyIsIlNldCIsImkiLCJhZGQiLCJzaXplIiwibGVuZ3RoIiwib3JpZ2luYWxSYW5kb21CeXRlcyIsInJlcXVpcmUiLCJyYW5kb21CeXRlcyIsIm1vY2tSYW5kb21CeXRlcyIsIkJ1ZmZlciJdLCJtYXBwaW5ncyI6Ijs7Ozt5QkFBa0U7OENBZ0JxQjtBQWR2RixpREFBaUQ7QUFDakQsTUFBTUEsU0FBUztJQUNiQyxRQUFRQyxhQUFJLENBQUNDLEVBQUU7SUFDZkMsUUFBUUYsYUFBSSxDQUFDQyxFQUFFO0lBQ2ZFLFFBQVFILGFBQUksQ0FBQ0MsRUFBRTtJQUNmRyxRQUFRSixhQUFJLENBQUNDLEVBQUU7SUFDZkksYUFBYUwsYUFBSSxDQUFDQyxFQUFFO0FBQ3RCO0FBRUFELGFBQUksQ0FBQ00sSUFBSSxDQUFDLFlBQVks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