{"version":3,"sources":["/Users/stefanbekker/projects/fancy-planties/src/lib/auth/server.ts"],"sourcesContent":["import 'server-only';\n\nimport { cookies } from 'next/headers';\nimport { redirect } from 'next/navigation';\nimport { lucia } from './lucia';\nimport { cache } from 'react';\nimport { getUserById } from './index';\nimport type { User, Session } from '../db/schema';\n\n// Session cookie management\nexport async function setSessionCookie(sessionId: string): Promise<void> {\n  const sessionCookie = lucia.createSessionCookie(sessionId);\n  (await cookies()).set(sessionCookie.name, sessionCookie.value, sessionCookie.attributes);\n}\n\nexport async function clearSessionCookie(): Promise<void> {\n  const sessionCookie = lucia.createBlankSessionCookie();\n  (await cookies()).set(sessionCookie.name, sessionCookie.value, sessionCookie.attributes);\n}\n\n// Cached session validation for performance\nexport const validateRequest = cache(async (): Promise<{ user: User; session: Session } | { user: null; session: null }> => {\n  const sessionId = (await cookies()).get(lucia.sessionCookieName)?.value ?? null;\n  \n  if (!sessionId) {\n    return {\n      user: null,\n      session: null,\n    };\n  }\n\n  const result = await lucia.validateSession(sessionId);\n  \n  // Next.js throws when you attempt to set cookie when rendering page\n  try {\n    if (result.session && result.session.fresh) {\n      const sessionCookie = lucia.createSessionCookie(result.session.id);\n      (await cookies()).set(sessionCookie.name, sessionCookie.value, sessionCookie.attributes);\n    }\n    if (!result.session) {\n      const sessionCookie = lucia.createBlankSessionCookie();\n      (await cookies()).set(sessionCookie.name, sessionCookie.value, sessionCookie.attributes);\n    }\n  } catch {\n    // Ignore cookie setting errors in server components\n  }\n  \n  // Convert Lucia result to our expected format\n  if (result.user && result.session) {\n    // Get full user data from database\n    const fullUser = await getUserById(parseInt(result.user.id));\n    if (!fullUser) {\n      return { user: null, session: null };\n    }\n    \n    return {\n      user: fullUser,\n      session: {\n        id: result.session.id,\n        userId: parseInt(result.user.id),\n        expiresAt: result.session.expiresAt,\n      },\n    };\n  }\n  \n  return {\n    user: null,\n    session: null,\n  };\n});\n\n// Server-side session validation\nexport async function getAuthSession() {\n  return await validateRequest();\n}\n\n// Require authenticated user or redirect\nexport async function requireAuthSession(redirectTo: string = '/auth/signin') {\n  const { user, session } = await validateRequest();\n  \n  if (!user || !session) {\n    redirect(redirectTo);\n  }\n  \n  return { user, session };\n}\n\n// Require authenticated and email verified user or redirect\nexport async function requireVerifiedSession(redirectTo: string = '/auth/signin') {\n  const { user, session } = await validateRequest();\n  \n  if (!user || !session) {\n    redirect(redirectTo);\n  }\n  \n  if (!user.isEmailVerified) {\n    redirect('/auth/verify-email');\n  }\n  \n  return { user, session };\n}\n\n// Check if user has verified email (without redirect)\nexport async function isEmailVerified(): Promise<boolean> {\n  const { user } = await validateRequest();\n  return !!(user && user.isEmailVerified);\n}\n\n// Check if user is authenticated (without redirect)\nexport async function isAuthenticated(): Promise<boolean> {\n  const { user, session } = await validateRequest();\n  return !!(user && session);\n}\n\n// Validate request and require email verification for API routes\nexport async function validateVerifiedRequest(): Promise<{ user: User; session: Session } | { user: null; session: null; error: string }> {\n  const { user, session } = await validateRequest();\n  \n  if (!user || !session) {\n    return { user: null, session: null, error: 'Unauthorized' };\n  }\n  \n  if (!user.isEmailVerified) {\n    return { user: null, session: null, error: 'Email verification required' };\n  }\n  \n  return { user, session };\n}\n\n// Redirect authenticated users away from auth pages\nexport async function redirectIfAuthenticated(redirectTo: string = '/dashboard') {\n  const { user, session } = await validateRequest();\n  \n  if (user && session) {\n    redirect(redirectTo);\n  }\n}\n\n// Session cleanup utility\nexport async function cleanupExpiredSessions(): Promise<void> {\n  try {\n    // This would typically be run as a background job\n    // For now, we'll rely on Lucia's built-in cleanup\n    console.log('Session cleanup would run here');\n  } catch (error) {\n    console.error('Session cleanup error:', error);\n  }\n}"],"names":["cleanupExpiredSessions","clearSessionCookie","getAuthSession","isAuthenticated","isEmailVerified","redirectIfAuthenticated","requireAuthSession","requireVerifiedSession","setSessionCookie","validateRequest","validateVerifiedRequest","sessionId","sessionCookie","lucia","createSessionCookie","cookies","set","name","value","attributes","createBlankSessionCookie","cache","get","sessionCookieName","user","session","result","validateSession","fresh","id","fullUser","getUserById","parseInt","userId","expiresAt","redirectTo","redirect","error","console","log"],"mappings":";;;;;;;;;;;QA2IsBA;eAAAA;;QA5HAC;eAAAA;;QAyDAC;eAAAA;;QAqCAC;eAAAA;;QANAC;eAAAA;;QA2BAC;eAAAA;;QArDAC;eAAAA;;QAWAC;eAAAA;;QA9EAC;eAAAA;;QAWTC;eAAAA;;QA8FSC;eAAAA;;;QAnHf;yBAEiB;4BACC;uBACH;uBACA;uBACM;AAIrB,eAAeF,iBAAiBG,SAAiB;IACtD,MAAMC,gBAAgBC,YAAK,CAACC,mBAAmB,CAACH;IAC/C,CAAA,MAAMI,IAAAA,gBAAO,GAAC,EAAGC,GAAG,CAACJ,cAAcK,IAAI,EAAEL,cAAcM,KAAK,EAAEN,cAAcO,UAAU;AACzF;AAEO,eAAelB;IACpB,MAAMW,gBAAgBC,YAAK,CAACO,wBAAwB;IACnD,CAAA,MAAML,IAAAA,gBAAO,GAAC,EAAGC,GAAG,CAACJ,cAAcK,IAAI,EAAEL,cAAcM,KAAK,EAAEN,cAAcO,UAAU;AACzF;AAGO,MAAMV,kBAAkBY,IAAAA,YAAK,EAAC;IACnC,MAAMV,YAAY,AAAC,CAAA,MAAMI,IAAAA,gBAAO,GAAC,EAAGO,GAAG,CAACT,YAAK,CAACU,iBAAiB,GAAGL,SAAS;IAE3E,IAAI,CAACP,WAAW;QACd,OAAO;YACLa,MAAM;YACNC,SAAS;QACX;IACF;IAEA,MAAMC,SAAS,MAAMb,YAAK,CAACc,eAAe,CAAChB;IAE3C,oEAAoE;IACpE,IAAI;QACF,IAAIe,OAAOD,OAAO,IAAIC,OAAOD,OAAO,CAACG,KAAK,EAAE;YAC1C,MAAMhB,gBAAgBC,YAAK,CAACC,mBAAmB,CAACY,OAAOD,OAAO,CAACI,EAAE;YAChE,CAAA,MAAMd,IAAAA,gBAAO,GAAC,EAAGC,GAAG,CAACJ,cAAcK,IAAI,EAAEL,cAAcM,KAAK,EAAEN,cAAcO,UAAU;QACzF;QACA,IAAI,CAACO,OAAOD,OAAO,EAAE;YACnB,MAAMb,gBAAgBC,YAAK,CAACO,wBAAwB;YACnD,CAAA,MAAML,IAAAA,gBAAO,GAAC,EAAGC,GAAG,CAACJ,cAAcK,IAAI,EAAEL,cAAcM,KAAK,EAAEN,cAAcO,UAAU;QACzF;IACF,EAAE,OAAM;IACN,oDAAoD;IACtD;IAEA,8CAA8C;IAC9C,IAAIO,OAAOF,IAAI,IAAIE,OAAOD,OAAO,EAAE;QACjC,mCAAmC;QACnC,MAAMK,WAAW,MAAMC,IAAAA,kBAAW,EAACC,SAASN,OAAOF,IAAI,CAACK,EAAE;QAC1D,IAAI,CAACC,UAAU;YACb,OAAO;gBAAEN,MAAM;gBAAMC,SAAS;YAAK;QACrC;QAEA,OAAO;YACLD,MAAMM;YACNL,SAAS;gBACPI,IAAIH,OAAOD,OAAO,CAACI,EAAE;gBACrBI,QAAQD,SAASN,OAAOF,IAAI,CAACK,EAAE;gBAC/BK,WAAWR,OAAOD,OAAO,CAACS,SAAS;YACrC;QACF;IACF;IAEA,OAAO;QACLV,MAAM;QACNC,SAAS;IACX;AACF;AAGO,eAAevB;IACpB,OAAO,MAAMO;AACf;AAGO,eAAeH,mBAAmB6B,aAAqB,cAAc;IAC1E,MAAM,EAAEX,IAAI,EAAEC,OAAO,EAAE,GAAG,MAAMhB;IAEhC,IAAI,CAACe,QAAQ,CAACC,SAAS;QACrBW,IAAAA,oBAAQ,EAACD;IACX;IAEA,OAAO;QAAEX;QAAMC;IAAQ;AACzB;AAGO,eAAelB,uBAAuB4B,aAAqB,cAAc;IAC9E,MAAM,EAAEX,IAAI,EAAEC,OAAO,EAAE,GAAG,MAAMhB;IAEhC,IAAI,CAACe,QAAQ,CAACC,SAAS;QACrBW,IAAAA,oBAAQ,EAACD;IACX;IAEA,IAAI,CAACX,KAAKpB,eAAe,EAAE;QACzBgC,IAAAA,oBAAQ,EAAC;IACX;IAEA,OAAO;QAAEZ;QAAMC;IAAQ;AACzB;AAGO,eAAerB;IACpB,MAAM,EAAEoB,IAAI,EAAE,GAAG,MAAMf;IACvB,OAAO,CAAC,CAAEe,CAAAA,QAAQA,KAAKpB,eAAe,AAAD;AACvC;AAGO,eAAeD;IACpB,MAAM,EAAEqB,IAAI,EAAEC,OAAO,EAAE,GAAG,MAAMhB;IAChC,OAAO,CAAC,CAAEe,CAAAA,QAAQC,OAAM;AAC1B;AAGO,eAAef;IACpB,MAAM,EAAEc,IAAI,EAAEC,OAAO,EAAE,GAAG,MAAMhB;IAEhC,IAAI,CAACe,QAAQ,CAACC,SAAS;QACrB,OAAO;YAAED,MAAM;YAAMC,SAAS;YAAMY,OAAO;QAAe;IAC5D;IAEA,IAAI,CAACb,KAAKpB,eAAe,EAAE;QACzB,OAAO;YAAEoB,MAAM;YAAMC,SAAS;YAAMY,OAAO;QAA8B;IAC3E;IAEA,OAAO;QAAEb;QAAMC;IAAQ;AACzB;AAGO,eAAepB,wBAAwB8B,aAAqB,YAAY;IAC7E,MAAM,EAAEX,IAAI,EAAEC,OAAO,EAAE,GAAG,MAAMhB;IAEhC,IAAIe,QAAQC,SAAS;QACnBW,IAAAA,oBAAQ,EAACD;IACX;AACF;AAGO,eAAenC;IACpB,IAAI;QACF,kDAAkD;QAClD,kDAAkD;QAClDsC,QAAQC,GAAG,CAAC;IACd,EAAE,OAAOF,OAAO;QACdC,QAAQD,KAAK,CAAC,0BAA0BA;IAC1C;AACF"}