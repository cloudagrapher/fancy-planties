1f5aeb5b4a2b4c3b7bbd5ba3d60d759d
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _emailverificationratelimiter = require("../../lib/services/email-verification-rate-limiter");
describe('EmailVerificationRateLimiter', ()=>{
    let rateLimiter;
    beforeEach(()=>{
        // Create a new instance with shorter windows for testing
        rateLimiter = new _emailverificationratelimiter.EmailVerificationRateLimiter({
            maxVerificationAttempts: 3,
            verificationWindowMs: 1000,
            maxResendRequests: 2,
            resendWindowMs: 1000,
            resendCooldownMs: 500,
            maxEmailVerificationRequests: 5,
            emailVerificationWindowMs: 1000
        });
    });
    afterEach(()=>{
        // Clean up after each test
        rateLimiter.cleanup();
    });
    describe('checkVerificationAttempts', ()=>{
        it('should allow requests within limit', ()=>{
            const identifier = '192.168.1.1';
            // First request should be allowed
            const result1 = rateLimiter.checkVerificationAttempts(identifier);
            expect(result1.allowed).toBe(true);
            expect(result1.remaining).toBe(2);
            // Second request should be allowed
            const result2 = rateLimiter.checkVerificationAttempts(identifier);
            expect(result2.allowed).toBe(true);
            expect(result2.remaining).toBe(1);
            // Third request should be allowed
            const result3 = rateLimiter.checkVerificationAttempts(identifier);
            expect(result3.allowed).toBe(true);
            expect(result3.remaining).toBe(0);
        });
        it('should block requests over limit', ()=>{
            const identifier = '192.168.1.1';
            // Use up the limit
            for(let i = 0; i < 3; i++){
                rateLimiter.checkVerificationAttempts(identifier);
            }
            // Fourth request should be blocked
            const result = rateLimiter.checkVerificationAttempts(identifier);
            expect(result.allowed).toBe(false);
            expect(result.remaining).toBe(0);
            expect(result.retryAfter).toBeGreaterThan(0);
        });
        it('should reset after window expires', async ()=>{
            const identifier = '192.168.1.1';
            // Use up the limit
            for(let i = 0; i < 3; i++){
                rateLimiter.checkVerificationAttempts(identifier);
            }
            // Should be blocked
            expect(rateLimiter.checkVerificationAttempts(identifier).allowed).toBe(false);
            // Wait for window to expire
            await new Promise((resolve)=>setTimeout(resolve, 1100));
            // Should be allowed again
            const result = rateLimiter.checkVerificationAttempts(identifier);
            expect(result.allowed).toBe(true);
            expect(result.remaining).toBe(2);
        });
    });
    describe('checkResendRequests', ()=>{
        it('should allow requests within limit', ()=>{
            const email = 'test@example.com';
            const identifier = '192.168.1.1';
            // First request should be allowed
            const result1 = rateLimiter.checkResendRequests(email, identifier);
            expect(result1.allowed).toBe(true);
            expect(result1.remaining).toBe(1);
            // Record success to update cooldown
            rateLimiter.recordResendSuccess(email);
            // Wait for cooldown
            return new Promise((resolve)=>{
                setTimeout(()=>{
                    // Second request should be allowed after cooldown
                    const result2 = rateLimiter.checkResendRequests(email, identifier);
                    expect(result2.allowed).toBe(true);
                    expect(result2.remaining).toBe(0);
                    resolve(undefined);
                }, 600); // Wait for cooldown to expire
            });
        });
        it('should enforce cooldown period', ()=>{
            const email = 'test@example.com';
            const identifier = '192.168.1.1';
            // First request
            rateLimiter.checkResendRequests(email, identifier);
            rateLimiter.recordResendSuccess(email);
            // Immediate second request should be blocked by cooldown
            const result = rateLimiter.checkResendRequests(email, identifier);
            expect(result.allowed).toBe(false);
            expect(result.cooldownRemaining).toBeGreaterThan(0);
        });
        it('should block requests over hourly limit', ()=>{
            const email = 'test@example.com';
            const identifier = '192.168.1.1';
            // Use up the limit (with cooldown waits)
            rateLimiter.checkResendRequests(email, identifier);
            rateLimiter.recordResendSuccess(email);
            // Wait for cooldown
            return new Promise((resolve)=>{
                setTimeout(()=>{
                    rateLimiter.checkResendRequests(email, identifier);
                    rateLimiter.recordResendSuccess(email);
                    setTimeout(()=>{
                        // Third request should be blocked by hourly limit
                        const result = rateLimiter.checkResendRequests(email, identifier);
                        expect(result.allowed).toBe(false);
                        expect(result.retryAfter).toBeGreaterThan(0);
                        resolve(undefined);
                    }, 600);
                }, 600);
            });
        });
    });
    describe('checkEmailVerificationActivity', ()=>{
        it('should allow requests within limit', ()=>{
            const identifier = '192.168.1.1';
            for(let i = 0; i < 5; i++){
                const result = rateLimiter.checkEmailVerificationActivity(identifier);
                expect(result.allowed).toBe(true);
                expect(result.remaining).toBe(4 - i);
            }
        });
        it('should block requests over limit', ()=>{
            const identifier = '192.168.1.1';
            // Use up the limit
            for(let i = 0; i < 5; i++){
                rateLimiter.checkEmailVerificationActivity(identifier);
            }
            // Sixth request should be blocked
            const result = rateLimiter.checkEmailVerificationActivity(identifier);
            expect(result.allowed).toBe(false);
            expect(result.remaining).toBe(0);
        });
    });
    describe('detectSuspiciousActivity', ()=>{
        it('should detect rapid verification attempts', ()=>{
            const identifier = '192.168.1.1';
            const email = 'test@example.com';
            // Make rapid attempts
            for(let i = 0; i < 8; i++){
                rateLimiter.checkVerificationAttempts(identifier, email);
            }
            const isSuspicious = rateLimiter.detectSuspiciousActivity(identifier, email);
            expect(isSuspicious).toBe(true);
        });
        it('should not detect normal activity as suspicious', ()=>{
            const identifier = '192.168.1.1';
            const email = 'test@example.com';
            // Make normal attempts
            for(let i = 0; i < 2; i++){
                rateLimiter.checkVerificationAttempts(identifier, email);
            }
            const isSuspicious = rateLimiter.detectSuspiciousActivity(identifier, email);
            expect(isSuspicious).toBe(false);
        });
    });
    describe('getSecurityEvents', ()=>{
        it('should return security events', ()=>{
            const identifier = '192.168.1.1';
            // Trigger rate limit to generate security event
            for(let i = 0; i < 4; i++){
                rateLimiter.checkVerificationAttempts(identifier);
            }
            const events = rateLimiter.getSecurityEvents();
            expect(events.length).toBeGreaterThan(0);
            expect(events[0].type).toBe('RATE_LIMIT_EXCEEDED');
            expect(events[0].identifier).toBe(identifier);
        });
        it('should filter events by timestamp', ()=>{
            const identifier = '192.168.1.1';
            const now = Date.now();
            // Trigger rate limit
            for(let i = 0; i < 4; i++){
                rateLimiter.checkVerificationAttempts(identifier);
            }
            // Get events since future timestamp (should be empty)
            const futureEvents = rateLimiter.getSecurityEvents(now + 1000);
            expect(futureEvents.length).toBe(0);
            // Get events since past timestamp (should include events)
            const pastEvents = rateLimiter.getSecurityEvents(now - 1000);
            expect(pastEvents.length).toBeGreaterThan(0);
        });
    });
    describe('cleanup', ()=>{
        it('should clean up expired data', async ()=>{
            const identifier = '192.168.1.1';
            // Generate some data
            rateLimiter.checkVerificationAttempts(identifier);
            rateLimiter.checkEmailVerificationActivity(identifier);
            // Check stats before cleanup
            const statsBefore = rateLimiter.getStats();
            expect(statsBefore.verificationAttempts).toBeGreaterThan(0);
            expect(statsBefore.emailVerificationActivity).toBeGreaterThan(0);
            // Wait for data to expire
            await new Promise((resolve)=>setTimeout(resolve, 1100));
            // Run cleanup
            rateLimiter.cleanup();
            // Check stats after cleanup
            const statsAfter = rateLimiter.getStats();
            expect(statsAfter.verificationAttempts).toBe(0);
            expect(statsAfter.emailVerificationActivity).toBe(0);
        });
    });
    describe('getStats', ()=>{
        it('should return current statistics', ()=>{
            const identifier = '192.168.1.1';
            const email = 'test@example.com';
            // Generate some activity
            rateLimiter.checkVerificationAttempts(identifier);
            rateLimiter.checkResendRequests(email, identifier);
            rateLimiter.checkEmailVerificationActivity(identifier);
            const stats = rateLimiter.getStats();
            expect(stats.verificationAttempts).toBe(1);
            expect(stats.resendRequests).toBe(1);
            expect(stats.emailVerificationActivity).toBe(1);
            expect(stats.resendCooldowns).toBe(0); // No successful resends yet
            expect(stats.securityEvents).toBe(0); // No rate limits exceeded yet
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdGVmYW5iZWtrZXIvcHJvamVjdHMvZmFuY3ktcGxhbnRpZXMvc3JjL19fdGVzdHNfXy9zZXJ2aWNlcy9lbWFpbC12ZXJpZmljYXRpb24tcmF0ZS1saW1pdGVyLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRW1haWxWZXJpZmljYXRpb25SYXRlTGltaXRlciwgREVGQVVMVF9FTUFJTF9WRVJJRklDQVRJT05fUkFURV9MSU1JVF9DT05GSUcgfSBmcm9tICdAL2xpYi9zZXJ2aWNlcy9lbWFpbC12ZXJpZmljYXRpb24tcmF0ZS1saW1pdGVyJztcblxuZGVzY3JpYmUoJ0VtYWlsVmVyaWZpY2F0aW9uUmF0ZUxpbWl0ZXInLCAoKSA9PiB7XG4gIGxldCByYXRlTGltaXRlcjogRW1haWxWZXJpZmljYXRpb25SYXRlTGltaXRlcjtcbiAgXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIC8vIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSB3aXRoIHNob3J0ZXIgd2luZG93cyBmb3IgdGVzdGluZ1xuICAgIHJhdGVMaW1pdGVyID0gbmV3IEVtYWlsVmVyaWZpY2F0aW9uUmF0ZUxpbWl0ZXIoe1xuICAgICAgbWF4VmVyaWZpY2F0aW9uQXR0ZW1wdHM6IDMsXG4gICAgICB2ZXJpZmljYXRpb25XaW5kb3dNczogMTAwMCwgLy8gMSBzZWNvbmRcbiAgICAgIG1heFJlc2VuZFJlcXVlc3RzOiAyLFxuICAgICAgcmVzZW5kV2luZG93TXM6IDEwMDAsIC8vIDEgc2Vjb25kXG4gICAgICByZXNlbmRDb29sZG93bk1zOiA1MDAsIC8vIDAuNSBzZWNvbmRzXG4gICAgICBtYXhFbWFpbFZlcmlmaWNhdGlvblJlcXVlc3RzOiA1LFxuICAgICAgZW1haWxWZXJpZmljYXRpb25XaW5kb3dNczogMTAwMCwgLy8gMSBzZWNvbmRcbiAgICB9KTtcbiAgfSk7XG4gIFxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIC8vIENsZWFuIHVwIGFmdGVyIGVhY2ggdGVzdFxuICAgIHJhdGVMaW1pdGVyLmNsZWFudXAoKTtcbiAgfSk7XG4gIFxuICBkZXNjcmliZSgnY2hlY2tWZXJpZmljYXRpb25BdHRlbXB0cycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGFsbG93IHJlcXVlc3RzIHdpdGhpbiBsaW1pdCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSAnMTkyLjE2OC4xLjEnO1xuICAgICAgXG4gICAgICAvLyBGaXJzdCByZXF1ZXN0IHNob3VsZCBiZSBhbGxvd2VkXG4gICAgICBjb25zdCByZXN1bHQxID0gcmF0ZUxpbWl0ZXIuY2hlY2tWZXJpZmljYXRpb25BdHRlbXB0cyhpZGVudGlmaWVyKTtcbiAgICAgIGV4cGVjdChyZXN1bHQxLmFsbG93ZWQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0MS5yZW1haW5pbmcpLnRvQmUoMik7XG4gICAgICBcbiAgICAgIC8vIFNlY29uZCByZXF1ZXN0IHNob3VsZCBiZSBhbGxvd2VkXG4gICAgICBjb25zdCByZXN1bHQyID0gcmF0ZUxpbWl0ZXIuY2hlY2tWZXJpZmljYXRpb25BdHRlbXB0cyhpZGVudGlmaWVyKTtcbiAgICAgIGV4cGVjdChyZXN1bHQyLmFsbG93ZWQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0Mi5yZW1haW5pbmcpLnRvQmUoMSk7XG4gICAgICBcbiAgICAgIC8vIFRoaXJkIHJlcXVlc3Qgc2hvdWxkIGJlIGFsbG93ZWRcbiAgICAgIGNvbnN0IHJlc3VsdDMgPSByYXRlTGltaXRlci5jaGVja1ZlcmlmaWNhdGlvbkF0dGVtcHRzKGlkZW50aWZpZXIpO1xuICAgICAgZXhwZWN0KHJlc3VsdDMuYWxsb3dlZCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQzLnJlbWFpbmluZykudG9CZSgwKTtcbiAgICB9KTtcbiAgICBcbiAgICBpdCgnc2hvdWxkIGJsb2NrIHJlcXVlc3RzIG92ZXIgbGltaXQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBpZGVudGlmaWVyID0gJzE5Mi4xNjguMS4xJztcbiAgICAgIFxuICAgICAgLy8gVXNlIHVwIHRoZSBsaW1pdFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgcmF0ZUxpbWl0ZXIuY2hlY2tWZXJpZmljYXRpb25BdHRlbXB0cyhpZGVudGlmaWVyKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRm91cnRoIHJlcXVlc3Qgc2hvdWxkIGJlIGJsb2NrZWRcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHJhdGVMaW1pdGVyLmNoZWNrVmVyaWZpY2F0aW9uQXR0ZW1wdHMoaWRlbnRpZmllcik7XG4gICAgICBleHBlY3QocmVzdWx0LmFsbG93ZWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5yZW1haW5pbmcpLnRvQmUoMCk7XG4gICAgICBleHBlY3QocmVzdWx0LnJldHJ5QWZ0ZXIpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICB9KTtcbiAgICBcbiAgICBpdCgnc2hvdWxkIHJlc2V0IGFmdGVyIHdpbmRvdyBleHBpcmVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaWRlbnRpZmllciA9ICcxOTIuMTY4LjEuMSc7XG4gICAgICBcbiAgICAgIC8vIFVzZSB1cCB0aGUgbGltaXRcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIHJhdGVMaW1pdGVyLmNoZWNrVmVyaWZpY2F0aW9uQXR0ZW1wdHMoaWRlbnRpZmllcik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBiZSBibG9ja2VkXG4gICAgICBleHBlY3QocmF0ZUxpbWl0ZXIuY2hlY2tWZXJpZmljYXRpb25BdHRlbXB0cyhpZGVudGlmaWVyKS5hbGxvd2VkKS50b0JlKGZhbHNlKTtcbiAgICAgIFxuICAgICAgLy8gV2FpdCBmb3Igd2luZG93IHRvIGV4cGlyZVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDExMDApKTtcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIGJlIGFsbG93ZWQgYWdhaW5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHJhdGVMaW1pdGVyLmNoZWNrVmVyaWZpY2F0aW9uQXR0ZW1wdHMoaWRlbnRpZmllcik7XG4gICAgICBleHBlY3QocmVzdWx0LmFsbG93ZWQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LnJlbWFpbmluZykudG9CZSgyKTtcbiAgICB9KTtcbiAgfSk7XG4gIFxuICBkZXNjcmliZSgnY2hlY2tSZXNlbmRSZXF1ZXN0cycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGFsbG93IHJlcXVlc3RzIHdpdGhpbiBsaW1pdCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGVtYWlsID0gJ3Rlc3RAZXhhbXBsZS5jb20nO1xuICAgICAgY29uc3QgaWRlbnRpZmllciA9ICcxOTIuMTY4LjEuMSc7XG4gICAgICBcbiAgICAgIC8vIEZpcnN0IHJlcXVlc3Qgc2hvdWxkIGJlIGFsbG93ZWRcbiAgICAgIGNvbnN0IHJlc3VsdDEgPSByYXRlTGltaXRlci5jaGVja1Jlc2VuZFJlcXVlc3RzKGVtYWlsLCBpZGVudGlmaWVyKTtcbiAgICAgIGV4cGVjdChyZXN1bHQxLmFsbG93ZWQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0MS5yZW1haW5pbmcpLnRvQmUoMSk7XG4gICAgICBcbiAgICAgIC8vIFJlY29yZCBzdWNjZXNzIHRvIHVwZGF0ZSBjb29sZG93blxuICAgICAgcmF0ZUxpbWl0ZXIucmVjb3JkUmVzZW5kU3VjY2VzcyhlbWFpbCk7XG4gICAgICBcbiAgICAgIC8vIFdhaXQgZm9yIGNvb2xkb3duXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIC8vIFNlY29uZCByZXF1ZXN0IHNob3VsZCBiZSBhbGxvd2VkIGFmdGVyIGNvb2xkb3duXG4gICAgICAgICAgY29uc3QgcmVzdWx0MiA9IHJhdGVMaW1pdGVyLmNoZWNrUmVzZW5kUmVxdWVzdHMoZW1haWwsIGlkZW50aWZpZXIpO1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQyLmFsbG93ZWQpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgZXhwZWN0KHJlc3VsdDIucmVtYWluaW5nKS50b0JlKDApO1xuICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgfSwgNjAwKTsgLy8gV2FpdCBmb3IgY29vbGRvd24gdG8gZXhwaXJlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBcbiAgICBpdCgnc2hvdWxkIGVuZm9yY2UgY29vbGRvd24gcGVyaW9kJywgKCkgPT4ge1xuICAgICAgY29uc3QgZW1haWwgPSAndGVzdEBleGFtcGxlLmNvbSc7XG4gICAgICBjb25zdCBpZGVudGlmaWVyID0gJzE5Mi4xNjguMS4xJztcbiAgICAgIFxuICAgICAgLy8gRmlyc3QgcmVxdWVzdFxuICAgICAgcmF0ZUxpbWl0ZXIuY2hlY2tSZXNlbmRSZXF1ZXN0cyhlbWFpbCwgaWRlbnRpZmllcik7XG4gICAgICByYXRlTGltaXRlci5yZWNvcmRSZXNlbmRTdWNjZXNzKGVtYWlsKTtcbiAgICAgIFxuICAgICAgLy8gSW1tZWRpYXRlIHNlY29uZCByZXF1ZXN0IHNob3VsZCBiZSBibG9ja2VkIGJ5IGNvb2xkb3duXG4gICAgICBjb25zdCByZXN1bHQgPSByYXRlTGltaXRlci5jaGVja1Jlc2VuZFJlcXVlc3RzKGVtYWlsLCBpZGVudGlmaWVyKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuYWxsb3dlZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmNvb2xkb3duUmVtYWluaW5nKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgfSk7XG4gICAgXG4gICAgaXQoJ3Nob3VsZCBibG9jayByZXF1ZXN0cyBvdmVyIGhvdXJseSBsaW1pdCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGVtYWlsID0gJ3Rlc3RAZXhhbXBsZS5jb20nO1xuICAgICAgY29uc3QgaWRlbnRpZmllciA9ICcxOTIuMTY4LjEuMSc7XG4gICAgICBcbiAgICAgIC8vIFVzZSB1cCB0aGUgbGltaXQgKHdpdGggY29vbGRvd24gd2FpdHMpXG4gICAgICByYXRlTGltaXRlci5jaGVja1Jlc2VuZFJlcXVlc3RzKGVtYWlsLCBpZGVudGlmaWVyKTtcbiAgICAgIHJhdGVMaW1pdGVyLnJlY29yZFJlc2VuZFN1Y2Nlc3MoZW1haWwpO1xuICAgICAgXG4gICAgICAvLyBXYWl0IGZvciBjb29sZG93blxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICByYXRlTGltaXRlci5jaGVja1Jlc2VuZFJlcXVlc3RzKGVtYWlsLCBpZGVudGlmaWVyKTtcbiAgICAgICAgICByYXRlTGltaXRlci5yZWNvcmRSZXNlbmRTdWNjZXNzKGVtYWlsKTtcbiAgICAgICAgICBcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIC8vIFRoaXJkIHJlcXVlc3Qgc2hvdWxkIGJlIGJsb2NrZWQgYnkgaG91cmx5IGxpbWl0XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSByYXRlTGltaXRlci5jaGVja1Jlc2VuZFJlcXVlc3RzKGVtYWlsLCBpZGVudGlmaWVyKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuYWxsb3dlZCkudG9CZShmYWxzZSk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LnJldHJ5QWZ0ZXIpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgICB9LCA2MDApO1xuICAgICAgICB9LCA2MDApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuICBcbiAgZGVzY3JpYmUoJ2NoZWNrRW1haWxWZXJpZmljYXRpb25BY3Rpdml0eScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGFsbG93IHJlcXVlc3RzIHdpdGhpbiBsaW1pdCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSAnMTkyLjE2OC4xLjEnO1xuICAgICAgXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSByYXRlTGltaXRlci5jaGVja0VtYWlsVmVyaWZpY2F0aW9uQWN0aXZpdHkoaWRlbnRpZmllcik7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuYWxsb3dlZCkudG9CZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5yZW1haW5pbmcpLnRvQmUoNCAtIGkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGl0KCdzaG91bGQgYmxvY2sgcmVxdWVzdHMgb3ZlciBsaW1pdCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSAnMTkyLjE2OC4xLjEnO1xuICAgICAgXG4gICAgICAvLyBVc2UgdXAgdGhlIGxpbWl0XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICByYXRlTGltaXRlci5jaGVja0VtYWlsVmVyaWZpY2F0aW9uQWN0aXZpdHkoaWRlbnRpZmllcik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNpeHRoIHJlcXVlc3Qgc2hvdWxkIGJlIGJsb2NrZWRcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHJhdGVMaW1pdGVyLmNoZWNrRW1haWxWZXJpZmljYXRpb25BY3Rpdml0eShpZGVudGlmaWVyKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuYWxsb3dlZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LnJlbWFpbmluZykudG9CZSgwKTtcbiAgICB9KTtcbiAgfSk7XG4gIFxuICBkZXNjcmliZSgnZGV0ZWN0U3VzcGljaW91c0FjdGl2aXR5JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZGV0ZWN0IHJhcGlkIHZlcmlmaWNhdGlvbiBhdHRlbXB0cycsICgpID0+IHtcbiAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSAnMTkyLjE2OC4xLjEnO1xuICAgICAgY29uc3QgZW1haWwgPSAndGVzdEBleGFtcGxlLmNvbSc7XG4gICAgICBcbiAgICAgIC8vIE1ha2UgcmFwaWQgYXR0ZW1wdHNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICAgIHJhdGVMaW1pdGVyLmNoZWNrVmVyaWZpY2F0aW9uQXR0ZW1wdHMoaWRlbnRpZmllciwgZW1haWwpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBpc1N1c3BpY2lvdXMgPSByYXRlTGltaXRlci5kZXRlY3RTdXNwaWNpb3VzQWN0aXZpdHkoaWRlbnRpZmllciwgZW1haWwpO1xuICAgICAgZXhwZWN0KGlzU3VzcGljaW91cykudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgICBcbiAgICBpdCgnc2hvdWxkIG5vdCBkZXRlY3Qgbm9ybWFsIGFjdGl2aXR5IGFzIHN1c3BpY2lvdXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBpZGVudGlmaWVyID0gJzE5Mi4xNjguMS4xJztcbiAgICAgIGNvbnN0IGVtYWlsID0gJ3Rlc3RAZXhhbXBsZS5jb20nO1xuICAgICAgXG4gICAgICAvLyBNYWtlIG5vcm1hbCBhdHRlbXB0c1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgcmF0ZUxpbWl0ZXIuY2hlY2tWZXJpZmljYXRpb25BdHRlbXB0cyhpZGVudGlmaWVyLCBlbWFpbCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGlzU3VzcGljaW91cyA9IHJhdGVMaW1pdGVyLmRldGVjdFN1c3BpY2lvdXNBY3Rpdml0eShpZGVudGlmaWVyLCBlbWFpbCk7XG4gICAgICBleHBlY3QoaXNTdXNwaWNpb3VzKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcbiAgfSk7XG4gIFxuICBkZXNjcmliZSgnZ2V0U2VjdXJpdHlFdmVudHMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gc2VjdXJpdHkgZXZlbnRzJywgKCkgPT4ge1xuICAgICAgY29uc3QgaWRlbnRpZmllciA9ICcxOTIuMTY4LjEuMSc7XG4gICAgICBcbiAgICAgIC8vIFRyaWdnZXIgcmF0ZSBsaW1pdCB0byBnZW5lcmF0ZSBzZWN1cml0eSBldmVudFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgcmF0ZUxpbWl0ZXIuY2hlY2tWZXJpZmljYXRpb25BdHRlbXB0cyhpZGVudGlmaWVyKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgZXZlbnRzID0gcmF0ZUxpbWl0ZXIuZ2V0U2VjdXJpdHlFdmVudHMoKTtcbiAgICAgIGV4cGVjdChldmVudHMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICBleHBlY3QoZXZlbnRzWzBdLnR5cGUpLnRvQmUoJ1JBVEVfTElNSVRfRVhDRUVERUQnKTtcbiAgICAgIGV4cGVjdChldmVudHNbMF0uaWRlbnRpZmllcikudG9CZShpZGVudGlmaWVyKTtcbiAgICB9KTtcbiAgICBcbiAgICBpdCgnc2hvdWxkIGZpbHRlciBldmVudHMgYnkgdGltZXN0YW1wJywgKCkgPT4ge1xuICAgICAgY29uc3QgaWRlbnRpZmllciA9ICcxOTIuMTY4LjEuMSc7XG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBUcmlnZ2VyIHJhdGUgbGltaXRcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIHJhdGVMaW1pdGVyLmNoZWNrVmVyaWZpY2F0aW9uQXR0ZW1wdHMoaWRlbnRpZmllcik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEdldCBldmVudHMgc2luY2UgZnV0dXJlIHRpbWVzdGFtcCAoc2hvdWxkIGJlIGVtcHR5KVxuICAgICAgY29uc3QgZnV0dXJlRXZlbnRzID0gcmF0ZUxpbWl0ZXIuZ2V0U2VjdXJpdHlFdmVudHMobm93ICsgMTAwMCk7XG4gICAgICBleHBlY3QoZnV0dXJlRXZlbnRzLmxlbmd0aCkudG9CZSgwKTtcbiAgICAgIFxuICAgICAgLy8gR2V0IGV2ZW50cyBzaW5jZSBwYXN0IHRpbWVzdGFtcCAoc2hvdWxkIGluY2x1ZGUgZXZlbnRzKVxuICAgICAgY29uc3QgcGFzdEV2ZW50cyA9IHJhdGVMaW1pdGVyLmdldFNlY3VyaXR5RXZlbnRzKG5vdyAtIDEwMDApO1xuICAgICAgZXhwZWN0KHBhc3RFdmVudHMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgfSk7XG4gIH0pO1xuICBcbiAgZGVzY3JpYmUoJ2NsZWFudXAnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjbGVhbiB1cCBleHBpcmVkIGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpZGVudGlmaWVyID0gJzE5Mi4xNjguMS4xJztcbiAgICAgIFxuICAgICAgLy8gR2VuZXJhdGUgc29tZSBkYXRhXG4gICAgICByYXRlTGltaXRlci5jaGVja1ZlcmlmaWNhdGlvbkF0dGVtcHRzKGlkZW50aWZpZXIpO1xuICAgICAgcmF0ZUxpbWl0ZXIuY2hlY2tFbWFpbFZlcmlmaWNhdGlvbkFjdGl2aXR5KGlkZW50aWZpZXIpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBzdGF0cyBiZWZvcmUgY2xlYW51cFxuICAgICAgY29uc3Qgc3RhdHNCZWZvcmUgPSByYXRlTGltaXRlci5nZXRTdGF0cygpO1xuICAgICAgZXhwZWN0KHN0YXRzQmVmb3JlLnZlcmlmaWNhdGlvbkF0dGVtcHRzKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICBleHBlY3Qoc3RhdHNCZWZvcmUuZW1haWxWZXJpZmljYXRpb25BY3Rpdml0eSkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgXG4gICAgICAvLyBXYWl0IGZvciBkYXRhIHRvIGV4cGlyZVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDExMDApKTtcbiAgICAgIFxuICAgICAgLy8gUnVuIGNsZWFudXBcbiAgICAgIHJhdGVMaW1pdGVyLmNsZWFudXAoKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgc3RhdHMgYWZ0ZXIgY2xlYW51cFxuICAgICAgY29uc3Qgc3RhdHNBZnRlciA9IHJhdGVMaW1pdGVyLmdldFN0YXRzKCk7XG4gICAgICBleHBlY3Qoc3RhdHNBZnRlci52ZXJpZmljYXRpb25BdHRlbXB0cykudG9CZSgwKTtcbiAgICAgIGV4cGVjdChzdGF0c0FmdGVyLmVtYWlsVmVyaWZpY2F0aW9uQWN0aXZpdHkpLnRvQmUoMCk7XG4gICAgfSk7XG4gIH0pO1xuICBcbiAgZGVzY3JpYmUoJ2dldFN0YXRzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIGN1cnJlbnQgc3RhdGlzdGljcycsICgpID0+IHtcbiAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSAnMTkyLjE2OC4xLjEnO1xuICAgICAgY29uc3QgZW1haWwgPSAndGVzdEBleGFtcGxlLmNvbSc7XG4gICAgICBcbiAgICAgIC8vIEdlbmVyYXRlIHNvbWUgYWN0aXZpdHlcbiAgICAgIHJhdGVMaW1pdGVyLmNoZWNrVmVyaWZpY2F0aW9uQXR0ZW1wdHMoaWRlbnRpZmllcik7XG4gICAgICByYXRlTGltaXRlci5jaGVja1Jlc2VuZFJlcXVlc3RzKGVtYWlsLCBpZGVudGlmaWVyKTtcbiAgICAgIHJhdGVMaW1pdGVyLmNoZWNrRW1haWxWZXJpZmljYXRpb25BY3Rpdml0eShpZGVudGlmaWVyKTtcbiAgICAgIFxuICAgICAgY29uc3Qgc3RhdHMgPSByYXRlTGltaXRlci5nZXRTdGF0cygpO1xuICAgICAgZXhwZWN0KHN0YXRzLnZlcmlmaWNhdGlvbkF0dGVtcHRzKS50b0JlKDEpO1xuICAgICAgZXhwZWN0KHN0YXRzLnJlc2VuZFJlcXVlc3RzKS50b0JlKDEpO1xuICAgICAgZXhwZWN0KHN0YXRzLmVtYWlsVmVyaWZpY2F0aW9uQWN0aXZpdHkpLnRvQmUoMSk7XG4gICAgICBleHBlY3Qoc3RhdHMucmVzZW5kQ29vbGRvd25zKS50b0JlKDApOyAvLyBObyBzdWNjZXNzZnVsIHJlc2VuZHMgeWV0XG4gICAgICBleHBlY3Qoc3RhdHMuc2VjdXJpdHlFdmVudHMpLnRvQmUoMCk7IC8vIE5vIHJhdGUgbGltaXRzIGV4Y2VlZGVkIHlldFxuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJkZXNjcmliZSIsInJhdGVMaW1pdGVyIiwiYmVmb3JlRWFjaCIsIkVtYWlsVmVyaWZpY2F0aW9uUmF0ZUxpbWl0ZXIiLCJtYXhWZXJpZmljYXRpb25BdHRlbXB0cyIsInZlcmlmaWNhdGlvbldpbmRvd01zIiwibWF4UmVzZW5kUmVxdWVzdHMiLCJyZXNlbmRXaW5kb3dNcyIsInJlc2VuZENvb2xkb3duTXMiLCJtYXhFbWFpbFZlcmlmaWNhdGlvblJlcXVlc3RzIiwiZW1haWxWZXJpZmljYXRpb25XaW5kb3dNcyIsImFmdGVyRWFjaCIsImNsZWFudXAiLCJpdCIsImlkZW50aWZpZXIiLCJyZXN1bHQxIiwiY2hlY2tWZXJpZmljYXRpb25BdHRlbXB0cyIsImV4cGVjdCIsImFsbG93ZWQiLCJ0b0JlIiwicmVtYWluaW5nIiwicmVzdWx0MiIsInJlc3VsdDMiLCJpIiwicmVzdWx0IiwicmV0cnlBZnRlciIsInRvQmVHcmVhdGVyVGhhbiIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImVtYWlsIiwiY2hlY2tSZXNlbmRSZXF1ZXN0cyIsInJlY29yZFJlc2VuZFN1Y2Nlc3MiLCJ1bmRlZmluZWQiLCJjb29sZG93blJlbWFpbmluZyIsImNoZWNrRW1haWxWZXJpZmljYXRpb25BY3Rpdml0eSIsImlzU3VzcGljaW91cyIsImRldGVjdFN1c3BpY2lvdXNBY3Rpdml0eSIsImV2ZW50cyIsImdldFNlY3VyaXR5RXZlbnRzIiwibGVuZ3RoIiwidHlwZSIsIm5vdyIsIkRhdGUiLCJmdXR1cmVFdmVudHMiLCJwYXN0RXZlbnRzIiwic3RhdHNCZWZvcmUiLCJnZXRTdGF0cyIsInZlcmlmaWNhdGlvbkF0dGVtcHRzIiwiZW1haWxWZXJpZmljYXRpb25BY3Rpdml0eSIsInN0YXRzQWZ0ZXIiLCJz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