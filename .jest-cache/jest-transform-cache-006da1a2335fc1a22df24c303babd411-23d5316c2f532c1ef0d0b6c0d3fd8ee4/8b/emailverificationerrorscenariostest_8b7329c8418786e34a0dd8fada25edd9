37906c8126c887bf7b84f9e21951ce99
/**
 * Email Verification Error Scenario Tests
 * Tests email service failure handling, retry logic, expired code scenarios, 
 * cleanup processes, and concurrent verification attempts
 * Requirements: 1.4, 3.1, 7.3, 7.4
 */ "use strict";
// Mock email service and related modules
jest.mock('@/lib/services/resend-email-service');
jest.mock('@/lib/services/email-service');
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _databasetestmanager = require("../../test-utils/setup/database-test-manager.js");
const _emailverificationcodeservice = require("../../lib/services/email-verification-code-service");
const _resendemailservice = require("../../lib/services/resend-email-service");
const _emailservice = require("../../lib/services/email-service");
const mockEmailService = {
    sendVerificationEmail: jest.fn()
};
const mockCreateEmailService = _resendemailservice.createEmailService;
const mockSendEmailWithRetry = require('@/lib/services/email-service').sendEmailWithRetry;
// Mock environment variables
const originalEnv = process.env;
beforeAll(()=>{
    process.env = {
        ...originalEnv,
        RESEND_API_KEY: 'test-api-key',
        FROM_EMAIL: 'test@example.com',
        FROM_NAME: 'Test App',
        VERIFICATION_CODE_EXPIRY_MINUTES: '10',
        MAX_VERIFICATION_ATTEMPTS: '5',
        RESEND_COOLDOWN_SECONDS: '60',
        MAX_RESEND_PER_HOUR: '5',
        NODE_ENV: 'test'
    };
});
afterAll(()=>{
    process.env = originalEnv;
});
describe('Email Verification Error Scenario Tests', ()=>{
    let dbManager;
    beforeEach(async ()=>{
        jest.clearAllMocks();
        dbManager = (0, _databasetestmanager.createDatabaseTestManager)();
        // Default to successful email service
        mockCreateEmailService.mockReturnValue(mockEmailService);
        mockSendEmailWithRetry.mockResolvedValue(true);
        mockEmailService.sendVerificationEmail.mockResolvedValue(true);
    });
    afterEach(async ()=>{
        await dbManager.cleanup();
    });
    describe('Email Service Failure Handling and Retry Logic', ()=>{
        it('should handle email service errors during code generation', async ()=>{
            // Mock email service to fail
            mockSendEmailWithRetry.mockRejectedValue(new _emailservice.EmailServiceError('Quota exceeded', 'QUOTA_EXCEEDED'));
            // Create user
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Generate verification code (should work even if email fails)
            const verificationCode = await _emailverificationcodeservice.emailVerificationCodeService.generateCode(user.id);
            expect(verificationCode).toMatch(/^\d{6}$/);
            // Verify code was stored in database
            const emailCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(emailCodes).toHaveLength(1);
            expect(emailCodes[0].code).toBe(verificationCode);
            // User should still be unverified
            const unverifiedUser = await dbManager.getUserById(user.id);
            expect(unverifiedUser.isEmailVerified).toBe(false);
        });
        it('should handle different types of email service errors', async ()=>{
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Test API error
            mockSendEmailWithRetry.mockRejectedValue(new _emailservice.EmailServiceError('API error', 'API_ERROR'));
            const code1 = await _emailverificationcodeservice.emailVerificationCodeService.generateCode(user.id);
            expect(code1).toMatch(/^\d{6}$/);
            // Test network error
            mockSendEmailWithRetry.mockRejectedValue(new _emailservice.EmailServiceError('Network timeout', 'NETWORK_ERROR'));
            const code2 = await _emailverificationcodeservice.emailVerificationCodeService.generateCode(user.id);
            expect(code2).toMatch(/^\d{6}$/);
            expect(code2).not.toBe(code1); // Should be different code
            // Verify only latest code exists
            const emailCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(emailCodes).toHaveLength(1);
            expect(emailCodes[0].code).toBe(code2);
        });
        it('should handle email service errors but still generate codes', async ()=>{
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Mock various email service errors
            mockSendEmailWithRetry.mockRejectedValue(new _emailservice.EmailServiceError('Invalid email', 'INVALID_EMAIL'));
            // Code generation should still work
            const code = await _emailverificationcodeservice.emailVerificationCodeService.generateCode(user.id);
            expect(code).toMatch(/^\d{6}$/);
            // Verify code was stored
            const emailCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(emailCodes).toHaveLength(1);
            expect(emailCodes[0].code).toBe(code);
        });
    });
    describe('Expired Code Scenarios and Cleanup Processes', ()=>{
        it('should handle expired verification codes properly', async ()=>{
            // Create user with expired verification code
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            const expiredCode = await dbManager.createTestEmailCode({
                userId: user.id,
                code: '123456',
                expiresAt: new Date(Date.now() - 60000),
                attemptsUsed: 0
            });
            // Try to verify with expired code using service
            try {
                await _emailverificationcodeservice.emailVerificationCodeService.validateCode('test@example.com', '123456');
                fail('Should have thrown an error for expired code');
            } catch (error) {
                expect(error.code).toBe('CODE_EXPIRED');
            }
            // Verify user is still not verified
            const unverifiedUser = await dbManager.getUserById(user.id);
            expect(unverifiedUser.isEmailVerified).toBe(false);
        });
        it('should clean up expired codes during verification service operations', async ()=>{
            // Create user with multiple codes, some expired
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Create expired code
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '111111',
                expiresAt: new Date(Date.now() - 60000),
                attemptsUsed: 0
            });
            // Create valid code
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '222222',
                expiresAt: new Date(Date.now() + 600000),
                attemptsUsed: 0
            });
            // Trigger cleanup by calling the service method
            await _emailverificationcodeservice.emailVerificationCodeService.cleanupExpiredCodes();
            // Verify expired code was cleaned up
            const remainingCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(remainingCodes).toHaveLength(1);
            expect(remainingCodes[0].code).toBe('222222');
        });
        it('should handle cleanup when user is deleted', async ()=>{
            // Create user with verification codes
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '123456',
                expiresAt: new Date(Date.now() + 600000),
                attemptsUsed: 0
            });
            // Verify code exists
            let emailCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(emailCodes).toHaveLength(1);
            // Delete user (should cascade delete codes due to foreign key constraint)
            await dbManager.deleteUser(user.id);
            // Verify codes were cleaned up
            emailCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(emailCodes).toHaveLength(0);
        });
        it('should handle multiple expired codes for same user', async ()=>{
            // Create user with multiple expired codes
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Create multiple expired codes
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '111111',
                expiresAt: new Date(Date.now() - 120000),
                attemptsUsed: 0
            });
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '222222',
                expiresAt: new Date(Date.now() - 60000),
                attemptsUsed: 0
            });
            // Try to verify with one of the expired codes
            const verifyRequest = new NextRequest('http://localhost/api/auth/verify-email', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com',
                    code: '111111'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            const verifyResponse = await verifyEmailHandler(verifyRequest);
            const verifyData = await verifyResponse.json();
            // Assert expired code error
            expect(verifyResponse.status).toBe(400);
            expect(verifyData.error).toContain('Verification code has expired');
            // Cleanup expired codes
            await _emailverificationcodeservice.emailVerificationCodeService.cleanupExpiredCodes();
            // Verify all expired codes were cleaned up
            const remainingCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(remainingCodes).toHaveLength(0);
        });
    });
    describe('Concurrent Verification Attempts and Race Conditions', ()=>{
        it('should handle concurrent verification attempts safely', async ()=>{
            // Create user with verification code
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '123456',
                expiresAt: new Date(Date.now() + 600000),
                attemptsUsed: 0
            });
            // Create multiple concurrent verification requests
            const verifyRequest1 = new NextRequest('http://localhost/api/auth/verify-email', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com',
                    code: '123456'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            const verifyRequest2 = new NextRequest('http://localhost/api/auth/verify-email', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com',
                    code: '123456'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            // Execute concurrent requests
            const [response1, response2] = await Promise.all([
                verifyEmailHandler(verifyRequest1),
                verifyEmailHandler(verifyRequest2)
            ]);
            const data1 = await response1.json();
            const data2 = await response2.json();
            // One should succeed, one should fail (code already used)
            const responses = [
                {
                    status: response1.status,
                    data: data1
                },
                {
                    status: response2.status,
                    data: data2
                }
            ];
            const successResponses = responses.filter((r)=>r.status === 200);
            const failureResponses = responses.filter((r)=>r.status !== 200);
            expect(successResponses).toHaveLength(1);
            expect(failureResponses).toHaveLength(1);
            // Verify user is verified only once
            const verifiedUser = await dbManager.getUserById(user.id);
            expect(verifiedUser.isEmailVerified).toBe(true);
            // Verify code was deleted
            const remainingCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(remainingCodes).toHaveLength(0);
        });
        it('should handle concurrent resend requests safely', async ()=>{
            // Create user
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Create multiple concurrent resend requests
            const resendRequest1 = new NextRequest('http://localhost/api/auth/resend-verification', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            const resendRequest2 = new NextRequest('http://localhost/api/auth/resend-verification', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            // Execute concurrent requests
            const [response1, response2] = await Promise.all([
                resendVerificationHandler(resendRequest1),
                resendVerificationHandler(resendRequest2)
            ]);
            // Both should succeed (rate limiting is handled by middleware)
            expect(response1.status).toBe(200);
            expect(response2.status).toBe(200);
            // Verify only one code exists (latest one)
            const emailCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(emailCodes).toHaveLength(1);
            // Verify email service was called (possibly multiple times due to concurrency)
            expect(mockSendEmailWithRetry).toHaveBeenCalled();
        });
        it('should handle race condition between verification and code expiration', async ()=>{
            // Create user with code that expires very soon
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '123456',
                expiresAt: new Date(Date.now() + 100),
                attemptsUsed: 0
            });
            // Wait for code to expire
            await new Promise((resolve)=>setTimeout(resolve, 150));
            // Try to verify with expired code
            const verifyRequest = new NextRequest('http://localhost/api/auth/verify-email', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com',
                    code: '123456'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            const verifyResponse = await verifyEmailHandler(verifyRequest);
            const verifyData = await verifyResponse.json();
            // Should handle expired code gracefully
            expect(verifyResponse.status).toBe(400);
            expect(verifyData.error).toContain('expired');
            // User should remain unverified
            const unverifiedUser = await dbManager.getUserById(user.id);
            expect(unverifiedUser.isEmailVerified).toBe(false);
        });
        it('should handle concurrent signup attempts with same email', async ()=>{
            // Create concurrent signup requests with same email
            const signupRequest1 = new NextRequest('http://localhost/api/auth/signup', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'SecurePass123!',
                    name: 'Test User 1'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            const signupRequest2 = new NextRequest('http://localhost/api/auth/signup', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'AnotherPass123!',
                    name: 'Test User 2'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            // Execute concurrent requests
            const [response1, response2] = await Promise.all([
                signupHandler(signupRequest1),
                signupHandler(signupRequest2)
            ]);
            const data1 = await response1.json();
            const data2 = await response2.json();
            // One should succeed, one should fail with duplicate email error
            const responses = [
                {
                    status: response1.status,
                    data: data1
                },
                {
                    status: response2.status,
                    data: data2
                }
            ];
            const successResponses = responses.filter((r)=>r.status === 200);
            const conflictResponses = responses.filter((r)=>r.status === 409);
            expect(successResponses).toHaveLength(1);
            expect(conflictResponses).toHaveLength(1);
            // Verify only one user was created
            const user = await dbManager.getUserByEmail('test@example.com');
            expect(user).toBeTruthy();
            // Verify only one set of verification codes exists
            const emailCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(emailCodes).toHaveLength(1);
        });
    });
    describe('Database Error Scenarios', ()=>{
        it('should handle database connection failures gracefully', async ()=>{
            // Mock database connection failure
            const originalDb = require('@/lib/db').db;
            // Mock database to throw connection error
            jest.doMock('@/lib/db', ()=>({
                    db: {
                        select: jest.fn().mockRejectedValue(new Error('Database connection failed')),
                        insert: jest.fn().mockRejectedValue(new Error('Database connection failed')),
                        update: jest.fn().mockRejectedValue(new Error('Database connection failed')),
                        delete: jest.fn().mockRejectedValue(new Error('Database connection failed'))
                    }
                }));
            const verifyRequest = new NextRequest('http://localhost/api/auth/verify-email', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com',
                    code: '123456'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            const verifyResponse = await verifyEmailHandler(verifyRequest);
            const verifyData = await verifyResponse.json();
            // Should handle database error gracefully
            expect(verifyResponse.status).toBe(500);
            expect(verifyData.error).toBe('Internal server error');
            // Restore original database
            jest.doMock('@/lib/db', ()=>({
                    db: originalDb
                }));
        });
        it('should handle transaction rollback scenarios', async ()=>{
            // This test would require more complex database transaction mocking
            // For now, we'll test that the service handles errors during code validation
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Create code with maximum attempts reached
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '123456',
                expiresAt: new Date(Date.now() + 600000),
                attemptsUsed: 5
            });
            const verifyRequest = new NextRequest('http://localhost/api/auth/verify-email', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com',
                    code: '123456'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            const verifyResponse = await verifyEmailHandler(verifyRequest);
            const verifyData = await verifyResponse.json();
            // Should handle too many attempts error
            expect(verifyResponse.status).toBe(429);
            expect(verifyData.error).toContain('Too many verification attempts');
            // User should remain unverified
            const unverifiedUser = await dbManager.getUserById(user.id);
            expect(unverifiedUser.isEmailVerified).toBe(false);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdGVmYW5iZWtrZXIvcHJvamVjdHMvZmFuY3ktcGxhbnRpZXMvc3JjL19fdGVzdHNfXy9pbnRlZ3JhdGlvbi9lbWFpbC12ZXJpZmljYXRpb24tZXJyb3Itc2NlbmFyaW9zLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFbWFpbCBWZXJpZmljYXRpb24gRXJyb3IgU2NlbmFyaW8gVGVzdHNcbiAqIFRlc3RzIGVtYWlsIHNlcnZpY2UgZmFpbHVyZSBoYW5kbGluZywgcmV0cnkgbG9naWMsIGV4cGlyZWQgY29kZSBzY2VuYXJpb3MsIFxuICogY2xlYW51cCBwcm9jZXNzZXMsIGFuZCBjb25jdXJyZW50IHZlcmlmaWNhdGlvbiBhdHRlbXB0c1xuICogUmVxdWlyZW1lbnRzOiAxLjQsIDMuMSwgNy4zLCA3LjRcbiAqL1xuXG5pbXBvcnQgeyBjcmVhdGVEYXRhYmFzZVRlc3RNYW5hZ2VyIH0gZnJvbSAnQC90ZXN0LXV0aWxzL3NldHVwL2RhdGFiYXNlLXRlc3QtbWFuYWdlcic7XG5pbXBvcnQgeyBlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlIH0gZnJvbSAnQC9saWIvc2VydmljZXMvZW1haWwtdmVyaWZpY2F0aW9uLWNvZGUtc2VydmljZSc7XG5pbXBvcnQgeyBjcmVhdGVFbWFpbFNlcnZpY2UgfSBmcm9tICdAL2xpYi9zZXJ2aWNlcy9yZXNlbmQtZW1haWwtc2VydmljZSc7XG5pbXBvcnQgeyBFbWFpbFNlcnZpY2VFcnJvciB9IGZyb20gJ0AvbGliL3NlcnZpY2VzL2VtYWlsLXNlcnZpY2UnO1xuXG4vLyBNb2NrIGVtYWlsIHNlcnZpY2UgYW5kIHJlbGF0ZWQgbW9kdWxlc1xuamVzdC5tb2NrKCdAL2xpYi9zZXJ2aWNlcy9yZXNlbmQtZW1haWwtc2VydmljZScpO1xuamVzdC5tb2NrKCdAL2xpYi9zZXJ2aWNlcy9lbWFpbC1zZXJ2aWNlJyk7XG5cbmNvbnN0IG1vY2tFbWFpbFNlcnZpY2UgPSB7XG4gIHNlbmRWZXJpZmljYXRpb25FbWFpbDogamVzdC5mbigpLFxufTtcblxuY29uc3QgbW9ja0NyZWF0ZUVtYWlsU2VydmljZSA9IGNyZWF0ZUVtYWlsU2VydmljZSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiBjcmVhdGVFbWFpbFNlcnZpY2U+O1xuY29uc3QgbW9ja1NlbmRFbWFpbFdpdGhSZXRyeSA9IHJlcXVpcmUoJ0AvbGliL3NlcnZpY2VzL2VtYWlsLXNlcnZpY2UnKS5zZW5kRW1haWxXaXRoUmV0cnkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+O1xuXG4vLyBNb2NrIGVudmlyb25tZW50IHZhcmlhYmxlc1xuY29uc3Qgb3JpZ2luYWxFbnYgPSBwcm9jZXNzLmVudjtcblxuYmVmb3JlQWxsKCgpID0+IHtcbiAgcHJvY2Vzcy5lbnYgPSB7XG4gICAgLi4ub3JpZ2luYWxFbnYsXG4gICAgUkVTRU5EX0FQSV9LRVk6ICd0ZXN0LWFwaS1rZXknLFxuICAgIEZST01fRU1BSUw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICBGUk9NX05BTUU6ICdUZXN0IEFwcCcsXG4gICAgVkVSSUZJQ0FUSU9OX0NPREVfRVhQSVJZX01JTlVURVM6ICcxMCcsXG4gICAgTUFYX1ZFUklGSUNBVElPTl9BVFRFTVBUUzogJzUnLFxuICAgIFJFU0VORF9DT09MRE9XTl9TRUNPTkRTOiAnNjAnLFxuICAgIE1BWF9SRVNFTkRfUEVSX0hPVVI6ICc1JyxcbiAgICBOT0RFX0VOVjogJ3Rlc3QnLFxuICB9O1xufSk7XG5cbmFmdGVyQWxsKCgpID0+IHtcbiAgcHJvY2Vzcy5lbnYgPSBvcmlnaW5hbEVudjtcbn0pO1xuXG5kZXNjcmliZSgnRW1haWwgVmVyaWZpY2F0aW9uIEVycm9yIFNjZW5hcmlvIFRlc3RzJywgKCkgPT4ge1xuICBsZXQgZGJNYW5hZ2VyOiBhbnk7XG5cbiAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgZGJNYW5hZ2VyID0gY3JlYXRlRGF0YWJhc2VUZXN0TWFuYWdlcigpO1xuICAgIFxuICAgIC8vIERlZmF1bHQgdG8gc3VjY2Vzc2Z1bCBlbWFpbCBzZXJ2aWNlXG4gICAgbW9ja0NyZWF0ZUVtYWlsU2VydmljZS5tb2NrUmV0dXJuVmFsdWUobW9ja0VtYWlsU2VydmljZSk7XG4gICAgbW9ja1NlbmRFbWFpbFdpdGhSZXRyeS5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKTtcbiAgICBtb2NrRW1haWxTZXJ2aWNlLnNlbmRWZXJpZmljYXRpb25FbWFpbC5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBkYk1hbmFnZXIuY2xlYW51cCgpO1xuICB9KTtcblxuICBkZXNjcmliZSgnRW1haWwgU2VydmljZSBGYWlsdXJlIEhhbmRsaW5nIGFuZCBSZXRyeSBMb2dpYycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBlbWFpbCBzZXJ2aWNlIGVycm9ycyBkdXJpbmcgY29kZSBnZW5lcmF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBlbWFpbCBzZXJ2aWNlIHRvIGZhaWxcbiAgICAgIG1vY2tTZW5kRW1haWxXaXRoUmV0cnkubW9ja1JlamVjdGVkVmFsdWUobmV3IEVtYWlsU2VydmljZUVycm9yKCdRdW90YSBleGNlZWRlZCcsICdRVU9UQV9FWENFRURFRCcpKTtcblxuICAgICAgLy8gQ3JlYXRlIHVzZXJcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdFVzZXIoe1xuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAnVGVzdCBVc2VyJyxcbiAgICAgICAgcGFzc3dvcmRIYXNoOiAnaGFzaGVkX3Bhc3N3b3JkJyxcbiAgICAgICAgaXNFbWFpbFZlcmlmaWVkOiBmYWxzZSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBHZW5lcmF0ZSB2ZXJpZmljYXRpb24gY29kZSAoc2hvdWxkIHdvcmsgZXZlbiBpZiBlbWFpbCBmYWlscylcbiAgICAgIGNvbnN0IHZlcmlmaWNhdGlvbkNvZGUgPSBhd2FpdCBlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlLmdlbmVyYXRlQ29kZSh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdCh2ZXJpZmljYXRpb25Db2RlKS50b01hdGNoKC9eXFxkezZ9JC8pO1xuXG4gICAgICAvLyBWZXJpZnkgY29kZSB3YXMgc3RvcmVkIGluIGRhdGFiYXNlXG4gICAgICBjb25zdCBlbWFpbENvZGVzID0gYXdhaXQgZGJNYW5hZ2VyLmdldEVtYWlsQ29kZXNCeVVzZXJJZCh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdChlbWFpbENvZGVzKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QoZW1haWxDb2Rlc1swXS5jb2RlKS50b0JlKHZlcmlmaWNhdGlvbkNvZGUpO1xuXG4gICAgICAvLyBVc2VyIHNob3VsZCBzdGlsbCBiZSB1bnZlcmlmaWVkXG4gICAgICBjb25zdCB1bnZlcmlmaWVkVXNlciA9IGF3YWl0IGRiTWFuYWdlci5nZXRVc2VyQnlJZCh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdCh1bnZlcmlmaWVkVXNlci5pc0VtYWlsVmVyaWZpZWQpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZGlmZmVyZW50IHR5cGVzIG9mIGVtYWlsIHNlcnZpY2UgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0VXNlcih7XG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgICBwYXNzd29yZEhhc2g6ICdoYXNoZWRfcGFzc3dvcmQnLFxuICAgICAgICBpc0VtYWlsVmVyaWZpZWQ6IGZhbHNlLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFRlc3QgQVBJIGVycm9yXG4gICAgICBtb2NrU2VuZEVtYWlsV2l0aFJldHJ5Lm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFbWFpbFNlcnZpY2VFcnJvcignQVBJIGVycm9yJywgJ0FQSV9FUlJPUicpKTtcbiAgICAgIGNvbnN0IGNvZGUxID0gYXdhaXQgZW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS5nZW5lcmF0ZUNvZGUodXNlci5pZCk7XG4gICAgICBleHBlY3QoY29kZTEpLnRvTWF0Y2goL15cXGR7Nn0kLyk7XG5cbiAgICAgIC8vIFRlc3QgbmV0d29yayBlcnJvclxuICAgICAgbW9ja1NlbmRFbWFpbFdpdGhSZXRyeS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRW1haWxTZXJ2aWNlRXJyb3IoJ05ldHdvcmsgdGltZW91dCcsICdORVRXT1JLX0VSUk9SJykpO1xuICAgICAgY29uc3QgY29kZTIgPSBhd2FpdCBlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlLmdlbmVyYXRlQ29kZSh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdChjb2RlMikudG9NYXRjaCgvXlxcZHs2fSQvKTtcbiAgICAgIGV4cGVjdChjb2RlMikubm90LnRvQmUoY29kZTEpOyAvLyBTaG91bGQgYmUgZGlmZmVyZW50IGNvZGVcblxuICAgICAgLy8gVmVyaWZ5IG9ubHkgbGF0ZXN0IGNvZGUgZXhpc3RzXG4gICAgICBjb25zdCBlbWFpbENvZGVzID0gYXdhaXQgZGJNYW5hZ2VyLmdldEVtYWlsQ29kZXNCeVVzZXJJZCh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdChlbWFpbENvZGVzKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QoZW1haWxDb2Rlc1swXS5jb2RlKS50b0JlKGNvZGUyKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGVtYWlsIHNlcnZpY2UgZXJyb3JzIGJ1dCBzdGlsbCBnZW5lcmF0ZSBjb2RlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdFVzZXIoe1xuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAnVGVzdCBVc2VyJyxcbiAgICAgICAgcGFzc3dvcmRIYXNoOiAnaGFzaGVkX3Bhc3N3b3JkJyxcbiAgICAgICAgaXNFbWFpbFZlcmlmaWVkOiBmYWxzZSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNb2NrIHZhcmlvdXMgZW1haWwgc2VydmljZSBlcnJvcnNcbiAgICAgIG1vY2tTZW5kRW1haWxXaXRoUmV0cnkubW9ja1JlamVjdGVkVmFsdWUobmV3IEVtYWlsU2VydmljZUVycm9yKCdJbnZhbGlkIGVtYWlsJywgJ0lOVkFMSURfRU1BSUwnKSk7XG4gICAgICBcbiAgICAgIC8vIENvZGUgZ2VuZXJhdGlvbiBzaG91bGQgc3RpbGwgd29ya1xuICAgICAgY29uc3QgY29kZSA9IGF3YWl0IGVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UuZ2VuZXJhdGVDb2RlKHVzZXIuaWQpO1xuICAgICAgZXhwZWN0KGNvZGUpLnRvTWF0Y2goL15cXGR7Nn0kLyk7XG5cbiAgICAgIC8vIFZlcmlmeSBjb2RlIHdhcyBzdG9yZWRcbiAgICAgIGNvbnN0IGVtYWlsQ29kZXMgPSBhd2FpdCBkYk1hbmFnZXIuZ2V0RW1haWxDb2Rlc0J5VXNlcklkKHVzZXIuaWQpO1xuICAgICAgZXhwZWN0KGVtYWlsQ29kZXMpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChlbWFpbENvZGVzWzBdLmNvZGUpLnRvQmUoY29kZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFeHBpcmVkIENvZGUgU2NlbmFyaW9zIGFuZCBDbGVhbnVwIFByb2Nlc3NlcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBleHBpcmVkIHZlcmlmaWNhdGlvbiBjb2RlcyBwcm9wZXJseScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSB1c2VyIHdpdGggZXhwaXJlZCB2ZXJpZmljYXRpb24gY29kZVxuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0VXNlcih7XG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgICBwYXNzd29yZEhhc2g6ICdoYXNoZWRfcGFzc3dvcmQnLFxuICAgICAgICBpc0VtYWlsVmVyaWZpZWQ6IGZhbHNlLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGV4cGlyZWRDb2RlID0gYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RFbWFpbENvZGUoe1xuICAgICAgICB1c2VySWQ6IHVzZXIuaWQsXG4gICAgICAgIGNvZGU6ICcxMjM0NTYnLFxuICAgICAgICBleHBpcmVzQXQ6IG5ldyBEYXRlKERhdGUubm93KCkgLSA2MDAwMCksIC8vIEV4cGlyZWQgMSBtaW51dGUgYWdvXG4gICAgICAgIGF0dGVtcHRzVXNlZDogMCxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBUcnkgdG8gdmVyaWZ5IHdpdGggZXhwaXJlZCBjb2RlIHVzaW5nIHNlcnZpY2VcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UudmFsaWRhdGVDb2RlKCd0ZXN0QGV4YW1wbGUuY29tJywgJzEyMzQ1NicpO1xuICAgICAgICBmYWlsKCdTaG91bGQgaGF2ZSB0aHJvd24gYW4gZXJyb3IgZm9yIGV4cGlyZWQgY29kZScpO1xuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBleHBlY3QoZXJyb3IuY29kZSkudG9CZSgnQ09ERV9FWFBJUkVEJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFZlcmlmeSB1c2VyIGlzIHN0aWxsIG5vdCB2ZXJpZmllZFxuICAgICAgY29uc3QgdW52ZXJpZmllZFVzZXIgPSBhd2FpdCBkYk1hbmFnZXIuZ2V0VXNlckJ5SWQodXNlci5pZCk7XG4gICAgICBleHBlY3QodW52ZXJpZmllZFVzZXIuaXNFbWFpbFZlcmlmaWVkKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY2xlYW4gdXAgZXhwaXJlZCBjb2RlcyBkdXJpbmcgdmVyaWZpY2F0aW9uIHNlcnZpY2Ugb3BlcmF0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSB1c2VyIHdpdGggbXVsdGlwbGUgY29kZXMsIHNvbWUgZXhwaXJlZFxuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0VXNlcih7XG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgICBwYXNzd29yZEhhc2g6ICdoYXNoZWRfcGFzc3dvcmQnLFxuICAgICAgICBpc0VtYWlsVmVyaWZpZWQ6IGZhbHNlLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIENyZWF0ZSBleHBpcmVkIGNvZGVcbiAgICAgIGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0RW1haWxDb2RlKHtcbiAgICAgICAgdXNlcklkOiB1c2VyLmlkLFxuICAgICAgICBjb2RlOiAnMTExMTExJyxcbiAgICAgICAgZXhwaXJlc0F0OiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gNjAwMDApLCAvLyBFeHBpcmVkXG4gICAgICAgIGF0dGVtcHRzVXNlZDogMCxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBDcmVhdGUgdmFsaWQgY29kZVxuICAgICAgYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RFbWFpbENvZGUoe1xuICAgICAgICB1c2VySWQ6IHVzZXIuaWQsXG4gICAgICAgIGNvZGU6ICcyMjIyMjInLFxuICAgICAgICBleHBpcmVzQXQ6IG5ldyBEYXRlKERhdGUubm93KCkgKyA2MDAwMDApLCAvLyBWYWxpZCBmb3IgMTAgbWludXRlc1xuICAgICAgICBhdHRlbXB0c1VzZWQ6IDAsXG4gICAgICB9KTtcblxuICAgICAgLy8gVHJpZ2dlciBjbGVhbnVwIGJ5IGNhbGxpbmcgdGhlIHNlcnZpY2UgbWV0aG9kXG4gICAgICBhd2FpdCBlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlLmNsZWFudXBFeHBpcmVkQ29kZXMoKTtcblxuICAgICAgLy8gVmVyaWZ5IGV4cGlyZWQgY29kZSB3YXMgY2xlYW5lZCB1cFxuICAgICAgY29uc3QgcmVtYWluaW5nQ29kZXMgPSBhd2FpdCBkYk1hbmFnZXIuZ2V0RW1haWxDb2Rlc0J5VXNlcklkKHVzZXIuaWQpO1xuICAgICAgZXhwZWN0KHJlbWFpbmluZ0NvZGVzKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QocmVtYWluaW5nQ29kZXNbMF0uY29kZSkudG9CZSgnMjIyMjIyJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjbGVhbnVwIHdoZW4gdXNlciBpcyBkZWxldGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIHVzZXIgd2l0aCB2ZXJpZmljYXRpb24gY29kZXNcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdFVzZXIoe1xuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAnVGVzdCBVc2VyJyxcbiAgICAgICAgcGFzc3dvcmRIYXNoOiAnaGFzaGVkX3Bhc3N3b3JkJyxcbiAgICAgICAgaXNFbWFpbFZlcmlmaWVkOiBmYWxzZSxcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdEVtYWlsQ29kZSh7XG4gICAgICAgIHVzZXJJZDogdXNlci5pZCxcbiAgICAgICAgY29kZTogJzEyMzQ1NicsXG4gICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIDYwMDAwMCksXG4gICAgICAgIGF0dGVtcHRzVXNlZDogMCxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBWZXJpZnkgY29kZSBleGlzdHNcbiAgICAgIGxldCBlbWFpbENvZGVzID0gYXdhaXQgZGJNYW5hZ2VyLmdldEVtYWlsQ29kZXNCeVVzZXJJZCh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdChlbWFpbENvZGVzKS50b0hhdmVMZW5ndGgoMSk7XG5cbiAgICAgIC8vIERlbGV0ZSB1c2VyIChzaG91bGQgY2FzY2FkZSBkZWxldGUgY29kZXMgZHVlIHRvIGZvcmVpZ24ga2V5IGNvbnN0cmFpbnQpXG4gICAgICBhd2FpdCBkYk1hbmFnZXIuZGVsZXRlVXNlcih1c2VyLmlkKTtcblxuICAgICAgLy8gVmVyaWZ5IGNvZGVzIHdlcmUgY2xlYW5lZCB1cFxuICAgICAgZW1haWxDb2RlcyA9IGF3YWl0IGRiTWFuYWdlci5nZXRFbWFpbENvZGVzQnlVc2VySWQodXNlci5pZCk7XG4gICAgICBleHBlY3QoZW1haWxDb2RlcykudG9IYXZlTGVuZ3RoKDApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbXVsdGlwbGUgZXhwaXJlZCBjb2RlcyBmb3Igc2FtZSB1c2VyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIHVzZXIgd2l0aCBtdWx0aXBsZSBleHBpcmVkIGNvZGVzXG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RVc2VyKHtcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgICAgIHBhc3N3b3JkSGFzaDogJ2hhc2hlZF9wYXNzd29yZCcsXG4gICAgICAgIGlzRW1haWxWZXJpZmllZDogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgLy8gQ3JlYXRlIG11bHRpcGxlIGV4cGlyZWQgY29kZXNcbiAgICAgIGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0RW1haWxDb2RlKHtcbiAgICAgICAgdXNlcklkOiB1c2VyLmlkLFxuICAgICAgICBjb2RlOiAnMTExMTExJyxcbiAgICAgICAgZXhwaXJlc0F0OiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gMTIwMDAwKSwgLy8gRXhwaXJlZCAyIG1pbnV0ZXMgYWdvXG4gICAgICAgIGF0dGVtcHRzVXNlZDogMCxcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdEVtYWlsQ29kZSh7XG4gICAgICAgIHVzZXJJZDogdXNlci5pZCxcbiAgICAgICAgY29kZTogJzIyMjIyMicsXG4gICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDYwMDAwKSwgLy8gRXhwaXJlZCAxIG1pbnV0ZSBhZ29cbiAgICAgICAgYXR0ZW1wdHNVc2VkOiAwLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFRyeSB0byB2ZXJpZnkgd2l0aCBvbmUgb2YgdGhlIGV4cGlyZWQgY29kZXNcbiAgICAgIGNvbnN0IHZlcmlmeVJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvYXBpL2F1dGgvdmVyaWZ5LWVtYWlsJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgY29kZTogJzExMTExMScsXG4gICAgICAgIH0pLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB2ZXJpZnlSZXNwb25zZSA9IGF3YWl0IHZlcmlmeUVtYWlsSGFuZGxlcih2ZXJpZnlSZXF1ZXN0KTtcbiAgICAgIGNvbnN0IHZlcmlmeURhdGEgPSBhd2FpdCB2ZXJpZnlSZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIC8vIEFzc2VydCBleHBpcmVkIGNvZGUgZXJyb3JcbiAgICAgIGV4cGVjdCh2ZXJpZnlSZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAwKTtcbiAgICAgIGV4cGVjdCh2ZXJpZnlEYXRhLmVycm9yKS50b0NvbnRhaW4oJ1ZlcmlmaWNhdGlvbiBjb2RlIGhhcyBleHBpcmVkJyk7XG5cbiAgICAgIC8vIENsZWFudXAgZXhwaXJlZCBjb2Rlc1xuICAgICAgYXdhaXQgZW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS5jbGVhbnVwRXhwaXJlZENvZGVzKCk7XG5cbiAgICAgIC8vIFZlcmlmeSBhbGwgZXhwaXJlZCBjb2RlcyB3ZXJlIGNsZWFuZWQgdXBcbiAgICAgIGNvbnN0IHJlbWFpbmluZ0NvZGVzID0gYXdhaXQgZGJNYW5hZ2VyLmdldEVtYWlsQ29kZXNCeVVzZXJJZCh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdChyZW1haW5pbmdDb2RlcykudG9IYXZlTGVuZ3RoKDApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ29uY3VycmVudCBWZXJpZmljYXRpb24gQXR0ZW1wdHMgYW5kIFJhY2UgQ29uZGl0aW9ucycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjb25jdXJyZW50IHZlcmlmaWNhdGlvbiBhdHRlbXB0cyBzYWZlbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBDcmVhdGUgdXNlciB3aXRoIHZlcmlmaWNhdGlvbiBjb2RlXG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RVc2VyKHtcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgICAgIHBhc3N3b3JkSGFzaDogJ2hhc2hlZF9wYXNzd29yZCcsXG4gICAgICAgIGlzRW1haWxWZXJpZmllZDogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RFbWFpbENvZGUoe1xuICAgICAgICB1c2VySWQ6IHVzZXIuaWQsXG4gICAgICAgIGNvZGU6ICcxMjM0NTYnLFxuICAgICAgICBleHBpcmVzQXQ6IG5ldyBEYXRlKERhdGUubm93KCkgKyA2MDAwMDApLFxuICAgICAgICBhdHRlbXB0c1VzZWQ6IDAsXG4gICAgICB9KTtcblxuICAgICAgLy8gQ3JlYXRlIG11bHRpcGxlIGNvbmN1cnJlbnQgdmVyaWZpY2F0aW9uIHJlcXVlc3RzXG4gICAgICBjb25zdCB2ZXJpZnlSZXF1ZXN0MSA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdC9hcGkvYXV0aC92ZXJpZnktZW1haWwnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBjb2RlOiAnMTIzNDU2JyxcbiAgICAgICAgfSksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHZlcmlmeVJlcXVlc3QyID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0L2FwaS9hdXRoL3ZlcmlmeS1lbWFpbCcsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIGNvZGU6ICcxMjM0NTYnLFxuICAgICAgICB9KSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgLy8gRXhlY3V0ZSBjb25jdXJyZW50IHJlcXVlc3RzXG4gICAgICBjb25zdCBbcmVzcG9uc2UxLCByZXNwb25zZTJdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICB2ZXJpZnlFbWFpbEhhbmRsZXIodmVyaWZ5UmVxdWVzdDEpLFxuICAgICAgICB2ZXJpZnlFbWFpbEhhbmRsZXIodmVyaWZ5UmVxdWVzdDIpLFxuICAgICAgXSk7XG5cbiAgICAgIGNvbnN0IGRhdGExID0gYXdhaXQgcmVzcG9uc2UxLmpzb24oKTtcbiAgICAgIGNvbnN0IGRhdGEyID0gYXdhaXQgcmVzcG9uc2UyLmpzb24oKTtcblxuICAgICAgLy8gT25lIHNob3VsZCBzdWNjZWVkLCBvbmUgc2hvdWxkIGZhaWwgKGNvZGUgYWxyZWFkeSB1c2VkKVxuICAgICAgY29uc3QgcmVzcG9uc2VzID0gW1xuICAgICAgICB7IHN0YXR1czogcmVzcG9uc2UxLnN0YXR1cywgZGF0YTogZGF0YTEgfSxcbiAgICAgICAgeyBzdGF0dXM6IHJlc3BvbnNlMi5zdGF0dXMsIGRhdGE6IGRhdGEyIH0sXG4gICAgICBdO1xuXG4gICAgICBjb25zdCBzdWNjZXNzUmVzcG9uc2VzID0gcmVzcG9uc2VzLmZpbHRlcihyID0+IHIuc3RhdHVzID09PSAyMDApO1xuICAgICAgY29uc3QgZmFpbHVyZVJlc3BvbnNlcyA9IHJlc3BvbnNlcy5maWx0ZXIociA9PiByLnN0YXR1cyAhPT0gMjAwKTtcblxuICAgICAgZXhwZWN0KHN1Y2Nlc3NSZXNwb25zZXMpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChmYWlsdXJlUmVzcG9uc2VzKS50b0hhdmVMZW5ndGgoMSk7XG5cbiAgICAgIC8vIFZlcmlmeSB1c2VyIGlzIHZlcmlmaWVkIG9ubHkgb25jZVxuICAgICAgY29uc3QgdmVyaWZpZWRVc2VyID0gYXdhaXQgZGJNYW5hZ2VyLmdldFVzZXJCeUlkKHVzZXIuaWQpO1xuICAgICAgZXhwZWN0KHZlcmlmaWVkVXNlci5pc0VtYWlsVmVyaWZpZWQpLnRvQmUodHJ1ZSk7XG5cbiAgICAgIC8vIFZlcmlmeSBjb2RlIHdhcyBkZWxldGVkXG4gICAgICBjb25zdCByZW1haW5pbmdDb2RlcyA9IGF3YWl0IGRiTWFuYWdlci5nZXRFbWFpbENvZGVzQnlVc2VySWQodXNlci5pZCk7XG4gICAgICBleHBlY3QocmVtYWluaW5nQ29kZXMpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNvbmN1cnJlbnQgcmVzZW5kIHJlcXVlc3RzIHNhZmVseScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSB1c2VyXG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RVc2VyKHtcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgICAgIHBhc3N3b3JkSGFzaDogJ2hhc2hlZF9wYXNzd29yZCcsXG4gICAgICAgIGlzRW1haWxWZXJpZmllZDogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgLy8gQ3JlYXRlIG11bHRpcGxlIGNvbmN1cnJlbnQgcmVzZW5kIHJlcXVlc3RzXG4gICAgICBjb25zdCByZXNlbmRSZXF1ZXN0MSA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdC9hcGkvYXV0aC9yZXNlbmQtdmVyaWZpY2F0aW9uJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIH0pLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNlbmRSZXF1ZXN0MiA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdC9hcGkvYXV0aC9yZXNlbmQtdmVyaWZpY2F0aW9uJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIH0pLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBFeGVjdXRlIGNvbmN1cnJlbnQgcmVxdWVzdHNcbiAgICAgIGNvbnN0IFtyZXNwb25zZTEsIHJlc3BvbnNlMl0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIHJlc2VuZFZlcmlmaWNhdGlvbkhhbmRsZXIocmVzZW5kUmVxdWVzdDEpLFxuICAgICAgICByZXNlbmRWZXJpZmljYXRpb25IYW5kbGVyKHJlc2VuZFJlcXVlc3QyKSxcbiAgICAgIF0pO1xuXG4gICAgICAvLyBCb3RoIHNob3VsZCBzdWNjZWVkIChyYXRlIGxpbWl0aW5nIGlzIGhhbmRsZWQgYnkgbWlkZGxld2FyZSlcbiAgICAgIGV4cGVjdChyZXNwb25zZTEuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICBleHBlY3QocmVzcG9uc2UyLnN0YXR1cykudG9CZSgyMDApO1xuXG4gICAgICAvLyBWZXJpZnkgb25seSBvbmUgY29kZSBleGlzdHMgKGxhdGVzdCBvbmUpXG4gICAgICBjb25zdCBlbWFpbENvZGVzID0gYXdhaXQgZGJNYW5hZ2VyLmdldEVtYWlsQ29kZXNCeVVzZXJJZCh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdChlbWFpbENvZGVzKS50b0hhdmVMZW5ndGgoMSk7XG5cbiAgICAgIC8vIFZlcmlmeSBlbWFpbCBzZXJ2aWNlIHdhcyBjYWxsZWQgKHBvc3NpYmx5IG11bHRpcGxlIHRpbWVzIGR1ZSB0byBjb25jdXJyZW5jeSlcbiAgICAgIGV4cGVjdChtb2NrU2VuZEVtYWlsV2l0aFJldHJ5KS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSByYWNlIGNvbmRpdGlvbiBiZXR3ZWVuIHZlcmlmaWNhdGlvbiBhbmQgY29kZSBleHBpcmF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIHVzZXIgd2l0aCBjb2RlIHRoYXQgZXhwaXJlcyB2ZXJ5IHNvb25cbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdFVzZXIoe1xuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAnVGVzdCBVc2VyJyxcbiAgICAgICAgcGFzc3dvcmRIYXNoOiAnaGFzaGVkX3Bhc3N3b3JkJyxcbiAgICAgICAgaXNFbWFpbFZlcmlmaWVkOiBmYWxzZSxcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdEVtYWlsQ29kZSh7XG4gICAgICAgIHVzZXJJZDogdXNlci5pZCxcbiAgICAgICAgY29kZTogJzEyMzQ1NicsXG4gICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIDEwMCksIC8vIEV4cGlyZXMgaW4gMTAwbXNcbiAgICAgICAgYXR0ZW1wdHNVc2VkOiAwLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFdhaXQgZm9yIGNvZGUgdG8gZXhwaXJlXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTUwKSk7XG5cbiAgICAgIC8vIFRyeSB0byB2ZXJpZnkgd2l0aCBleHBpcmVkIGNvZGVcbiAgICAgIGNvbnN0IHZlcmlmeVJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvYXBpL2F1dGgvdmVyaWZ5LWVtYWlsJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgY29kZTogJzEyMzQ1NicsXG4gICAgICAgIH0pLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB2ZXJpZnlSZXNwb25zZSA9IGF3YWl0IHZlcmlmeUVtYWlsSGFuZGxlcih2ZXJpZnlSZXF1ZXN0KTtcbiAgICAgIGNvbnN0IHZlcmlmeURhdGEgPSBhd2FpdCB2ZXJpZnlSZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIC8vIFNob3VsZCBoYW5kbGUgZXhwaXJlZCBjb2RlIGdyYWNlZnVsbHlcbiAgICAgIGV4cGVjdCh2ZXJpZnlSZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAwKTtcbiAgICAgIGV4cGVjdCh2ZXJpZnlEYXRhLmVycm9yKS50b0NvbnRhaW4oJ2V4cGlyZWQnKTtcblxuICAgICAgLy8gVXNlciBzaG91bGQgcmVtYWluIHVudmVyaWZpZWRcbiAgICAgIGNvbnN0IHVudmVyaWZpZWRVc2VyID0gYXdhaXQgZGJNYW5hZ2VyLmdldFVzZXJCeUlkKHVzZXIuaWQpO1xuICAgICAgZXhwZWN0KHVudmVyaWZpZWRVc2VyLmlzRW1haWxWZXJpZmllZCkudG9CZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjb25jdXJyZW50IHNpZ251cCBhdHRlbXB0cyB3aXRoIHNhbWUgZW1haWwnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBDcmVhdGUgY29uY3VycmVudCBzaWdudXAgcmVxdWVzdHMgd2l0aCBzYW1lIGVtYWlsXG4gICAgICBjb25zdCBzaWdudXBSZXF1ZXN0MSA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdC9hcGkvYXV0aC9zaWdudXAnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBwYXNzd29yZDogJ1NlY3VyZVBhc3MxMjMhJyxcbiAgICAgICAgICBuYW1lOiAnVGVzdCBVc2VyIDEnLFxuICAgICAgICB9KSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgc2lnbnVwUmVxdWVzdDIgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvYXBpL2F1dGgvc2lnbnVwJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgcGFzc3dvcmQ6ICdBbm90aGVyUGFzczEyMyEnLFxuICAgICAgICAgIG5hbWU6ICdUZXN0IFVzZXIgMicsXG4gICAgICAgIH0pLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBFeGVjdXRlIGNvbmN1cnJlbnQgcmVxdWVzdHNcbiAgICAgIGNvbnN0IFtyZXNwb25zZTEsIHJlc3BvbnNlMl0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIHNpZ251cEhhbmRsZXIoc2lnbnVwUmVxdWVzdDEpLFxuICAgICAgICBzaWdudXBIYW5kbGVyKHNpZ251cFJlcXVlc3QyKSxcbiAgICAgIF0pO1xuXG4gICAgICBjb25zdCBkYXRhMSA9IGF3YWl0IHJlc3BvbnNlMS5qc29uKCk7XG4gICAgICBjb25zdCBkYXRhMiA9IGF3YWl0IHJlc3BvbnNlMi5qc29uKCk7XG5cbiAgICAgIC8vIE9uZSBzaG91bGQgc3VjY2VlZCwgb25lIHNob3VsZCBmYWlsIHdpdGggZHVwbGljYXRlIGVtYWlsIGVycm9yXG4gICAgICBjb25zdCByZXNwb25zZXMgPSBbXG4gICAgICAgIHsgc3RhdHVzOiByZXNwb25zZTEuc3RhdHVzLCBkYXRhOiBkYXRhMSB9LFxuICAgICAgICB7IHN0YXR1czogcmVzcG9uc2UyLnN0YXR1cywgZGF0YTogZGF0YTIgfSxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IHN1Y2Nlc3NSZXNwb25zZXMgPSByZXNwb25zZXMuZmlsdGVyKHIgPT4gci5zdGF0dXMgPT09IDIwMCk7XG4gICAgICBjb25zdCBjb25mbGljdFJlc3BvbnNlcyA9IHJlc3BvbnNlcy5maWx0ZXIociA9PiByLnN0YXR1cyA9PT0gNDA5KTtcblxuICAgICAgZXhwZWN0KHN1Y2Nlc3NSZXNwb25zZXMpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChjb25mbGljdFJlc3BvbnNlcykudG9IYXZlTGVuZ3RoKDEpO1xuXG4gICAgICAvLyBWZXJpZnkgb25seSBvbmUgdXNlciB3YXMgY3JlYXRlZFxuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGRiTWFuYWdlci5nZXRVc2VyQnlFbWFpbCgndGVzdEBleGFtcGxlLmNvbScpO1xuICAgICAgZXhwZWN0KHVzZXIpLnRvQmVUcnV0aHkoKTtcblxuICAgICAgLy8gVmVyaWZ5IG9ubHkgb25lIHNldCBvZiB2ZXJpZmljYXRpb24gY29kZXMgZXhpc3RzXG4gICAgICBjb25zdCBlbWFpbENvZGVzID0gYXdhaXQgZGJNYW5hZ2VyLmdldEVtYWlsQ29kZXNCeVVzZXJJZCh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdChlbWFpbENvZGVzKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdEYXRhYmFzZSBFcnJvciBTY2VuYXJpb3MnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsdXJlcyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBkYXRhYmFzZSBjb25uZWN0aW9uIGZhaWx1cmVcbiAgICAgIGNvbnN0IG9yaWdpbmFsRGIgPSByZXF1aXJlKCdAL2xpYi9kYicpLmRiO1xuICAgICAgXG4gICAgICAvLyBNb2NrIGRhdGFiYXNlIHRvIHRocm93IGNvbm5lY3Rpb24gZXJyb3JcbiAgICAgIGplc3QuZG9Nb2NrKCdAL2xpYi9kYicsICgpID0+ICh7XG4gICAgICAgIGRiOiB7XG4gICAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZCcpKSxcbiAgICAgICAgICBpbnNlcnQ6IGplc3QuZm4oKS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZmFpbGVkJykpLFxuICAgICAgICAgIHVwZGF0ZTogamVzdC5mbigpLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnKSksXG4gICAgICAgICAgZGVsZXRlOiBqZXN0LmZuKCkubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZCcpKSxcbiAgICAgICAgfSxcbiAgICAgIH0pKTtcblxuICAgICAgY29uc3QgdmVyaWZ5UmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdC9hcGkvYXV0aC92ZXJpZnktZW1haWwnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBjb2RlOiAnMTIzNDU2JyxcbiAgICAgICAgfSksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHZlcmlmeVJlc3BvbnNlID0gYXdhaXQgdmVyaWZ5RW1haWxIYW5kbGVyKHZlcmlmeVJlcXVlc3QpO1xuICAgICAgY29uc3QgdmVyaWZ5RGF0YSA9IGF3YWl0IHZlcmlmeVJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgLy8gU2hvdWxkIGhhbmRsZSBkYXRhYmFzZSBlcnJvciBncmFjZWZ1bGx5XG4gICAgICBleHBlY3QodmVyaWZ5UmVzcG9uc2Uuc3RhdHVzKS50b0JlKDUwMCk7XG4gICAgICBleHBlY3QodmVyaWZ5RGF0YS5lcnJvcikudG9CZSgnSW50ZXJuYWwgc2VydmVyIGVycm9yJyk7XG5cbiAgICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgZGF0YWJhc2VcbiAgICAgIGplc3QuZG9Nb2NrKCdAL2xpYi9kYicsICgpID0+ICh7IGRiOiBvcmlnaW5hbERiIH0pKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHRyYW5zYWN0aW9uIHJvbGxiYWNrIHNjZW5hcmlvcycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFRoaXMgdGVzdCB3b3VsZCByZXF1aXJlIG1vcmUgY29tcGxleCBkYXRhYmFzZSB0cmFuc2FjdGlvbiBtb2NraW5nXG4gICAgICAvLyBGb3Igbm93LCB3ZSdsbCB0ZXN0IHRoYXQgdGhlIHNlcnZpY2UgaGFuZGxlcyBlcnJvcnMgZHVyaW5nIGNvZGUgdmFsaWRhdGlvblxuICAgICAgXG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RVc2VyKHtcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgICAgIHBhc3N3b3JkSGFzaDogJ2hhc2hlZF9wYXNzd29yZCcsXG4gICAgICAgIGlzRW1haWxWZXJpZmllZDogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgLy8gQ3JlYXRlIGNvZGUgd2l0aCBtYXhpbXVtIGF0dGVtcHRzIHJlYWNoZWRcbiAgICAgIGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0RW1haWxDb2RlKHtcbiAgICAgICAgdXNlcklkOiB1c2VyLmlkLFxuICAgICAgICBjb2RlOiAnMTIzNDU2JyxcbiAgICAgICAgZXhwaXJlc0F0OiBuZXcgRGF0ZShEYXRlLm5vdygpICsgNjAwMDAwKSxcbiAgICAgICAgYXR0ZW1wdHNVc2VkOiA1LCAvLyBNYXhpbXVtIGF0dGVtcHRzIHJlYWNoZWRcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB2ZXJpZnlSZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0L2FwaS9hdXRoL3ZlcmlmeS1lbWFpbCcsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIGNvZGU6ICcxMjM0NTYnLFxuICAgICAgICB9KSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdmVyaWZ5UmVzcG9uc2UgPSBhd2FpdCB2ZXJpZnlFbWFpbEhhbmRsZXIodmVyaWZ5UmVxdWVzdCk7XG4gICAgICBjb25zdCB2ZXJpZnlEYXRhID0gYXdhaXQgdmVyaWZ5UmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAvLyBTaG91bGQgaGFuZGxlIHRvbyBtYW55IGF0dGVtcHRzIGVycm9yXG4gICAgICBleHBlY3QodmVyaWZ5UmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQyOSk7XG4gICAgICBleHBlY3QodmVyaWZ5RGF0YS5lcnJvcikudG9Db250YWluKCdUb28gbWFueSB2ZXJpZmljYXRpb24gYXR0ZW1wdHMnKTtcblxuICAgICAgLy8gVXNlciBzaG91bGQgcmVtYWluIHVudmVyaWZpZWRcbiAgICAgIGNvbnN0IHVudmVyaWZpZWRVc2VyID0gYXdhaXQgZGJNYW5hZ2VyLmdldFVzZXJCeUlkKHVzZXIuaWQpO1xuICAgICAgZXhwZWN0KHVudmVyaWZpZWRVc2VyLmlzRW1haWxWZXJpZmllZCkudG9CZShmYWxzZSk7XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwibW9ja0VtYWlsU2VydmljZSIsInNlbmRWZXJpZmljYXRpb25FbWFpbCIsImZuIiwibW9ja0NyZWF0ZUVtYWlsU2VydmljZSIsImNyZWF0ZUVtYWlsU2VydmljZSIsIm1vY2tTZW5kRW1haWxXaXRoUmV0cnkiLCJyZXF1aXJlIiwic2VuZEVtYWlsV2l0aFJldHJ5Iiwib3JpZ2luYWxFbnYiLCJwcm9jZXNzIiwiZW52IiwiYmVmb3JlQWxsIiwiUkVTRU5EX0FQSV9LRVkiLCJGUk9NX0VNQUlMIiwiRlJPTV9OQU1FIiwiVkVSSUZJQ0FUSU9OX0NPREVfRVhQSVJZX01JTlVURVMiLCJNQVhfVkVSSUZJQ0FUSU9OX0FUVEVNUFRTIiwiUkVTRU5EX0NPT0xET1dOX1NFQ09ORFMiLCJNQVhfUkVTRU5EX1BFUl9IT1VSIiwiTk9ERV9FTlYiLCJhZnRlckFsbCIsImRlc2NyaWJlIiwiZGJNYW5hZ2VyIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJjcmVhdGVEYXRhYmFzZVRlc3RNYW5hZ2VyIiwibW9ja1JldHVyblZhbHVlIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJhZnRlckVhY2giLCJjbGVhbnVwIiwiaXQiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsIkVtYWlsU2VydmljZUVycm9yIiwidXNlciIsImNyZWF0ZVRlc3RVc2VyIiwiZW1haWwiLCJuYW1lIiwicGFzc3dvcmRIYXNoIiwiaXNFbWFpbFZlcmlmaWVkIiwidmVyaWZpY2F0aW9uQ29kZSIsImVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UiLCJnZW5lcmF0ZUNvZGUiLCJpZCIsImV4cGVjdCIsInRvTWF0Y2giLCJlbWFpbENvZGVzIiwiZ2V0RW1haWxDb2Rlc0J5VXNlcklkIiwidG9IYXZlTGVuZ3RoIiwiY29kZSIsInRvQmUiLCJ1bnZlcmlmaWVkVXNlciIsImdldFVzZXJCeUlkIiwiY29kZTEiLCJjb2RlMiIsIm5vdCIsImV4cGlyZWRDb2RlIiwiY3JlYXRlVGVzdEVtYWlsQ29kZSIsInVzZXJJZCIsImV4cGlyZXNBdCIsIkRhdGUiLCJub3ciLCJhdHRlbXB0c1VzZWQiLCJ2YWxpZGF0ZUNvZGUiLCJmYWlsIiwiZXJyb3IiLCJjbGVhbnVwRXhwaXJlZENvZGVzIiwicmVtYWluaW5nQ29kZXMiLCJkZWxldGVVc2VyIiwidmVyaWZ5UmVxdWVzdCIsIk5leHRSZXF1ZXN0IiwibWV0aG9kIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJoZWFkZXJzIiwidmVyaWZ5UmVzcG9uc2UiLCJ2ZXJpZnlFbWFpbEhhbmRsZXIiLCJ2ZXJpZnlEYXRhIiwianNvbiIsInN0YXR1cyIsInRvQ29udGFpbiIsInZlcmlmeVJlcXVlc3QxIiwidmVyaWZ5UmVxdWVzdDIiLCJyZXNwb25zZTEiLCJyZXNwb25zZTIiLCJQcm9taXNlIiwiYWxsIiwiZGF0YTEiLCJkYXRhMiIsInJlc3BvbnNlcyIsImRhdGEiLCJzdWNjZXNzUmVzcG9uc2VzIiwiZmlsdGVyIiwiciIsImZhaWx1cmVSZXNwb25zZXMiLCJ2ZXJpZmllZFVzZXIiLCJyZXNlbmRSZXF1ZXN0MSIsInJlc2VuZFJlcXVlc3QyIiwicmVzZW5kVmVyaWZpY2F0aW9uSGFuZGxlciIsInRvSGF2ZUJlZW5DYWxsZWQiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsInNpZ251cFJlcXVlc3QxIiwicGFzc3dvcmQiLCJzaWdudXBSZXF1ZXN0MiIsInNpZ251cEhhbmRsZXIiLCJjb25mbGljdFJlc3BvbnNlcyIsImdldFVzZXJCeUVtYWlsIiwidG9CZVRydXRoeSIsIm9yaWdpbmFsRGIiLCJkYiIsImRvTW9jayIsInNlbGVjdCIsIkVycm9yIiwiaW5zZXJ0IiwidXBkYXRlIiwiZGVsZXRlIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Q0FLQztBQU9ELHlDQUF5QztBQUN6Q0EsS0FBS0MsSUFBSSxDQUFDO0FBQ1ZELEtBQUtDLElBQUksQ0FBQzs7OztxQ0FQZ0M7OENBQ0c7b0NBQ1Y7OEJBQ0Q7QUFNbEMsTUFBTUMsbUJBQW1CO0lBQ3ZCQyx1QkFBdUJILEtBQUtJLEVBQUU7QUFDaEM7QUFFQSxNQUFNQyx5QkFBeUJDLHNDQUFrQjtBQUNqRCxNQUFNQyx5QkFBeUJDLFFBQVEsZ0NBQWdDQyxrQkFBa0I7QUFFekYsNkJBQTZCO0FBQzdCLE1BQU1DLGNBQWNDLFFBQVFDLEdBQUc7QUFFL0JDLFVBQVU7SUFDUkYsUUFBUUMsR0FBRyxHQUFHO1FBQ1osR0FBR0YsV0FBVztRQUNkSSxnQkFBZ0I7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