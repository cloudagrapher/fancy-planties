6adf500d001e8044523bfde3af3d969b
/**
 * Email Verification Flow Integration Tests
 * Tests complete signup and verification process, resend functionality, and rate limiting
 * Requirements: 1.1, 1.4, 2.1, 2.2
 */ "use strict";
// Mock email service
jest.mock('@/lib/services/resend-email-service');
jest.mock('@/lib/services/email-service');
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _databasetestmanager = require("../../test-utils/setup/database-test-manager.js");
const _emailverificationcodeservice = require("../../lib/services/email-verification-code-service");
const _resendemailservice = require("../../lib/services/resend-email-service");
const mockEmailService = {
    sendVerificationEmail: jest.fn()
};
const mockCreateEmailService = _resendemailservice.createEmailService;
const mockSendEmailWithRetry = require('@/lib/services/email-service').sendEmailWithRetry;
// Mock environment variables
const originalEnv = process.env;
beforeAll(()=>{
    process.env = {
        ...originalEnv,
        RESEND_API_KEY: 'test-api-key',
        FROM_EMAIL: 'test@example.com',
        FROM_NAME: 'Test App',
        VERIFICATION_CODE_EXPIRY_MINUTES: '10',
        MAX_VERIFICATION_ATTEMPTS: '5',
        RESEND_COOLDOWN_SECONDS: '60',
        MAX_RESEND_PER_HOUR: '5',
        NODE_ENV: 'test'
    };
});
afterAll(()=>{
    process.env = originalEnv;
});
describe('Email Verification Flow Integration Tests', ()=>{
    let dbManager;
    beforeEach(async ()=>{
        jest.clearAllMocks();
        dbManager = (0, _databasetestmanager.createDatabaseTestManager)();
        // Mock email service to always succeed
        mockCreateEmailService.mockReturnValue(mockEmailService);
        mockSendEmailWithRetry.mockResolvedValue(true);
        mockEmailService.sendVerificationEmail.mockResolvedValue(true);
    });
    afterEach(async ()=>{
        await dbManager.cleanup();
    });
    describe('Complete Signup and Verification Process', ()=>{
        it('should complete full signup and verification workflow', async ()=>{
            // Step 1: Create user and verification code directly
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Step 2: Generate verification code
            const verificationCode = await _emailverificationcodeservice.emailVerificationCodeService.generateCode(user.id);
            expect(verificationCode).toMatch(/^\d{6}$/);
            // Step 3: Verify the code was stored in database
            const emailCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(emailCodes).toHaveLength(1);
            expect(emailCodes[0].code).toBe(verificationCode);
            // Step 4: Validate the verification code
            const isValid = await _emailverificationcodeservice.emailVerificationCodeService.validateCode('test@example.com', verificationCode);
            expect(isValid).toBe(true);
            // Step 5: Verify user is now verified in database
            const verifiedUser = await dbManager.getUserById(user.id);
            expect(verifiedUser.isEmailVerified).toBe(true);
            // Step 6: Verify verification code was deleted
            const remainingCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(remainingCodes).toHaveLength(0);
        });
        it('should handle email service failure gracefully during code generation', async ()=>{
            // Create user
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Generate verification code (this should work even if email fails)
            const verificationCode = await _emailverificationcodeservice.emailVerificationCodeService.generateCode(user.id);
            expect(verificationCode).toMatch(/^\d{6}$/);
            // Verify code was stored in database
            const emailCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(emailCodes).toHaveLength(1);
            expect(emailCodes[0].code).toBe(verificationCode);
            // User should still be unverified
            const unverifiedUser = await dbManager.getUserById(user.id);
            expect(unverifiedUser.isEmailVerified).toBe(false);
        });
        it('should reject verification with invalid code', async ()=>{
            // Create user and verification code
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '123456',
                expiresAt: new Date(Date.now() + 10 * 60 * 1000),
                attemptsUsed: 0
            });
            // Try to verify with wrong code using service directly
            try {
                await _emailverificationcodeservice.emailVerificationCodeService.validateCode('test@example.com', '654321');
                fail('Should have thrown an error for invalid code');
            } catch (error) {
                expect(error.code).toBe('CODE_INVALID');
            }
            // Verify user is still not verified
            const unverifiedUser = await dbManager.getUserById(user.id);
            expect(unverifiedUser.isEmailVerified).toBe(false);
        });
        it('should reject verification with expired code', async ()=>{
            // Create user and expired verification code
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '123456',
                expiresAt: new Date(Date.now() - 1000),
                attemptsUsed: 0
            });
            // Try to verify with expired code using service directly
            try {
                await _emailverificationcodeservice.emailVerificationCodeService.validateCode('test@example.com', '123456');
                fail('Should have thrown an error for expired code');
            } catch (error) {
                expect(error.code).toBe('CODE_EXPIRED');
            }
            // Verify user is still not verified
            const unverifiedUser = await dbManager.getUserById(user.id);
            expect(unverifiedUser.isEmailVerified).toBe(false);
        });
    });
    describe('Resend Verification Code Functionality', ()=>{
        it('should resend verification code by generating new code', async ()=>{
            // Create unverified user
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Create existing verification code
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '123456',
                expiresAt: new Date(Date.now() + 10 * 60 * 1000),
                attemptsUsed: 0
            });
            // Generate new verification code (simulating resend)
            const newCode = await _emailverificationcodeservice.emailVerificationCodeService.generateCode(user.id);
            expect(newCode).toMatch(/^\d{6}$/);
            expect(newCode).not.toBe('123456'); // Should be a new code
            // Verify new code was generated (old one should be invalidated)
            const emailCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(emailCodes).toHaveLength(1);
            expect(emailCodes[0].code).toBe(newCode);
        });
        it('should handle resend for already verified user', async ()=>{
            // Create verified user
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: true
            });
            // Try to generate code for already verified user
            try {
                await _emailverificationcodeservice.emailVerificationCodeService.generateCode(user.id);
                fail('Should have thrown an error for already verified user');
            } catch (error) {
                expect(error.code).toBe('ALREADY_VERIFIED');
            }
        });
        it('should handle resend for non-existent user', async ()=>{
            // Try to validate code for non-existent user
            try {
                await _emailverificationcodeservice.emailVerificationCodeService.validateCode('nonexistent@example.com', '123456');
                fail('Should have thrown an error for non-existent user');
            } catch (error) {
                expect(error.code).toBe('USER_NOT_FOUND');
            }
        });
    });
    describe('Rate Limiting Enforcement', ()=>{
        it('should enforce verification attempt limits', async ()=>{
            // Create user and verification code
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            const emailCode = await dbManager.createTestEmailCode({
                userId: user.id,
                code: '123456',
                expiresAt: new Date(Date.now() + 10 * 60 * 1000),
                attemptsUsed: 5
            });
            // Try to verify with max attempts reached
            try {
                await _emailverificationcodeservice.emailVerificationCodeService.validateCode('test@example.com', '123456');
                fail('Should have thrown an error for too many attempts');
            } catch (error) {
                expect(error.code).toBe('TOO_MANY_ATTEMPTS');
            }
            // Verify user is still not verified
            const unverifiedUser = await dbManager.getUserById(user.id);
            expect(unverifiedUser.isEmailVerified).toBe(false);
        });
        it('should handle validation at service level', async ()=>{
            // Create user for testing
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Generate valid code
            const validCode = await _emailverificationcodeservice.emailVerificationCodeService.generateCode(user.id);
            expect(validCode).toMatch(/^\d{6}$/);
            // Test that service validates codes properly
            const isValid = await _emailverificationcodeservice.emailVerificationCodeService.validateCode('test@example.com', validCode);
            expect(isValid).toBe(true);
            // Verify user is now verified
            const verifiedUser = await dbManager.getUserById(user.id);
            expect(verifiedUser.isEmailVerified).toBe(true);
        });
    });
    describe('Edge Cases and Error Scenarios', ()=>{
        it('should handle duplicate signup attempts', async ()=>{
            // First signup
            const signupRequest1 = new NextRequest('http://localhost/api/auth/signup', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'SecurePass123!',
                    name: 'Test User'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            const signupResponse1 = await signupHandler(signupRequest1);
            expect(signupResponse1.status).toBe(200);
            // Second signup with same email
            const signupRequest2 = new NextRequest('http://localhost/api/auth/signup', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'AnotherPass123!',
                    name: 'Another User'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            const signupResponse2 = await signupHandler(signupRequest2);
            const signupData2 = await signupResponse2.json();
            // Assert duplicate email error
            expect(signupResponse2.status).toBe(409);
            expect(signupData2.error).toContain('already exists');
        });
        it('should handle malformed request bodies', async ()=>{
            // Test with invalid JSON
            const verifyRequest = new NextRequest('http://localhost/api/auth/verify-email', {
                method: 'POST',
                body: 'invalid json',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            const verifyResponse = await verifyEmailHandler(verifyRequest);
            const verifyData = await verifyResponse.json();
            expect(verifyResponse.status).toBe(500);
            expect(verifyData.error).toBe('Internal server error');
        });
        it('should handle missing request body fields', async ()=>{
            // Test with missing email
            const verifyRequest1 = new NextRequest('http://localhost/api/auth/verify-email', {
                method: 'POST',
                body: JSON.stringify({
                    code: '123456'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            const verifyResponse1 = await verifyEmailHandler(verifyRequest1);
            const verifyData1 = await verifyResponse1.json();
            expect(verifyResponse1.status).toBe(400);
            expect(verifyData1.error).toBe('Validation failed');
            // Test with missing code
            const verifyRequest2 = new NextRequest('http://localhost/api/auth/verify-email', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            const verifyResponse2 = await verifyEmailHandler(verifyRequest2);
            const verifyData2 = await verifyResponse2.json();
            expect(verifyResponse2.status).toBe(400);
            expect(verifyData2.error).toBe('Validation failed');
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdGVmYW5iZWtrZXIvcHJvamVjdHMvZmFuY3ktcGxhbnRpZXMvc3JjL19fdGVzdHNfXy9pbnRlZ3JhdGlvbi9lbWFpbC12ZXJpZmljYXRpb24tZmxvdy50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRW1haWwgVmVyaWZpY2F0aW9uIEZsb3cgSW50ZWdyYXRpb24gVGVzdHNcbiAqIFRlc3RzIGNvbXBsZXRlIHNpZ251cCBhbmQgdmVyaWZpY2F0aW9uIHByb2Nlc3MsIHJlc2VuZCBmdW5jdGlvbmFsaXR5LCBhbmQgcmF0ZSBsaW1pdGluZ1xuICogUmVxdWlyZW1lbnRzOiAxLjEsIDEuNCwgMi4xLCAyLjJcbiAqL1xuXG5pbXBvcnQgeyBjcmVhdGVEYXRhYmFzZVRlc3RNYW5hZ2VyIH0gZnJvbSAnQC90ZXN0LXV0aWxzL3NldHVwL2RhdGFiYXNlLXRlc3QtbWFuYWdlcic7XG5pbXBvcnQgeyBjcmVhdGVUZXN0VXNlciB9IGZyb20gJ0AvdGVzdC11dGlscy9mYWN0b3JpZXMvdXNlci1mYWN0b3J5JztcbmltcG9ydCB7IGVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UgfSBmcm9tICdAL2xpYi9zZXJ2aWNlcy9lbWFpbC12ZXJpZmljYXRpb24tY29kZS1zZXJ2aWNlJztcbmltcG9ydCB7IGNyZWF0ZUVtYWlsU2VydmljZSB9IGZyb20gJ0AvbGliL3NlcnZpY2VzL3Jlc2VuZC1lbWFpbC1zZXJ2aWNlJztcblxuLy8gTW9jayBlbWFpbCBzZXJ2aWNlXG5qZXN0Lm1vY2soJ0AvbGliL3NlcnZpY2VzL3Jlc2VuZC1lbWFpbC1zZXJ2aWNlJyk7XG5qZXN0Lm1vY2soJ0AvbGliL3NlcnZpY2VzL2VtYWlsLXNlcnZpY2UnKTtcblxuY29uc3QgbW9ja0VtYWlsU2VydmljZSA9IHtcbiAgc2VuZFZlcmlmaWNhdGlvbkVtYWlsOiBqZXN0LmZuKCksXG59O1xuXG5jb25zdCBtb2NrQ3JlYXRlRW1haWxTZXJ2aWNlID0gY3JlYXRlRW1haWxTZXJ2aWNlIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248dHlwZW9mIGNyZWF0ZUVtYWlsU2VydmljZT47XG5jb25zdCBtb2NrU2VuZEVtYWlsV2l0aFJldHJ5ID0gcmVxdWlyZSgnQC9saWIvc2VydmljZXMvZW1haWwtc2VydmljZScpLnNlbmRFbWFpbFdpdGhSZXRyeSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT47XG5cbi8vIE1vY2sgZW52aXJvbm1lbnQgdmFyaWFibGVzXG5jb25zdCBvcmlnaW5hbEVudiA9IHByb2Nlc3MuZW52O1xuXG5iZWZvcmVBbGwoKCkgPT4ge1xuICBwcm9jZXNzLmVudiA9IHtcbiAgICAuLi5vcmlnaW5hbEVudixcbiAgICBSRVNFTkRfQVBJX0tFWTogJ3Rlc3QtYXBpLWtleScsXG4gICAgRlJPTV9FTUFJTDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgIEZST01fTkFNRTogJ1Rlc3QgQXBwJyxcbiAgICBWRVJJRklDQVRJT05fQ09ERV9FWFBJUllfTUlOVVRFUzogJzEwJyxcbiAgICBNQVhfVkVSSUZJQ0FUSU9OX0FUVEVNUFRTOiAnNScsXG4gICAgUkVTRU5EX0NPT0xET1dOX1NFQ09ORFM6ICc2MCcsXG4gICAgTUFYX1JFU0VORF9QRVJfSE9VUjogJzUnLFxuICAgIE5PREVfRU5WOiAndGVzdCcsXG4gIH07XG59KTtcblxuYWZ0ZXJBbGwoKCkgPT4ge1xuICBwcm9jZXNzLmVudiA9IG9yaWdpbmFsRW52O1xufSk7XG5cbmRlc2NyaWJlKCdFbWFpbCBWZXJpZmljYXRpb24gRmxvdyBJbnRlZ3JhdGlvbiBUZXN0cycsICgpID0+IHtcbiAgbGV0IGRiTWFuYWdlcjogYW55O1xuXG4gIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIGRiTWFuYWdlciA9IGNyZWF0ZURhdGFiYXNlVGVzdE1hbmFnZXIoKTtcbiAgICBcbiAgICAvLyBNb2NrIGVtYWlsIHNlcnZpY2UgdG8gYWx3YXlzIHN1Y2NlZWRcbiAgICBtb2NrQ3JlYXRlRW1haWxTZXJ2aWNlLm1vY2tSZXR1cm5WYWx1ZShtb2NrRW1haWxTZXJ2aWNlKTtcbiAgICBtb2NrU2VuZEVtYWlsV2l0aFJldHJ5Lm1vY2tSZXNvbHZlZFZhbHVlKHRydWUpO1xuICAgIG1vY2tFbWFpbFNlcnZpY2Uuc2VuZFZlcmlmaWNhdGlvbkVtYWlsLm1vY2tSZXNvbHZlZFZhbHVlKHRydWUpO1xuICB9KTtcblxuICBhZnRlckVhY2goYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGRiTWFuYWdlci5jbGVhbnVwKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDb21wbGV0ZSBTaWdudXAgYW5kIFZlcmlmaWNhdGlvbiBQcm9jZXNzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgY29tcGxldGUgZnVsbCBzaWdudXAgYW5kIHZlcmlmaWNhdGlvbiB3b3JrZmxvdycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFN0ZXAgMTogQ3JlYXRlIHVzZXIgYW5kIHZlcmlmaWNhdGlvbiBjb2RlIGRpcmVjdGx5XG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RVc2VyKHtcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgICAgIHBhc3N3b3JkSGFzaDogJ2hhc2hlZF9wYXNzd29yZCcsXG4gICAgICAgIGlzRW1haWxWZXJpZmllZDogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgLy8gU3RlcCAyOiBHZW5lcmF0ZSB2ZXJpZmljYXRpb24gY29kZVxuICAgICAgY29uc3QgdmVyaWZpY2F0aW9uQ29kZSA9IGF3YWl0IGVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UuZ2VuZXJhdGVDb2RlKHVzZXIuaWQpO1xuICAgICAgZXhwZWN0KHZlcmlmaWNhdGlvbkNvZGUpLnRvTWF0Y2goL15cXGR7Nn0kLyk7XG5cbiAgICAgIC8vIFN0ZXAgMzogVmVyaWZ5IHRoZSBjb2RlIHdhcyBzdG9yZWQgaW4gZGF0YWJhc2VcbiAgICAgIGNvbnN0IGVtYWlsQ29kZXMgPSBhd2FpdCBkYk1hbmFnZXIuZ2V0RW1haWxDb2Rlc0J5VXNlcklkKHVzZXIuaWQpO1xuICAgICAgZXhwZWN0KGVtYWlsQ29kZXMpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChlbWFpbENvZGVzWzBdLmNvZGUpLnRvQmUodmVyaWZpY2F0aW9uQ29kZSk7XG5cbiAgICAgIC8vIFN0ZXAgNDogVmFsaWRhdGUgdGhlIHZlcmlmaWNhdGlvbiBjb2RlXG4gICAgICBjb25zdCBpc1ZhbGlkID0gYXdhaXQgZW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS52YWxpZGF0ZUNvZGUoJ3Rlc3RAZXhhbXBsZS5jb20nLCB2ZXJpZmljYXRpb25Db2RlKTtcbiAgICAgIGV4cGVjdChpc1ZhbGlkKS50b0JlKHRydWUpO1xuXG4gICAgICAvLyBTdGVwIDU6IFZlcmlmeSB1c2VyIGlzIG5vdyB2ZXJpZmllZCBpbiBkYXRhYmFzZVxuICAgICAgY29uc3QgdmVyaWZpZWRVc2VyID0gYXdhaXQgZGJNYW5hZ2VyLmdldFVzZXJCeUlkKHVzZXIuaWQpO1xuICAgICAgZXhwZWN0KHZlcmlmaWVkVXNlci5pc0VtYWlsVmVyaWZpZWQpLnRvQmUodHJ1ZSk7XG5cbiAgICAgIC8vIFN0ZXAgNjogVmVyaWZ5IHZlcmlmaWNhdGlvbiBjb2RlIHdhcyBkZWxldGVkXG4gICAgICBjb25zdCByZW1haW5pbmdDb2RlcyA9IGF3YWl0IGRiTWFuYWdlci5nZXRFbWFpbENvZGVzQnlVc2VySWQodXNlci5pZCk7XG4gICAgICBleHBlY3QocmVtYWluaW5nQ29kZXMpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGVtYWlsIHNlcnZpY2UgZmFpbHVyZSBncmFjZWZ1bGx5IGR1cmluZyBjb2RlIGdlbmVyYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBDcmVhdGUgdXNlclxuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0VXNlcih7XG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgICBwYXNzd29yZEhhc2g6ICdoYXNoZWRfcGFzc3dvcmQnLFxuICAgICAgICBpc0VtYWlsVmVyaWZpZWQ6IGZhbHNlLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIEdlbmVyYXRlIHZlcmlmaWNhdGlvbiBjb2RlICh0aGlzIHNob3VsZCB3b3JrIGV2ZW4gaWYgZW1haWwgZmFpbHMpXG4gICAgICBjb25zdCB2ZXJpZmljYXRpb25Db2RlID0gYXdhaXQgZW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS5nZW5lcmF0ZUNvZGUodXNlci5pZCk7XG4gICAgICBleHBlY3QodmVyaWZpY2F0aW9uQ29kZSkudG9NYXRjaCgvXlxcZHs2fSQvKTtcblxuICAgICAgLy8gVmVyaWZ5IGNvZGUgd2FzIHN0b3JlZCBpbiBkYXRhYmFzZVxuICAgICAgY29uc3QgZW1haWxDb2RlcyA9IGF3YWl0IGRiTWFuYWdlci5nZXRFbWFpbENvZGVzQnlVc2VySWQodXNlci5pZCk7XG4gICAgICBleHBlY3QoZW1haWxDb2RlcykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KGVtYWlsQ29kZXNbMF0uY29kZSkudG9CZSh2ZXJpZmljYXRpb25Db2RlKTtcblxuICAgICAgLy8gVXNlciBzaG91bGQgc3RpbGwgYmUgdW52ZXJpZmllZFxuICAgICAgY29uc3QgdW52ZXJpZmllZFVzZXIgPSBhd2FpdCBkYk1hbmFnZXIuZ2V0VXNlckJ5SWQodXNlci5pZCk7XG4gICAgICBleHBlY3QodW52ZXJpZmllZFVzZXIuaXNFbWFpbFZlcmlmaWVkKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IHZlcmlmaWNhdGlvbiB3aXRoIGludmFsaWQgY29kZScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSB1c2VyIGFuZCB2ZXJpZmljYXRpb24gY29kZVxuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0VXNlcih7XG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgICBwYXNzd29yZEhhc2g6ICdoYXNoZWRfcGFzc3dvcmQnLFxuICAgICAgICBpc0VtYWlsVmVyaWZpZWQ6IGZhbHNlLFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0RW1haWxDb2RlKHtcbiAgICAgICAgdXNlcklkOiB1c2VyLmlkLFxuICAgICAgICBjb2RlOiAnMTIzNDU2JyxcbiAgICAgICAgZXhwaXJlc0F0OiBuZXcgRGF0ZShEYXRlLm5vdygpICsgMTAgKiA2MCAqIDEwMDApLCAvLyAxMCBtaW51dGVzIGZyb20gbm93XG4gICAgICAgIGF0dGVtcHRzVXNlZDogMCxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBUcnkgdG8gdmVyaWZ5IHdpdGggd3JvbmcgY29kZSB1c2luZyBzZXJ2aWNlIGRpcmVjdGx5XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlLnZhbGlkYXRlQ29kZSgndGVzdEBleGFtcGxlLmNvbScsICc2NTQzMjEnKTtcbiAgICAgICAgZmFpbCgnU2hvdWxkIGhhdmUgdGhyb3duIGFuIGVycm9yIGZvciBpbnZhbGlkIGNvZGUnKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgZXhwZWN0KGVycm9yLmNvZGUpLnRvQmUoJ0NPREVfSU5WQUxJRCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBWZXJpZnkgdXNlciBpcyBzdGlsbCBub3QgdmVyaWZpZWRcbiAgICAgIGNvbnN0IHVudmVyaWZpZWRVc2VyID0gYXdhaXQgZGJNYW5hZ2VyLmdldFVzZXJCeUlkKHVzZXIuaWQpO1xuICAgICAgZXhwZWN0KHVudmVyaWZpZWRVc2VyLmlzRW1haWxWZXJpZmllZCkudG9CZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2ZXJpZmljYXRpb24gd2l0aCBleHBpcmVkIGNvZGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBDcmVhdGUgdXNlciBhbmQgZXhwaXJlZCB2ZXJpZmljYXRpb24gY29kZVxuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0VXNlcih7XG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgICBwYXNzd29yZEhhc2g6ICdoYXNoZWRfcGFzc3dvcmQnLFxuICAgICAgICBpc0VtYWlsVmVyaWZpZWQ6IGZhbHNlLFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0RW1haWxDb2RlKHtcbiAgICAgICAgdXNlcklkOiB1c2VyLmlkLFxuICAgICAgICBjb2RlOiAnMTIzNDU2JyxcbiAgICAgICAgZXhwaXJlc0F0OiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gMTAwMCksIC8vIEV4cGlyZWQgMSBzZWNvbmQgYWdvXG4gICAgICAgIGF0dGVtcHRzVXNlZDogMCxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBUcnkgdG8gdmVyaWZ5IHdpdGggZXhwaXJlZCBjb2RlIHVzaW5nIHNlcnZpY2UgZGlyZWN0bHlcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UudmFsaWRhdGVDb2RlKCd0ZXN0QGV4YW1wbGUuY29tJywgJzEyMzQ1NicpO1xuICAgICAgICBmYWlsKCdTaG91bGQgaGF2ZSB0aHJvd24gYW4gZXJyb3IgZm9yIGV4cGlyZWQgY29kZScpO1xuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBleHBlY3QoZXJyb3IuY29kZSkudG9CZSgnQ09ERV9FWFBJUkVEJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFZlcmlmeSB1c2VyIGlzIHN0aWxsIG5vdCB2ZXJpZmllZFxuICAgICAgY29uc3QgdW52ZXJpZmllZFVzZXIgPSBhd2FpdCBkYk1hbmFnZXIuZ2V0VXNlckJ5SWQodXNlci5pZCk7XG4gICAgICBleHBlY3QodW52ZXJpZmllZFVzZXIuaXNFbWFpbFZlcmlmaWVkKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1Jlc2VuZCBWZXJpZmljYXRpb24gQ29kZSBGdW5jdGlvbmFsaXR5JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmVzZW5kIHZlcmlmaWNhdGlvbiBjb2RlIGJ5IGdlbmVyYXRpbmcgbmV3IGNvZGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBDcmVhdGUgdW52ZXJpZmllZCB1c2VyXG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RVc2VyKHtcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgICAgIHBhc3N3b3JkSGFzaDogJ2hhc2hlZF9wYXNzd29yZCcsXG4gICAgICAgIGlzRW1haWxWZXJpZmllZDogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgLy8gQ3JlYXRlIGV4aXN0aW5nIHZlcmlmaWNhdGlvbiBjb2RlXG4gICAgICBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdEVtYWlsQ29kZSh7XG4gICAgICAgIHVzZXJJZDogdXNlci5pZCxcbiAgICAgICAgY29kZTogJzEyMzQ1NicsXG4gICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIDEwICogNjAgKiAxMDAwKSxcbiAgICAgICAgYXR0ZW1wdHNVc2VkOiAwLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIEdlbmVyYXRlIG5ldyB2ZXJpZmljYXRpb24gY29kZSAoc2ltdWxhdGluZyByZXNlbmQpXG4gICAgICBjb25zdCBuZXdDb2RlID0gYXdhaXQgZW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS5nZW5lcmF0ZUNvZGUodXNlci5pZCk7XG4gICAgICBleHBlY3QobmV3Q29kZSkudG9NYXRjaCgvXlxcZHs2fSQvKTtcbiAgICAgIGV4cGVjdChuZXdDb2RlKS5ub3QudG9CZSgnMTIzNDU2Jyk7IC8vIFNob3VsZCBiZSBhIG5ldyBjb2RlXG5cbiAgICAgIC8vIFZlcmlmeSBuZXcgY29kZSB3YXMgZ2VuZXJhdGVkIChvbGQgb25lIHNob3VsZCBiZSBpbnZhbGlkYXRlZClcbiAgICAgIGNvbnN0IGVtYWlsQ29kZXMgPSBhd2FpdCBkYk1hbmFnZXIuZ2V0RW1haWxDb2Rlc0J5VXNlcklkKHVzZXIuaWQpO1xuICAgICAgZXhwZWN0KGVtYWlsQ29kZXMpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChlbWFpbENvZGVzWzBdLmNvZGUpLnRvQmUobmV3Q29kZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSByZXNlbmQgZm9yIGFscmVhZHkgdmVyaWZpZWQgdXNlcicsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSB2ZXJpZmllZCB1c2VyXG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RVc2VyKHtcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgICAgIHBhc3N3b3JkSGFzaDogJ2hhc2hlZF9wYXNzd29yZCcsXG4gICAgICAgIGlzRW1haWxWZXJpZmllZDogdHJ1ZSwgLy8gQWxyZWFkeSB2ZXJpZmllZFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFRyeSB0byBnZW5lcmF0ZSBjb2RlIGZvciBhbHJlYWR5IHZlcmlmaWVkIHVzZXJcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UuZ2VuZXJhdGVDb2RlKHVzZXIuaWQpO1xuICAgICAgICBmYWlsKCdTaG91bGQgaGF2ZSB0aHJvd24gYW4gZXJyb3IgZm9yIGFscmVhZHkgdmVyaWZpZWQgdXNlcicpO1xuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBleHBlY3QoZXJyb3IuY29kZSkudG9CZSgnQUxSRUFEWV9WRVJJRklFRCcpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgcmVzZW5kIGZvciBub24tZXhpc3RlbnQgdXNlcicsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFRyeSB0byB2YWxpZGF0ZSBjb2RlIGZvciBub24tZXhpc3RlbnQgdXNlclxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS52YWxpZGF0ZUNvZGUoJ25vbmV4aXN0ZW50QGV4YW1wbGUuY29tJywgJzEyMzQ1NicpO1xuICAgICAgICBmYWlsKCdTaG91bGQgaGF2ZSB0aHJvd24gYW4gZXJyb3IgZm9yIG5vbi1leGlzdGVudCB1c2VyJyk7XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIGV4cGVjdChlcnJvci5jb2RlKS50b0JlKCdVU0VSX05PVF9GT1VORCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUmF0ZSBMaW1pdGluZyBFbmZvcmNlbWVudCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGVuZm9yY2UgdmVyaWZpY2F0aW9uIGF0dGVtcHQgbGltaXRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIHVzZXIgYW5kIHZlcmlmaWNhdGlvbiBjb2RlXG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RVc2VyKHtcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgICAgIHBhc3N3b3JkSGFzaDogJ2hhc2hlZF9wYXNzd29yZCcsXG4gICAgICAgIGlzRW1haWxWZXJpZmllZDogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZW1haWxDb2RlID0gYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RFbWFpbENvZGUoe1xuICAgICAgICB1c2VySWQ6IHVzZXIuaWQsXG4gICAgICAgIGNvZGU6ICcxMjM0NTYnLFxuICAgICAgICBleHBpcmVzQXQ6IG5ldyBEYXRlKERhdGUubm93KCkgKyAxMCAqIDYwICogMTAwMCksXG4gICAgICAgIGF0dGVtcHRzVXNlZDogNSwgLy8gQWxyZWFkeSBhdCBtYXggYXR0ZW1wdHMgKGxpbWl0IGlzIDUpXG4gICAgICB9KTtcblxuICAgICAgLy8gVHJ5IHRvIHZlcmlmeSB3aXRoIG1heCBhdHRlbXB0cyByZWFjaGVkXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlLnZhbGlkYXRlQ29kZSgndGVzdEBleGFtcGxlLmNvbScsICcxMjM0NTYnKTtcbiAgICAgICAgZmFpbCgnU2hvdWxkIGhhdmUgdGhyb3duIGFuIGVycm9yIGZvciB0b28gbWFueSBhdHRlbXB0cycpO1xuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBleHBlY3QoZXJyb3IuY29kZSkudG9CZSgnVE9PX01BTllfQVRURU1QVFMnKTtcbiAgICAgIH1cblxuICAgICAgLy8gVmVyaWZ5IHVzZXIgaXMgc3RpbGwgbm90IHZlcmlmaWVkXG4gICAgICBjb25zdCB1bnZlcmlmaWVkVXNlciA9IGF3YWl0IGRiTWFuYWdlci5nZXRVc2VyQnlJZCh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdCh1bnZlcmlmaWVkVXNlci5pc0VtYWlsVmVyaWZpZWQpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgdmFsaWRhdGlvbiBhdCBzZXJ2aWNlIGxldmVsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIHVzZXIgZm9yIHRlc3RpbmdcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdFVzZXIoe1xuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAnVGVzdCBVc2VyJyxcbiAgICAgICAgcGFzc3dvcmRIYXNoOiAnaGFzaGVkX3Bhc3N3b3JkJyxcbiAgICAgICAgaXNFbWFpbFZlcmlmaWVkOiBmYWxzZSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBHZW5lcmF0ZSB2YWxpZCBjb2RlXG4gICAgICBjb25zdCB2YWxpZENvZGUgPSBhd2FpdCBlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlLmdlbmVyYXRlQ29kZSh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdCh2YWxpZENvZGUpLnRvTWF0Y2goL15cXGR7Nn0kLyk7XG5cbiAgICAgIC8vIFRlc3QgdGhhdCBzZXJ2aWNlIHZhbGlkYXRlcyBjb2RlcyBwcm9wZXJseVxuICAgICAgY29uc3QgaXNWYWxpZCA9IGF3YWl0IGVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UudmFsaWRhdGVDb2RlKCd0ZXN0QGV4YW1wbGUuY29tJywgdmFsaWRDb2RlKTtcbiAgICAgIGV4cGVjdChpc1ZhbGlkKS50b0JlKHRydWUpO1xuXG4gICAgICAvLyBWZXJpZnkgdXNlciBpcyBub3cgdmVyaWZpZWRcbiAgICAgIGNvbnN0IHZlcmlmaWVkVXNlciA9IGF3YWl0IGRiTWFuYWdlci5nZXRVc2VyQnlJZCh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdCh2ZXJpZmllZFVzZXIuaXNFbWFpbFZlcmlmaWVkKS50b0JlKHRydWUpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRWRnZSBDYXNlcyBhbmQgRXJyb3IgU2NlbmFyaW9zJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIGR1cGxpY2F0ZSBzaWdudXAgYXR0ZW1wdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBGaXJzdCBzaWdudXBcbiAgICAgIGNvbnN0IHNpZ251cFJlcXVlc3QxID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0L2FwaS9hdXRoL3NpZ251cCcsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIHBhc3N3b3JkOiAnU2VjdXJlUGFzczEyMyEnLFxuICAgICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgICB9KSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgc2lnbnVwUmVzcG9uc2UxID0gYXdhaXQgc2lnbnVwSGFuZGxlcihzaWdudXBSZXF1ZXN0MSk7XG4gICAgICBleHBlY3Qoc2lnbnVwUmVzcG9uc2UxLnN0YXR1cykudG9CZSgyMDApO1xuXG4gICAgICAvLyBTZWNvbmQgc2lnbnVwIHdpdGggc2FtZSBlbWFpbFxuICAgICAgY29uc3Qgc2lnbnVwUmVxdWVzdDIgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvYXBpL2F1dGgvc2lnbnVwJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgcGFzc3dvcmQ6ICdBbm90aGVyUGFzczEyMyEnLFxuICAgICAgICAgIG5hbWU6ICdBbm90aGVyIFVzZXInLFxuICAgICAgICB9KSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgc2lnbnVwUmVzcG9uc2UyID0gYXdhaXQgc2lnbnVwSGFuZGxlcihzaWdudXBSZXF1ZXN0Mik7XG4gICAgICBjb25zdCBzaWdudXBEYXRhMiA9IGF3YWl0IHNpZ251cFJlc3BvbnNlMi5qc29uKCk7XG5cbiAgICAgIC8vIEFzc2VydCBkdXBsaWNhdGUgZW1haWwgZXJyb3JcbiAgICAgIGV4cGVjdChzaWdudXBSZXNwb25zZTIuc3RhdHVzKS50b0JlKDQwOSk7XG4gICAgICBleHBlY3Qoc2lnbnVwRGF0YTIuZXJyb3IpLnRvQ29udGFpbignYWxyZWFkeSBleGlzdHMnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIG1hbGZvcm1lZCByZXF1ZXN0IGJvZGllcycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFRlc3Qgd2l0aCBpbnZhbGlkIEpTT05cbiAgICAgIGNvbnN0IHZlcmlmeVJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvYXBpL2F1dGgvdmVyaWZ5LWVtYWlsJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogJ2ludmFsaWQganNvbicsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHZlcmlmeVJlc3BvbnNlID0gYXdhaXQgdmVyaWZ5RW1haWxIYW5kbGVyKHZlcmlmeVJlcXVlc3QpO1xuICAgICAgY29uc3QgdmVyaWZ5RGF0YSA9IGF3YWl0IHZlcmlmeVJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgZXhwZWN0KHZlcmlmeVJlc3BvbnNlLnN0YXR1cykudG9CZSg1MDApO1xuICAgICAgZXhwZWN0KHZlcmlmeURhdGEuZXJyb3IpLnRvQmUoJ0ludGVybmFsIHNlcnZlciBlcnJvcicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbWlzc2luZyByZXF1ZXN0IGJvZHkgZmllbGRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gVGVzdCB3aXRoIG1pc3NpbmcgZW1haWxcbiAgICAgIGNvbnN0IHZlcmlmeVJlcXVlc3QxID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0L2FwaS9hdXRoL3ZlcmlmeS1lbWFpbCcsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBjb2RlOiAnMTIzNDU2JyxcbiAgICAgICAgfSksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHZlcmlmeVJlc3BvbnNlMSA9IGF3YWl0IHZlcmlmeUVtYWlsSGFuZGxlcih2ZXJpZnlSZXF1ZXN0MSk7XG4gICAgICBjb25zdCB2ZXJpZnlEYXRhMSA9IGF3YWl0IHZlcmlmeVJlc3BvbnNlMS5qc29uKCk7XG5cbiAgICAgIGV4cGVjdCh2ZXJpZnlSZXNwb25zZTEuc3RhdHVzKS50b0JlKDQwMCk7XG4gICAgICBleHBlY3QodmVyaWZ5RGF0YTEuZXJyb3IpLnRvQmUoJ1ZhbGlkYXRpb24gZmFpbGVkJyk7XG5cbiAgICAgIC8vIFRlc3Qgd2l0aCBtaXNzaW5nIGNvZGVcbiAgICAgIGNvbnN0IHZlcmlmeVJlcXVlc3QyID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0L2FwaS9hdXRoL3ZlcmlmeS1lbWFpbCcsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICB9KSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdmVyaWZ5UmVzcG9uc2UyID0gYXdhaXQgdmVyaWZ5RW1haWxIYW5kbGVyKHZlcmlmeVJlcXVlc3QyKTtcbiAgICAgIGNvbnN0IHZlcmlmeURhdGEyID0gYXdhaXQgdmVyaWZ5UmVzcG9uc2UyLmpzb24oKTtcblxuICAgICAgZXhwZWN0KHZlcmlmeVJlc3BvbnNlMi5zdGF0dXMpLnRvQmUoNDAwKTtcbiAgICAgIGV4cGVjdCh2ZXJpZnlEYXRhMi5lcnJvcikudG9CZSgnVmFsaWRhdGlvbiBmYWlsZWQnKTtcbiAgICB9KTtcbiAgfSk7XG59KTsiXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJtb2NrRW1haWxTZXJ2aWNlIiwic2VuZFZlcmlmaWNhdGlvbkVtYWlsIiwiZm4iLCJtb2NrQ3JlYXRlRW1haWxTZXJ2aWNlIiwiY3JlYXRlRW1haWxTZXJ2aWNlIiwibW9ja1NlbmRFbWFpbFdpdGhSZXRyeSIsInJlcXVpcmUiLCJzZW5kRW1haWxXaXRoUmV0cnkiLCJvcmlnaW5hbEVudiIsInByb2Nlc3MiLCJlbnYiLCJiZWZvcmVBbGwiLCJSRVNFTkRfQVBJX0tFWSIsIkZST01fRU1BSUwiLCJGUk9NX05BTUUiLCJWRVJJRklDQVRJT05fQ09ERV9FWFBJUllfTUlOVVRFUyIsIk1BWF9WRVJJRklDQVRJT05fQVRURU1QVFMiLCJSRVNFTkRfQ09PTERPV05fU0VDT05EUyIsIk1BWF9SRVNFTkRfUEVSX0hPVVIiLCJOT0RFX0VOViIsImFmdGVyQWxsIiwiZGVzY3JpYmUiLCJkYk1hbmFnZXIiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsImNyZWF0ZURhdGFiYXNlVGVzdE1hbmFnZXIiLCJtb2NrUmV0dXJuVmFsdWUiLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsImFmdGVyRWFjaCIsImNsZWFudXAiLCJpdCIsInVzZXIiLCJjcmVhdGVUZXN0VXNlciIsImVtYWlsIiwibmFtZSIsInBhc3N3b3JkSGFzaCIsImlzRW1haWxWZXJpZmllZCIsInZlcmlmaWNhdGlvbkNvZGUiLCJlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlIiwiZ2VuZXJhdGVDb2RlIiwiaWQiLCJleHBlY3QiLCJ0b01hdGNoIiwiZW1haWxDb2RlcyIsImdldEVtYWlsQ29kZXNCeVVzZXJJZCIsInRvSGF2ZUxlbmd0aCIsImNvZGUiLCJ0b0JlIiwiaXNWYWxpZCIsInZhbGlkYXRlQ29kZSIsInZlcmlmaWVkVXNlciIsImdldFVzZXJCeUlkIiwicmVtYWluaW5nQ29kZXMiLCJ1bnZlcmlmaWVkVXNlciIsImNyZWF0ZVRlc3RFbWFpbENvZGUiLCJ1c2VySWQiLCJleHBpcmVzQXQiLCJEYXRlIiwibm93IiwiYXR0ZW1wdHNVc2VkIiwiZmFpbCIsImVycm9yIiwibmV3Q29kZSIsIm5vdCIsImVtYWlsQ29kZSIsInZhbGlkQ29kZSIsInNpZ251cFJlcXVlc3QxIiwiTmV4dFJlcXVlc3QiLCJtZXRob2QiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInBhc3N3b3JkIiwiaGVhZGVycyIsInNpZ251cFJlc3BvbnNlMSIsInNpZ251cEhhbmRsZXIiLCJzdGF0dXMiLCJzaWdudXBSZXF1ZXN0MiIsInNpZ251cFJlc3BvbnNlMiIsInNpZ251cERhdGEyIiwianNvbiIsInRvQ29udGFpbiIsInZlcmlmeVJlcXVlc3QiLCJ2ZXJpZnlSZXNwb25zZSIsInZlcmlmeUVtYWlsSGFuZGxlciIsInZlcmlmeURhdGEiLCJ2ZXJpZnlSZXF1ZXN0MSIsInZlcmlmeVJlc3BvbnNlMSIsInZlcmlmeURhdGExIiwidmVyaWZ5UmVxdWVzdDIiLCJ2ZXJpZnlSZXNwb25zZTIiLCJ2ZXJpZnlEYXRhMiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Q0FJQztBQU9ELHFCQUFxQjtBQUNyQkEsS0FBS0MsSUFBSSxDQUFDO0FBQ1ZELEtBQUtDLElBQUksQ0FBQzs7OztxQ0FQZ0M7OENBRUc7b0NBQ1Y7QUFNbkMsTUFBTUMsbUJBQW1CO0lBQ3ZCQyx1QkFBdUJILEtBQUtJLEVBQUU7QUFDaEM7QUFFQSxNQUFNQyx5QkFBeUJDLHNDQUFrQjtBQUNqRCxNQUFNQyx5QkFBeUJDLFFBQVEsZ0NBQWdDQyxrQkFBa0I7QUFFekYsNkJBQTZCO0FBQzdCLE1BQU1DLGNBQWNDLFFBQVFDLEdBQUc7QUFFL0JD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