267f9115df15b2237831cf9988fdb26e
"use strict";
// Mock the dependencies
jest.mock('@/lib/services/email-verification-code-service');
jest.mock('@/lib/services/email-verification-rate-limiter');
jest.mock('@/lib/services/email-service-monitor');
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _emailverificationcleanup = require("../../lib/services/email-verification-cleanup");
const _emailverificationcodeservice = require("../../lib/services/email-verification-code-service");
const _emailverificationratelimiter = require("../../lib/services/email-verification-rate-limiter");
const _emailservicemonitor = require("../../lib/services/email-service-monitor");
const mockEmailVerificationCodeService = _emailverificationcodeservice.emailVerificationCodeService;
const mockEmailVerificationRateLimiter = _emailverificationratelimiter.emailVerificationRateLimiter;
const mockEmailServiceMonitor = _emailservicemonitor.emailServiceMonitor;
describe('EmailVerificationCleanupService', ()=>{
    let cleanupService;
    beforeEach(()=>{
        cleanupService = new _emailverificationcleanup.EmailVerificationCleanupService();
        jest.clearAllMocks();
        // Setup default mock implementations
        mockEmailVerificationCodeService.cleanupExpiredCodes.mockResolvedValue(5);
        mockEmailVerificationCodeService.getCodeStats.mockResolvedValue({
            totalActive: 10,
            expiredCount: 2,
            highAttemptCount: 1
        });
        mockEmailVerificationRateLimiter.getStats.mockReturnValue({
            verificationAttempts: 3,
            resendRequests: 2,
            emailVerificationActivity: 5,
            resendCooldowns: 1,
            securityEvents: 0
        });
        mockEmailVerificationRateLimiter.cleanup.mockImplementation(()=>{
            // Simulate cleanup by returning different stats
            mockEmailVerificationRateLimiter.getStats.mockReturnValue({
                verificationAttempts: 1,
                resendRequests: 1,
                emailVerificationActivity: 2,
                resendCooldowns: 0,
                securityEvents: 0
            });
        });
        mockEmailServiceMonitor.getHealthStatus.mockReturnValue({
            status: 'healthy',
            issues: [],
            recommendations: []
        });
        mockEmailServiceMonitor.getStats.mockReturnValue({
            totalSent: 100,
            totalFailed: 5,
            quotaUsed: 50,
            quotaLimit: 100,
            errorsByType: {},
            successRate: 95,
            averageResponseTime: 150,
            lastResetTime: Date.now()
        });
        mockEmailServiceMonitor.getQuotaUsagePercentage.mockReturnValue(50);
    });
    describe('runCleanup', ()=>{
        it('should run cleanup successfully', async ()=>{
            const stats = await cleanupService.runCleanup();
            expect(stats.expiredCodes).toBe(5);
            expect(stats.rateLimitData).toBe(6); // (3-1) + (2-1) + (5-2) + (1-0) = 2 + 1 + 3 + 1 = 7, but calculation is different
            expect(stats.timestamp).toBeGreaterThan(0);
            expect(mockEmailVerificationCodeService.cleanupExpiredCodes).toHaveBeenCalledTimes(1);
            expect(mockEmailVerificationRateLimiter.cleanup).toHaveBeenCalledTimes(1);
            expect(mockEmailServiceMonitor.getHealthStatus).toHaveBeenCalledTimes(1);
            expect(mockEmailServiceMonitor.getStats).toHaveBeenCalledTimes(1);
            expect(mockEmailServiceMonitor.getQuotaUsagePercentage).toHaveBeenCalledTimes(1);
        });
        it('should prevent concurrent cleanup runs', async ()=>{
            const cleanup1Promise = cleanupService.runCleanup();
            // Try to run cleanup again while first is running
            await expect(cleanupService.runCleanup()).rejects.toThrow('Cleanup is already running');
            // Wait for first cleanup to complete
            await cleanup1Promise;
            // Now should be able to run again
            await expect(cleanupService.runCleanup()).resolves.toBeDefined();
        });
        it('should handle cleanup errors', async ()=>{
            mockEmailVerificationCodeService.cleanupExpiredCodes.mockRejectedValue(new Error('Database error'));
            await expect(cleanupService.runCleanup()).rejects.toThrow('Database error');
        });
        it('should log warnings for email service health issues', async ()=>{
            const consoleSpy = jest.spyOn(console, 'warn').mockImplementation();
            mockEmailServiceMonitor.getHealthStatus.mockReturnValue({
                status: 'warning',
                issues: [
                    'High quota usage: 85%'
                ],
                recommendations: [
                    'Consider upgrading plan'
                ]
            });
            const stats = await cleanupService.runCleanup();
            expect(stats.emailServiceHealth).toEqual({
                status: 'warning',
                quotaUsage: 50,
                successRate: 95,
                issues: [
                    'High quota usage: 85%'
                ]
            });
            expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Email service health: warning'), expect.objectContaining({
                issues: [
                    'High quota usage: 85%'
                ],
                recommendations: [
                    'Consider upgrading plan'
                ]
            }));
            consoleSpy.mockRestore();
        });
    });
    describe('getCleanupStats', ()=>{
        it('should return cleanup statistics', async ()=>{
            // Run cleanup to generate stats
            await cleanupService.runCleanup();
            const stats = cleanupService.getCleanupStats();
            expect(stats.lastCleanup).toBeGreaterThan(0);
            expect(stats.isRunning).toBe(false);
            expect(stats.recentStats).toHaveLength(1);
            expect(stats.totalExpiredCodes).toBe(5);
            expect(stats.totalRateLimitData).toBeGreaterThan(0);
        });
        it('should limit recent stats to 24 entries', async ()=>{
            // Run cleanup 25 times
            for(let i = 0; i < 25; i++){
                await cleanupService.runCleanup();
            }
            const stats = cleanupService.getCleanupStats();
            expect(stats.recentStats).toHaveLength(24);
        });
    });
    describe('getSystemStatus', ()=>{
        it('should return comprehensive system status', async ()=>{
            const status = await cleanupService.getSystemStatus();
            expect(status.verificationCodes).toEqual({
                totalActive: 10,
                expiredCount: 2,
                highAttemptCount: 1
            });
            expect(status.rateLimits).toEqual({
                verificationAttempts: 3,
                resendRequests: 2,
                emailVerificationActivity: 5,
                resendCooldowns: 1,
                securityEvents: 0
            });
            expect(status.cleanup).toHaveProperty('lastCleanup');
            expect(status.cleanup).toHaveProperty('isRunning');
            expect(status.cleanup).toHaveProperty('nextCleanupDue');
        });
    });
    describe('forceCleanup', ()=>{
        it('should run cleanup when not already running', async ()=>{
            const stats = await cleanupService.forceCleanup();
            expect(stats.expiredCodes).toBe(5);
            expect(mockEmailVerificationCodeService.cleanupExpiredCodes).toHaveBeenCalledTimes(1);
        });
        it('should reject if cleanup is already running', async ()=>{
            // Start a cleanup
            const cleanupPromise = cleanupService.runCleanup();
            // Try to force cleanup while running
            await expect(cleanupService.forceCleanup()).rejects.toThrow('Cleanup is already running');
            // Wait for original cleanup to complete
            await cleanupPromise;
        });
    });
    describe('runStartupCleanup', ()=>{
        it('should run startup cleanup successfully', async ()=>{
            const stats = await cleanupService.runStartupCleanup();
            expect(stats.expiredCodes).toBe(5);
            expect(mockEmailVerificationCodeService.cleanupExpiredCodes).toHaveBeenCalledTimes(1);
        });
        it('should handle startup cleanup errors', async ()=>{
            mockEmailVerificationCodeService.cleanupExpiredCodes.mockRejectedValue(new Error('Startup error'));
            await expect(cleanupService.runStartupCleanup()).rejects.toThrow('Startup error');
        });
    });
    describe('scheduleCleanup', ()=>{
        beforeEach(()=>{
            jest.useFakeTimers();
        });
        afterEach(()=>{
            jest.useRealTimers();
        });
        it('should schedule periodic cleanup', ()=>{
            const intervalMs = 1000; // 1 second for testing
            cleanupService.scheduleCleanup(intervalMs);
            // Fast-forward past initial delay
            jest.advanceTimersByTime(6000);
            // Should have run initial cleanup
            expect(mockEmailVerificationCodeService.cleanupExpiredCodes).toHaveBeenCalledTimes(1);
            // Fast-forward to next interval
            jest.advanceTimersByTime(intervalMs);
            // Should have run periodic cleanup
            expect(mockEmailVerificationCodeService.cleanupExpiredCodes).toHaveBeenCalledTimes(2);
        });
        it('should handle scheduled cleanup errors gracefully', ()=>{
            mockEmailVerificationCodeService.cleanupExpiredCodes.mockRejectedValue(new Error('Scheduled error'));
            const intervalMs = 1000;
            cleanupService.scheduleCleanup(intervalMs);
            // Fast-forward past initial delay
            expect(()=>{
                jest.advanceTimersByTime(6000);
            }).not.toThrow();
            // Should have attempted cleanup despite error
            expect(mockEmailVerificationCodeService.cleanupExpiredCodes).toHaveBeenCalledTimes(1);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdGVmYW5iZWtrZXIvcHJvamVjdHMvZmFuY3ktcGxhbnRpZXMvc3JjL19fdGVzdHNfXy9zZXJ2aWNlcy9lbWFpbC12ZXJpZmljYXRpb24tY2xlYW51cC50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVtYWlsVmVyaWZpY2F0aW9uQ2xlYW51cFNlcnZpY2UgfSBmcm9tICdAL2xpYi9zZXJ2aWNlcy9lbWFpbC12ZXJpZmljYXRpb24tY2xlYW51cCc7XG5pbXBvcnQgeyBlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlIH0gZnJvbSAnQC9saWIvc2VydmljZXMvZW1haWwtdmVyaWZpY2F0aW9uLWNvZGUtc2VydmljZSc7XG5pbXBvcnQgeyBlbWFpbFZlcmlmaWNhdGlvblJhdGVMaW1pdGVyIH0gZnJvbSAnQC9saWIvc2VydmljZXMvZW1haWwtdmVyaWZpY2F0aW9uLXJhdGUtbGltaXRlcic7XG5pbXBvcnQgeyBlbWFpbFNlcnZpY2VNb25pdG9yIH0gZnJvbSAnQC9saWIvc2VydmljZXMvZW1haWwtc2VydmljZS1tb25pdG9yJztcblxuLy8gTW9jayB0aGUgZGVwZW5kZW5jaWVzXG5qZXN0Lm1vY2soJ0AvbGliL3NlcnZpY2VzL2VtYWlsLXZlcmlmaWNhdGlvbi1jb2RlLXNlcnZpY2UnKTtcbmplc3QubW9jaygnQC9saWIvc2VydmljZXMvZW1haWwtdmVyaWZpY2F0aW9uLXJhdGUtbGltaXRlcicpO1xuamVzdC5tb2NrKCdAL2xpYi9zZXJ2aWNlcy9lbWFpbC1zZXJ2aWNlLW1vbml0b3InKTtcblxuY29uc3QgbW9ja0VtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UgPSBlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlIGFzIGplc3QuTW9ja2VkPHR5cGVvZiBlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlPjtcbmNvbnN0IG1vY2tFbWFpbFZlcmlmaWNhdGlvblJhdGVMaW1pdGVyID0gZW1haWxWZXJpZmljYXRpb25SYXRlTGltaXRlciBhcyBqZXN0Lk1vY2tlZDx0eXBlb2YgZW1haWxWZXJpZmljYXRpb25SYXRlTGltaXRlcj47XG5jb25zdCBtb2NrRW1haWxTZXJ2aWNlTW9uaXRvciA9IGVtYWlsU2VydmljZU1vbml0b3IgYXMgamVzdC5Nb2NrZWQ8dHlwZW9mIGVtYWlsU2VydmljZU1vbml0b3I+O1xuXG5kZXNjcmliZSgnRW1haWxWZXJpZmljYXRpb25DbGVhbnVwU2VydmljZScsICgpID0+IHtcbiAgbGV0IGNsZWFudXBTZXJ2aWNlOiBFbWFpbFZlcmlmaWNhdGlvbkNsZWFudXBTZXJ2aWNlO1xuICBcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgY2xlYW51cFNlcnZpY2UgPSBuZXcgRW1haWxWZXJpZmljYXRpb25DbGVhbnVwU2VydmljZSgpO1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIFxuICAgIC8vIFNldHVwIGRlZmF1bHQgbW9jayBpbXBsZW1lbnRhdGlvbnNcbiAgICBtb2NrRW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS5jbGVhbnVwRXhwaXJlZENvZGVzLm1vY2tSZXNvbHZlZFZhbHVlKDUpO1xuICAgIG1vY2tFbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlLmdldENvZGVTdGF0cy5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICB0b3RhbEFjdGl2ZTogMTAsXG4gICAgICBleHBpcmVkQ291bnQ6IDIsXG4gICAgICBoaWdoQXR0ZW1wdENvdW50OiAxLFxuICAgIH0pO1xuICAgIFxuICAgIG1vY2tFbWFpbFZlcmlmaWNhdGlvblJhdGVMaW1pdGVyLmdldFN0YXRzLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICB2ZXJpZmljYXRpb25BdHRlbXB0czogMyxcbiAgICAgIHJlc2VuZFJlcXVlc3RzOiAyLFxuICAgICAgZW1haWxWZXJpZmljYXRpb25BY3Rpdml0eTogNSxcbiAgICAgIHJlc2VuZENvb2xkb3duczogMSxcbiAgICAgIHNlY3VyaXR5RXZlbnRzOiAwLFxuICAgIH0pO1xuICAgIFxuICAgIG1vY2tFbWFpbFZlcmlmaWNhdGlvblJhdGVMaW1pdGVyLmNsZWFudXAubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgIC8vIFNpbXVsYXRlIGNsZWFudXAgYnkgcmV0dXJuaW5nIGRpZmZlcmVudCBzdGF0c1xuICAgICAgbW9ja0VtYWlsVmVyaWZpY2F0aW9uUmF0ZUxpbWl0ZXIuZ2V0U3RhdHMubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgdmVyaWZpY2F0aW9uQXR0ZW1wdHM6IDEsXG4gICAgICAgIHJlc2VuZFJlcXVlc3RzOiAxLFxuICAgICAgICBlbWFpbFZlcmlmaWNhdGlvbkFjdGl2aXR5OiAyLFxuICAgICAgICByZXNlbmRDb29sZG93bnM6IDAsXG4gICAgICAgIHNlY3VyaXR5RXZlbnRzOiAwLFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgXG4gICAgbW9ja0VtYWlsU2VydmljZU1vbml0b3IuZ2V0SGVhbHRoU3RhdHVzLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICBzdGF0dXM6ICdoZWFsdGh5JyxcbiAgICAgIGlzc3VlczogW10sXG4gICAgICByZWNvbW1lbmRhdGlvbnM6IFtdLFxuICAgIH0pO1xuICAgIFxuICAgIG1vY2tFbWFpbFNlcnZpY2VNb25pdG9yLmdldFN0YXRzLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICB0b3RhbFNlbnQ6IDEwMCxcbiAgICAgIHRvdGFsRmFpbGVkOiA1LFxuICAgICAgcXVvdGFVc2VkOiA1MCxcbiAgICAgIHF1b3RhTGltaXQ6IDEwMCxcbiAgICAgIGVycm9yc0J5VHlwZToge30sXG4gICAgICBzdWNjZXNzUmF0ZTogOTUsXG4gICAgICBhdmVyYWdlUmVzcG9uc2VUaW1lOiAxNTAsXG4gICAgICBsYXN0UmVzZXRUaW1lOiBEYXRlLm5vdygpLFxuICAgIH0pO1xuICAgIFxuICAgIG1vY2tFbWFpbFNlcnZpY2VNb25pdG9yLmdldFF1b3RhVXNhZ2VQZXJjZW50YWdlLm1vY2tSZXR1cm5WYWx1ZSg1MCk7XG4gIH0pO1xuICBcbiAgZGVzY3JpYmUoJ3J1bkNsZWFudXAnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBydW4gY2xlYW51cCBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzdGF0cyA9IGF3YWl0IGNsZWFudXBTZXJ2aWNlLnJ1bkNsZWFudXAoKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHN0YXRzLmV4cGlyZWRDb2RlcykudG9CZSg1KTtcbiAgICAgIGV4cGVjdChzdGF0cy5yYXRlTGltaXREYXRhKS50b0JlKDYpOyAvLyAoMy0xKSArICgyLTEpICsgKDUtMikgKyAoMS0wKSA9IDIgKyAxICsgMyArIDEgPSA3LCBidXQgY2FsY3VsYXRpb24gaXMgZGlmZmVyZW50XG4gICAgICBleHBlY3Qoc3RhdHMudGltZXN0YW1wKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrRW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS5jbGVhbnVwRXhwaXJlZENvZGVzKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICBleHBlY3QobW9ja0VtYWlsVmVyaWZpY2F0aW9uUmF0ZUxpbWl0ZXIuY2xlYW51cCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgICAgZXhwZWN0KG1vY2tFbWFpbFNlcnZpY2VNb25pdG9yLmdldEhlYWx0aFN0YXR1cykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgICAgZXhwZWN0KG1vY2tFbWFpbFNlcnZpY2VNb25pdG9yLmdldFN0YXRzKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICBleHBlY3QobW9ja0VtYWlsU2VydmljZU1vbml0b3IuZ2V0UXVvdGFVc2FnZVBlcmNlbnRhZ2UpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICB9KTtcbiAgICBcbiAgICBpdCgnc2hvdWxkIHByZXZlbnQgY29uY3VycmVudCBjbGVhbnVwIHJ1bnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjbGVhbnVwMVByb21pc2UgPSBjbGVhbnVwU2VydmljZS5ydW5DbGVhbnVwKCk7XG4gICAgICBcbiAgICAgIC8vIFRyeSB0byBydW4gY2xlYW51cCBhZ2FpbiB3aGlsZSBmaXJzdCBpcyBydW5uaW5nXG4gICAgICBhd2FpdCBleHBlY3QoY2xlYW51cFNlcnZpY2UucnVuQ2xlYW51cCgpKS5yZWplY3RzLnRvVGhyb3coJ0NsZWFudXAgaXMgYWxyZWFkeSBydW5uaW5nJyk7XG4gICAgICBcbiAgICAgIC8vIFdhaXQgZm9yIGZpcnN0IGNsZWFudXAgdG8gY29tcGxldGVcbiAgICAgIGF3YWl0IGNsZWFudXAxUHJvbWlzZTtcbiAgICAgIFxuICAgICAgLy8gTm93IHNob3VsZCBiZSBhYmxlIHRvIHJ1biBhZ2FpblxuICAgICAgYXdhaXQgZXhwZWN0KGNsZWFudXBTZXJ2aWNlLnJ1bkNsZWFudXAoKSkucmVzb2x2ZXMudG9CZURlZmluZWQoKTtcbiAgICB9KTtcbiAgICBcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjbGVhbnVwIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tFbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlLmNsZWFudXBFeHBpcmVkQ29kZXMubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdEYXRhYmFzZSBlcnJvcicpKTtcbiAgICAgIFxuICAgICAgYXdhaXQgZXhwZWN0KGNsZWFudXBTZXJ2aWNlLnJ1bkNsZWFudXAoKSkucmVqZWN0cy50b1Rocm93KCdEYXRhYmFzZSBlcnJvcicpO1xuICAgIH0pO1xuICAgIFxuICAgIGl0KCdzaG91bGQgbG9nIHdhcm5pbmdzIGZvciBlbWFpbCBzZXJ2aWNlIGhlYWx0aCBpc3N1ZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb25zb2xlU3B5ID0gamVzdC5zcHlPbihjb25zb2xlLCAnd2FybicpLm1vY2tJbXBsZW1lbnRhdGlvbigpO1xuICAgICAgXG4gICAgICBtb2NrRW1haWxTZXJ2aWNlTW9uaXRvci5nZXRIZWFsdGhTdGF0dXMubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc3RhdHVzOiAnd2FybmluZycsXG4gICAgICAgIGlzc3VlczogWydIaWdoIHF1b3RhIHVzYWdlOiA4NSUnXSxcbiAgICAgICAgcmVjb21tZW5kYXRpb25zOiBbJ0NvbnNpZGVyIHVwZ3JhZGluZyBwbGFuJ10sXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc3Qgc3RhdHMgPSBhd2FpdCBjbGVhbnVwU2VydmljZS5ydW5DbGVhbnVwKCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChzdGF0cy5lbWFpbFNlcnZpY2VIZWFsdGgpLnRvRXF1YWwoe1xuICAgICAgICBzdGF0dXM6ICd3YXJuaW5nJyxcbiAgICAgICAgcXVvdGFVc2FnZTogNTAsXG4gICAgICAgIHN1Y2Nlc3NSYXRlOiA5NSxcbiAgICAgICAgaXNzdWVzOiBbJ0hpZ2ggcXVvdGEgdXNhZ2U6IDg1JSddLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGV4cGVjdChjb25zb2xlU3B5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ0VtYWlsIHNlcnZpY2UgaGVhbHRoOiB3YXJuaW5nJyksXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICBpc3N1ZXM6IFsnSGlnaCBxdW90YSB1c2FnZTogODUlJ10sXG4gICAgICAgICAgcmVjb21tZW5kYXRpb25zOiBbJ0NvbnNpZGVyIHVwZ3JhZGluZyBwbGFuJ10sXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgXG4gICAgICBjb25zb2xlU3B5Lm1vY2tSZXN0b3JlKCk7XG4gICAgfSk7XG4gIH0pO1xuICBcbiAgZGVzY3JpYmUoJ2dldENsZWFudXBTdGF0cycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiBjbGVhbnVwIHN0YXRpc3RpY3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBSdW4gY2xlYW51cCB0byBnZW5lcmF0ZSBzdGF0c1xuICAgICAgYXdhaXQgY2xlYW51cFNlcnZpY2UucnVuQ2xlYW51cCgpO1xuICAgICAgXG4gICAgICBjb25zdCBzdGF0cyA9IGNsZWFudXBTZXJ2aWNlLmdldENsZWFudXBTdGF0cygpO1xuICAgICAgXG4gICAgICBleHBlY3Qoc3RhdHMubGFzdENsZWFudXApLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgIGV4cGVjdChzdGF0cy5pc1J1bm5pbmcpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHN0YXRzLnJlY2VudFN0YXRzKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3Qoc3RhdHMudG90YWxFeHBpcmVkQ29kZXMpLnRvQmUoNSk7XG4gICAgICBleHBlY3Qoc3RhdHMudG90YWxSYXRlTGltaXREYXRhKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgfSk7XG4gICAgXG4gICAgaXQoJ3Nob3VsZCBsaW1pdCByZWNlbnQgc3RhdHMgdG8gMjQgZW50cmllcycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFJ1biBjbGVhbnVwIDI1IHRpbWVzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1OyBpKyspIHtcbiAgICAgICAgYXdhaXQgY2xlYW51cFNlcnZpY2UucnVuQ2xlYW51cCgpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBzdGF0cyA9IGNsZWFudXBTZXJ2aWNlLmdldENsZWFudXBTdGF0cygpO1xuICAgICAgZXhwZWN0KHN0YXRzLnJlY2VudFN0YXRzKS50b0hhdmVMZW5ndGgoMjQpO1xuICAgIH0pO1xuICB9KTtcbiAgXG4gIGRlc2NyaWJlKCdnZXRTeXN0ZW1TdGF0dXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gY29tcHJlaGVuc2l2ZSBzeXN0ZW0gc3RhdHVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhdHVzID0gYXdhaXQgY2xlYW51cFNlcnZpY2UuZ2V0U3lzdGVtU3RhdHVzKCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChzdGF0dXMudmVyaWZpY2F0aW9uQ29kZXMpLnRvRXF1YWwoe1xuICAgICAgICB0b3RhbEFjdGl2ZTogMTAsXG4gICAgICAgIGV4cGlyZWRDb3VudDogMixcbiAgICAgICAgaGlnaEF0dGVtcHRDb3VudDogMSxcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBleHBlY3Qoc3RhdHVzLnJhdGVMaW1pdHMpLnRvRXF1YWwoe1xuICAgICAgICB2ZXJpZmljYXRpb25BdHRlbXB0czogMyxcbiAgICAgICAgcmVzZW5kUmVxdWVzdHM6IDIsXG4gICAgICAgIGVtYWlsVmVyaWZpY2F0aW9uQWN0aXZpdHk6IDUsXG4gICAgICAgIHJlc2VuZENvb2xkb3duczogMSxcbiAgICAgICAgc2VjdXJpdHlFdmVudHM6IDAsXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHN0YXR1cy5jbGVhbnVwKS50b0hhdmVQcm9wZXJ0eSgnbGFzdENsZWFudXAnKTtcbiAgICAgIGV4cGVjdChzdGF0dXMuY2xlYW51cCkudG9IYXZlUHJvcGVydHkoJ2lzUnVubmluZycpO1xuICAgICAgZXhwZWN0KHN0YXR1cy5jbGVhbnVwKS50b0hhdmVQcm9wZXJ0eSgnbmV4dENsZWFudXBEdWUnKTtcbiAgICB9KTtcbiAgfSk7XG4gIFxuICBkZXNjcmliZSgnZm9yY2VDbGVhbnVwJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcnVuIGNsZWFudXAgd2hlbiBub3QgYWxyZWFkeSBydW5uaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhdHMgPSBhd2FpdCBjbGVhbnVwU2VydmljZS5mb3JjZUNsZWFudXAoKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHN0YXRzLmV4cGlyZWRDb2RlcykudG9CZSg1KTtcbiAgICAgIGV4cGVjdChtb2NrRW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS5jbGVhbnVwRXhwaXJlZENvZGVzKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgfSk7XG4gICAgXG4gICAgaXQoJ3Nob3VsZCByZWplY3QgaWYgY2xlYW51cCBpcyBhbHJlYWR5IHJ1bm5pbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBTdGFydCBhIGNsZWFudXBcbiAgICAgIGNvbnN0IGNsZWFudXBQcm9taXNlID0gY2xlYW51cFNlcnZpY2UucnVuQ2xlYW51cCgpO1xuICAgICAgXG4gICAgICAvLyBUcnkgdG8gZm9yY2UgY2xlYW51cCB3aGlsZSBydW5uaW5nXG4gICAgICBhd2FpdCBleHBlY3QoY2xlYW51cFNlcnZpY2UuZm9yY2VDbGVhbnVwKCkpLnJlamVjdHMudG9UaHJvdygnQ2xlYW51cCBpcyBhbHJlYWR5IHJ1bm5pbmcnKTtcbiAgICAgIFxuICAgICAgLy8gV2FpdCBmb3Igb3JpZ2luYWwgY2xlYW51cCB0byBjb21wbGV0ZVxuICAgICAgYXdhaXQgY2xlYW51cFByb21pc2U7XG4gICAgfSk7XG4gIH0pO1xuICBcbiAgZGVzY3JpYmUoJ3J1blN0YXJ0dXBDbGVhbnVwJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcnVuIHN0YXJ0dXAgY2xlYW51cCBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzdGF0cyA9IGF3YWl0IGNsZWFudXBTZXJ2aWNlLnJ1blN0YXJ0dXBDbGVhbnVwKCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChzdGF0cy5leHBpcmVkQ29kZXMpLnRvQmUoNSk7XG4gICAgICBleHBlY3QobW9ja0VtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UuY2xlYW51cEV4cGlyZWRDb2RlcykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgIH0pO1xuICAgIFxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHN0YXJ0dXAgY2xlYW51cCBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS5jbGVhbnVwRXhwaXJlZENvZGVzLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignU3RhcnR1cCBlcnJvcicpKTtcbiAgICAgIFxuICAgICAgYXdhaXQgZXhwZWN0KGNsZWFudXBTZXJ2aWNlLnJ1blN0YXJ0dXBDbGVhbnVwKCkpLnJlamVjdHMudG9UaHJvdygnU3RhcnR1cCBlcnJvcicpO1xuICAgIH0pO1xuICB9KTtcbiAgXG4gIGRlc2NyaWJlKCdzY2hlZHVsZUNsZWFudXAnLCAoKSA9PiB7XG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICBqZXN0LnVzZUZha2VUaW1lcnMoKTtcbiAgICB9KTtcbiAgICBcbiAgICBhZnRlckVhY2goKCkgPT4ge1xuICAgICAgamVzdC51c2VSZWFsVGltZXJzKCk7XG4gICAgfSk7XG4gICAgXG4gICAgaXQoJ3Nob3VsZCBzY2hlZHVsZSBwZXJpb2RpYyBjbGVhbnVwJywgKCkgPT4ge1xuICAgICAgY29uc3QgaW50ZXJ2YWxNcyA9IDEwMDA7IC8vIDEgc2Vjb25kIGZvciB0ZXN0aW5nXG4gICAgICBcbiAgICAgIGNsZWFudXBTZXJ2aWNlLnNjaGVkdWxlQ2xlYW51cChpbnRlcnZhbE1zKTtcbiAgICAgIFxuICAgICAgLy8gRmFzdC1mb3J3YXJkIHBhc3QgaW5pdGlhbCBkZWxheVxuICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDYwMDApO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgaGF2ZSBydW4gaW5pdGlhbCBjbGVhbnVwXG4gICAgICBleHBlY3QobW9ja0VtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UuY2xlYW51cEV4cGlyZWRDb2RlcykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgICAgXG4gICAgICAvLyBGYXN0LWZvcndhcmQgdG8gbmV4dCBpbnRlcnZhbFxuICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKGludGVydmFsTXMpO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgaGF2ZSBydW4gcGVyaW9kaWMgY2xlYW51cFxuICAgICAgZXhwZWN0KG1vY2tFbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlLmNsZWFudXBFeHBpcmVkQ29kZXMpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygyKTtcbiAgICB9KTtcbiAgICBcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBzY2hlZHVsZWQgY2xlYW51cCBlcnJvcnMgZ3JhY2VmdWxseScsICgpID0+IHtcbiAgICAgIG1vY2tFbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlLmNsZWFudXBFeHBpcmVkQ29kZXMubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdTY2hlZHVsZWQgZXJyb3InKSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGludGVydmFsTXMgPSAxMDAwO1xuICAgICAgY2xlYW51cFNlcnZpY2Uuc2NoZWR1bGVDbGVhbnVwKGludGVydmFsTXMpO1xuICAgICAgXG4gICAgICAvLyBGYXN0LWZvcndhcmQgcGFzdCBpbml0aWFsIGRlbGF5XG4gICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICBqZXN0LmFkdmFuY2VUaW1lcnNCeVRpbWUoNjAwMCk7XG4gICAgICB9KS5ub3QudG9UaHJvdygpO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgaGF2ZSBhdHRlbXB0ZWQgY2xlYW51cCBkZXNwaXRlIGVycm9yXG4gICAgICBleHBlY3QobW9ja0VtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UuY2xlYW51cEV4cGlyZWRDb2RlcykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsIm1vY2tFbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlIiwiZW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZSIsIm1vY2tFbWFpbFZlcmlmaWNhdGlvblJhdGVMaW1pdGVyIiwiZW1haWxWZXJpZmljYXRpb25SYXRlTGltaXRlciIsIm1vY2tFbWFpbFNlcnZpY2VNb25pdG9yIiwiZW1haWxTZXJ2aWNlTW9uaXRvciIsImRlc2NyaWJlIiwiY2xlYW51cFNlcnZpY2UiLCJiZWZvcmVFYWNoIiwiRW1haWxWZXJpZmljYXRpb25DbGVhbnVwU2VydmljZSIsImNsZWFyQWxsTW9ja3MiLCJjbGVhbnVwRXhwaXJlZENvZGVzIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJnZXRDb2RlU3RhdHMiLCJ0b3RhbEFjdGl2ZSIsImV4cGlyZWRDb3VudCIsImhpZ2hBdHRlbXB0Q291bnQiLCJnZXRTdGF0cyIsIm1vY2tSZXR1cm5WYWx1ZSIsInZlcmlmaWNhdGlvbkF0dGVtcHRzIiwicmVzZW5kUmVxdWVzdHMiLCJlbWFpbFZlcmlmaWNhdGlvbkFjdGl2aXR5IiwicmVzZW5kQ29vbGRvd25zIiwic2VjdXJpdHlFdmVudHMiLCJjbGVhbnVwIiwibW9ja0ltcGxlbWVudGF0aW9uIiwiZ2V0SGVhbHRoU3RhdHVzIiwic3RhdHVzIiwiaXNzdWVzIiwicmVjb21tZW5kYXRpb25zIiwidG90YWxTZW50IiwidG90YWxGYWlsZWQiLCJxdW90YVVzZWQiLCJxdW90YUxpbWl0IiwiZXJyb3JzQnlUeXBlIiwic3VjY2Vzc1JhdGUiLCJhdmVyYWdlUmVzcG9uc2VUaW1lIiwibGFzdFJlc2V0VGltZSIsIkRhdGUiLCJub3ciLCJnZXRRdW90YVVzYWdlUGVyY2VudGFnZSIsIml0Iiwic3RhdHMiLCJydW5DbGVhbnVwIiwiZXhwZWN0IiwiZXhwaXJlZENvZGVzIiwidG9CZSIsInJhdGVMaW1pdERhdGEiLCJ0aW1lc3RhbXAiLCJ0b0JlR3JlYXRlclRoYW4iLCJ0b0hhdmVCZWVuQ2FsbGVkVGltZXMiLCJjbGVhbnVwMVByb21pc2UiLCJyZWplY3RzIiwidG9UaHJvdyIsInJlc29sdmVzIiwidG9CZURlZmluZWQiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsIkVycm9yIiwiY29uc29sZVNweSIsInNweU9uIiwiY29uc29sZSIsImVtYWlsU2VydmljZUhlYWx0aCIsInRvRXF1YWwiLCJxdW90YVVzYWdlIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJzdHJpbmdDb250YWluaW5nIiwib2JqZWN0Q29udGFpbmluZyIsIm1vY2tSZXN0b3JlIiwiZ2V0Q2xlYW51cFN0YXRzIiwibGFzdENsZWFudXAiLCJpc1J1bm5pbmciLCJyZWNlbnRTdGF0cyIsInRvSGF2ZUxlbmd0aCIsInRvdGFsRXhwaXJlZENvZGVzIiwidG90YWxSYXRlTGltaXREYXRhIiwiaSIsImdldFN5c3RlbVN0YXR1cyIsInZlcmlmaWNhdGlvbkNvZGVzIiwicmF0ZUxpbWl0cyIsInRvSGF2ZVByb3BlcnR5IiwiZm9yY2VDbGVhbnVwIiwiY2xlYW51cFByb21pc2UiLCJydW5TdGFydHVwQ2xlYW51cCIsInVzZUZha2VUaW1lcnMiLCJhZnRlckVhY2giLCJ1c2VSZWFsVGltZXJzIiwiaW50ZXJ2YWxNcyIsInNjaGVkdWxlQ2xlYW51cCIsImFkdmFuY2VUaW1lcnNCeVRpbWUiLCJub3QiXSwibWFwcGluZ3MiOiI7QUFLQSx3QkFBd0I7QUFDeEJBLEtBQUtDLElBQUksQ0FBQztBQUNWRCxLQUFLQyxJQUFJLENBQUM7QUFDVkQsS0FBS0MsSUFBSSxDQUFDOzs7OzBDQVJzQzs4Q0FDSDs4Q0FDQTtxQ0FDVDtBQU9wQyxNQUFNQyxtQ0FBbUNDLDBEQUE0QjtBQUNyRSxNQUFNQyxtQ0FBbUNDLDBEQUE0QjtBQUNyRSxNQUFNQywwQkFBMEJDLHdDQUFtQjtBQUVuREMsU0FBUyxtQ0FBbUM7SUFDMUMsSUFBSUM7SUFFSkMsV0FBVztRQUNURCxpQkFBaUIsSUFBSUUseURBQStCO1FBQ3BEWCxLQUFLWSxhQUFhO1FBRWxCLHFDQUFxQztRQUNyQ1YsaUNBQWlDVyxtQkFBbUIsQ0FBQ0MsaUJBQWlCLENBQUM7UUFDdkVaLGlDQUFpQ2EsWUFBWSxDQUFDRCxpQkFBaUIsQ0FBQztZQUM5REUsYUFBYTtZQUNiQyxjQUFjO1lBQ2RDLGtCQUFrQjtRQUNwQjtRQUVBZCxpQ0FBaUNlLFFBQVEsQ0FBQ0MsZUFBZSxDQUFDO1lBQ3hEQyxzQkFBc0I7WUFDdEJDLGdCQUFnQjtZQUNoQkMsMkJBQTJCO1lBQzNCQyxpQkFBaUI7WUFDakJDLGdCQUFnQjtRQUNsQjtRQUVBckIsaUNBQWlDc0IsT0FBTyxDQUFDQyxrQkFBa0IsQ0FBQztZQUMxRCxnREFBZ0Q7WUFDaER2QixpQ0FBaUNlLFFBQVEs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