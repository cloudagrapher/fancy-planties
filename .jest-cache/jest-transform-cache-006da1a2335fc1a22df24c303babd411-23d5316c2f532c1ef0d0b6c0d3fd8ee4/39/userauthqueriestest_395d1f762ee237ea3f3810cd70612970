bdf81401392eb01c6235d3a329d8ff8b
/**
 * User and Authentication Database Query Tests
 * Tests user creation, retrieval, session management, and password operations
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _auth = require("../../lib/auth");
const _databasetestmanager = require("../../test-utils/setup/database-test-manager.js");
const _userfactory = require("../../test-utils/factories/user-factory.js");
describe('User and Authentication Database Queries', ()=>{
    let dbManager;
    beforeEach(()=>{
        dbManager = (0, _databasetestmanager.createDatabaseTestManager)();
    });
    afterEach(async ()=>{
        await dbManager.cleanup();
    });
    describe('User Creation and Retrieval', ()=>{
        test('should create a new user with hashed password', async ()=>{
            const email = 'test@example.com';
            const password = 'testpassword123';
            const name = 'Test User';
            const user = await (0, _auth.createUser)(email, password, name);
            expect(user).toBeDefined();
            expect(user.id).toBeDefined();
            expect(user.email).toBe(email.toLowerCase());
            expect(user.name).toBe(name);
            expect(user.hashedPassword).toBeDefined();
            expect(user.hashedPassword).not.toBe(password); // Should be hashed
            expect(user.isCurator).toBe(false);
            expect(user.isEmailVerified).toBe(false);
            expect(user.createdAt).toBeInstanceOf(Date);
            expect(user.updatedAt).toBeInstanceOf(Date);
            // Track for cleanup
            dbManager.createdUsers.push(user.id);
        });
        test('should retrieve user by email (case insensitive)', async ()=>{
            const testUser = (0, _userfactory.createTestUser)({
                email: 'Test@Example.COM'
            });
            const createdUser = await dbManager.createTestUser(testUser);
            // Test case insensitive retrieval
            const foundUser1 = await (0, _auth.getUserByEmail)('test@example.com');
            const foundUser2 = await (0, _auth.getUserByEmail)('TEST@EXAMPLE.COM');
            const foundUser3 = await (0, _auth.getUserByEmail)('Test@Example.COM');
            expect(foundUser1).toBeDefined();
            expect(foundUser2).toBeDefined();
            expect(foundUser3).toBeDefined();
            expect(foundUser1.id).toBe(createdUser.id);
            expect(foundUser2.id).toBe(createdUser.id);
            expect(foundUser3.id).toBe(createdUser.id);
        });
        test('should return null for non-existent email', async ()=>{
            const user = await (0, _auth.getUserByEmail)('nonexistent@example.com');
            expect(user).toBeNull();
        });
        test('should retrieve user by ID', async ()=>{
            const testUser = (0, _userfactory.createTestUser)();
            const createdUser = await dbManager.createTestUser(testUser);
            const foundUser = await (0, _auth.getUserById)(createdUser.id);
            expect(foundUser).toBeDefined();
            expect(foundUser.id).toBe(createdUser.id);
            expect(foundUser.email).toBe(createdUser.email);
            expect(foundUser.name).toBe(createdUser.name);
        });
        test('should return null for non-existent user ID', async ()=>{
            const user = await (0, _auth.getUserById)(99999);
            expect(user).toBeNull();
        });
        test('should prevent duplicate email registration', async ()=>{
            const email = 'duplicate@example.com';
            // Create first user
            await (0, _auth.createUser)(email, 'password1', 'User 1');
            // Attempt to create second user with same email should fail
            await expect((0, _auth.createUser)(email, 'password2', 'User 2')).rejects.toThrow();
        });
    });
    describe('Password Hashing and Verification', ()=>{
        test('should hash passwords securely', async ()=>{
            const password = 'testpassword123';
            const hash1 = await (0, _auth.hashPassword)(password);
            const hash2 = await (0, _auth.hashPassword)(password);
            expect(hash1).toBeDefined();
            expect(hash2).toBeDefined();
            expect(hash1).not.toBe(password);
            expect(hash2).not.toBe(password);
            expect(hash1).not.toBe(hash2); // Should use salt, so hashes differ
            expect(hash1.length).toBeGreaterThan(50); // bcrypt hashes are long
        });
        test('should verify correct passwords', async ()=>{
            const password = 'testpassword123';
            const hash = await (0, _auth.hashPassword)(password);
            const isValid = await (0, _auth.verifyPassword)(password, hash);
            expect(isValid).toBe(true);
        });
        test('should reject incorrect passwords', async ()=>{
            const password = 'testpassword123';
            const wrongPassword = 'wrongpassword';
            const hash = await (0, _auth.hashPassword)(password);
            const isValid = await (0, _auth.verifyPassword)(wrongPassword, hash);
            expect(isValid).toBe(false);
        });
        test('should handle empty passwords gracefully', async ()=>{
            const hash = await (0, _auth.hashPassword)('validpassword');
            const isValid = await (0, _auth.verifyPassword)('', hash);
            expect(isValid).toBe(false);
        });
    });
    describe('Session Management', ()=>{
        test('should create session for user', async ()=>{
            const testUser = (0, _userfactory.createTestUser)();
            const createdUser = await dbManager.createTestUser(testUser);
            const session = await (0, _auth.createSession)(createdUser.id);
            expect(session).toBeDefined();
            expect(session.id).toBeDefined();
            expect(session.userId).toBe(createdUser.id);
            expect(session.expiresAt).toBeInstanceOf(Date);
            expect(session.expiresAt.getTime()).toBeGreaterThan(Date.now());
            // Track for cleanup
            dbManager.createdSessions.push(session.id);
        });
        test('should retrieve session by ID', async ()=>{
            const testUser = (0, _userfactory.createTestUser)();
            const createdUser = await dbManager.createTestUser(testUser);
            const session = await (0, _auth.createSession)(createdUser.id);
            dbManager.createdSessions.push(session.id);
            const foundSession = await dbManager.getSessionById(session.id);
            expect(foundSession).toBeDefined();
            expect(foundSession.id).toBe(session.id);
            expect(foundSession.userId).toBe(createdUser.id);
        });
        test('should retrieve sessions by user ID', async ()=>{
            const testUser = (0, _userfactory.createTestUser)();
            const createdUser = await dbManager.createTestUser(testUser);
            // Create multiple sessions for the user
            const session1 = await (0, _auth.createSession)(createdUser.id);
            const session2 = await (0, _auth.createSession)(createdUser.id);
            dbManager.createdSessions.push(session1.id, session2.id);
            const userSessions = await dbManager.getSessionsByUserId(createdUser.id);
            expect(userSessions).toHaveLength(2);
            expect(userSessions.map((s)=>s.id)).toContain(session1.id);
            expect(userSessions.map((s)=>s.id)).toContain(session2.id);
        });
        test('should invalidate session', async ()=>{
            const testUser = (0, _userfactory.createTestUser)();
            const createdUser = await dbManager.createTestUser(testUser);
            const session = await (0, _auth.createSession)(createdUser.id);
            dbManager.createdSessions.push(session.id);
            // Verify session exists
            let foundSession = await dbManager.getSessionById(session.id);
            expect(foundSession).toBeDefined();
            // Invalidate session
            await (0, _auth.invalidateSession)(session.id);
            // Session should no longer exist
            foundSession = await dbManager.getSessionById(session.id);
            expect(foundSession).toBeNull();
        });
    });
    describe('Authentication Flows', ()=>{
        test('should sign in with valid credentials', async ()=>{
            const email = 'signin@example.com';
            const password = 'testpassword123';
            const name = 'Sign In User';
            // Create user first
            const user = await (0, _auth.createUser)(email, password, name);
            dbManager.createdUsers.push(user.id);
            // Attempt sign in
            const result = await (0, _auth.signIn)(email, password);
            expect(result).toBeDefined();
            expect(result.user).toBeDefined();
            expect(result.session).toBeDefined();
            expect(result.user.id).toBe(user.id);
            expect(result.user.email).toBe(email.toLowerCase());
            expect(result.session.userId).toBe(user.id);
            expect(result.session.id).toBeDefined();
            // Track session for cleanup
            dbManager.createdSessions.push(result.session.id);
        });
        test('should reject sign in with invalid email', async ()=>{
            const result = await (0, _auth.signIn)('nonexistent@example.com', 'password');
            expect(result).toBeNull();
        });
        test('should reject sign in with invalid password', async ()=>{
            const email = 'signin2@example.com';
            const password = 'correctpassword';
            const wrongPassword = 'wrongpassword';
            // Create user
            const user = await (0, _auth.createUser)(email, password, 'Test User');
            dbManager.createdUsers.push(user.id);
            // Attempt sign in with wrong password
            const result = await (0, _auth.signIn)(email, wrongPassword);
            expect(result).toBeNull();
        });
        test('should sign up new user successfully', async ()=>{
            const email = 'signup@example.com';
            const password = 'testpassword123';
            const name = 'Sign Up User';
            const result = await (0, _auth.signUp)(email, password, name);
            expect(result).toBeDefined();
            expect(result.user).toBeDefined();
            expect(result.session).toBeDefined();
            expect(result.user.email).toBe(email.toLowerCase());
            expect(result.user.name).toBe(name);
            expect(result.session.userId).toBe(result.user.id);
            // Track for cleanup
            dbManager.createdUsers.push(result.user.id);
            dbManager.createdSessions.push(result.session.id);
        });
        test('should reject sign up with existing email', async ()=>{
            const email = 'existing@example.com';
            const password = 'testpassword123';
            // Create first user
            const user1 = await (0, _auth.createUser)(email, password, 'First User');
            dbManager.createdUsers.push(user1.id);
            // Attempt to sign up with same email
            await expect((0, _auth.signUp)(email, password, 'Second User')).rejects.toThrow('User already exists');
        });
        test('should handle case insensitive email in sign in', async ()=>{
            const email = 'CaseTest@Example.COM';
            const password = 'testpassword123';
            // Create user with mixed case email
            const user = await (0, _auth.createUser)(email, password, 'Case Test User');
            dbManager.createdUsers.push(user.id);
            // Sign in with different case
            const result = await (0, _auth.signIn)('casetest@example.com', password);
            expect(result).toBeDefined();
            expect(result.user.id).toBe(user.id);
            // Track session for cleanup
            dbManager.createdSessions.push(result.session.id);
        });
    });
    describe('Email Verification Code Management', ()=>{
        test('should create and retrieve email verification codes', async ()=>{
            const testUser = (0, _userfactory.createTestUser)();
            const createdUser = await dbManager.createTestUser(testUser);
            const codeData = {
                userId: createdUser.id,
                code: '123456',
                expiresAt: new Date(Date.now() + 15 * 60 * 1000),
                attemptsUsed: 0
            };
            const createdCode = await dbManager.createTestEmailCode(codeData);
            expect(createdCode).toBeDefined();
            expect(createdCode.userId).toBe(createdUser.id);
            expect(createdCode.code).toBe('123456');
            expect(createdCode.expiresAt).toBeInstanceOf(Date);
            // Retrieve codes for user
            const userCodes = await dbManager.getEmailCodesByUserId(createdUser.id);
            expect(userCodes).toHaveLength(1);
            expect(userCodes[0].id).toBe(createdCode.id);
        });
        test('should handle multiple verification codes for user', async ()=>{
            const testUser = (0, _userfactory.createTestUser)();
            const createdUser = await dbManager.createTestUser(testUser);
            // Create multiple codes (simulating code regeneration)
            const code1 = await dbManager.createTestEmailCode({
                userId: createdUser.id,
                code: '111111',
                expiresAt: new Date(Date.now() + 15 * 60 * 1000),
                attemptsUsed: 0
            });
            const code2 = await dbManager.createTestEmailCode({
                userId: createdUser.id,
                code: '222222',
                expiresAt: new Date(Date.now() + 15 * 60 * 1000),
                attemptsUsed: 0
            });
            const userCodes = await dbManager.getEmailCodesByUserId(createdUser.id);
            expect(userCodes).toHaveLength(2);
            expect(userCodes.map((c)=>c.code)).toContain('111111');
            expect(userCodes.map((c)=>c.code)).toContain('222222');
        });
    });
    describe('Database Connection and Error Handling', ()=>{
        test('should verify database connection is working', async ()=>{
            const isConnected = await dbManager.isConnected();
            expect(isConnected).toBe(true);
        });
        test('should handle database constraint violations gracefully', async ()=>{
            const email = 'constraint@example.com';
            // Create first user
            const user1 = await (0, _auth.createUser)(email, 'password1', 'User 1');
            dbManager.createdUsers.push(user1.id);
            // Attempt to create duplicate should throw error
            await expect((0, _auth.createUser)(email, 'password2', 'User 2')).rejects.toThrow();
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdGVmYW5iZWtrZXIvcHJvamVjdHMvZmFuY3ktcGxhbnRpZXMvc3JjL19fdGVzdHNfXy9kYXRhYmFzZS91c2VyLWF1dGgtcXVlcmllcy50ZXN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXNlciBhbmQgQXV0aGVudGljYXRpb24gRGF0YWJhc2UgUXVlcnkgVGVzdHNcbiAqIFRlc3RzIHVzZXIgY3JlYXRpb24sIHJldHJpZXZhbCwgc2Vzc2lvbiBtYW5hZ2VtZW50LCBhbmQgcGFzc3dvcmQgb3BlcmF0aW9uc1xuICovXG5cbmltcG9ydCB7XG4gIGNyZWF0ZVVzZXIsXG4gIGdldFVzZXJCeUVtYWlsLFxuICBnZXRVc2VyQnlJZCxcbiAgaGFzaFBhc3N3b3JkLFxuICB2ZXJpZnlQYXNzd29yZCxcbiAgc2lnbkluLFxuICBzaWduVXAsXG4gIGNyZWF0ZVNlc3Npb24sXG4gIGludmFsaWRhdGVTZXNzaW9uLFxufSBmcm9tICcuLi8uLi9saWIvYXV0aCc7XG5pbXBvcnQgeyBjcmVhdGVEYXRhYmFzZVRlc3RNYW5hZ2VyIH0gZnJvbSAnLi4vLi4vdGVzdC11dGlscy9zZXR1cC9kYXRhYmFzZS10ZXN0LW1hbmFnZXInO1xuaW1wb3J0IHsgY3JlYXRlVGVzdFVzZXIsIGNyZWF0ZVRlc3RVc2VyV2l0aFBhc3N3b3JkLCBoYXNoVGVzdFBhc3N3b3JkIH0gZnJvbSAnLi4vLi4vdGVzdC11dGlscy9mYWN0b3JpZXMvdXNlci1mYWN0b3J5JztcblxuZGVzY3JpYmUoJ1VzZXIgYW5kIEF1dGhlbnRpY2F0aW9uIERhdGFiYXNlIFF1ZXJpZXMnLCAoKSA9PiB7XG4gIGxldCBkYk1hbmFnZXI7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgZGJNYW5hZ2VyID0gY3JlYXRlRGF0YWJhc2VUZXN0TWFuYWdlcigpO1xuICB9KTtcblxuICBhZnRlckVhY2goYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGRiTWFuYWdlci5jbGVhbnVwKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdVc2VyIENyZWF0aW9uIGFuZCBSZXRyaWV2YWwnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGNyZWF0ZSBhIG5ldyB1c2VyIHdpdGggaGFzaGVkIHBhc3N3b3JkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZW1haWwgPSAndGVzdEBleGFtcGxlLmNvbSc7XG4gICAgICBjb25zdCBwYXNzd29yZCA9ICd0ZXN0cGFzc3dvcmQxMjMnO1xuICAgICAgY29uc3QgbmFtZSA9ICdUZXN0IFVzZXInO1xuXG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgY3JlYXRlVXNlcihlbWFpbCwgcGFzc3dvcmQsIG5hbWUpO1xuXG4gICAgICBleHBlY3QodXNlcikudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdCh1c2VyLmlkKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHVzZXIuZW1haWwpLnRvQmUoZW1haWwudG9Mb3dlckNhc2UoKSk7XG4gICAgICBleHBlY3QodXNlci5uYW1lKS50b0JlKG5hbWUpO1xuICAgICAgZXhwZWN0KHVzZXIuaGFzaGVkUGFzc3dvcmQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QodXNlci5oYXNoZWRQYXNzd29yZCkubm90LnRvQmUocGFzc3dvcmQpOyAvLyBTaG91bGQgYmUgaGFzaGVkXG4gICAgICBleHBlY3QodXNlci5pc0N1cmF0b3IpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHVzZXIuaXNFbWFpbFZlcmlmaWVkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh1c2VyLmNyZWF0ZWRBdCkudG9CZUluc3RhbmNlT2YoRGF0ZSk7XG4gICAgICBleHBlY3QodXNlci51cGRhdGVkQXQpLnRvQmVJbnN0YW5jZU9mKERhdGUpO1xuXG4gICAgICAvLyBUcmFjayBmb3IgY2xlYW51cFxuICAgICAgZGJNYW5hZ2VyLmNyZWF0ZWRVc2Vycy5wdXNoKHVzZXIuaWQpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIHJldHJpZXZlIHVzZXIgYnkgZW1haWwgKGNhc2UgaW5zZW5zaXRpdmUpJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFVzZXIgPSBjcmVhdGVUZXN0VXNlcih7XG4gICAgICAgIGVtYWlsOiAnVGVzdEBFeGFtcGxlLkNPTScsXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgY3JlYXRlZFVzZXIgPSBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdFVzZXIodGVzdFVzZXIpO1xuXG4gICAgICAvLyBUZXN0IGNhc2UgaW5zZW5zaXRpdmUgcmV0cmlldmFsXG4gICAgICBjb25zdCBmb3VuZFVzZXIxID0gYXdhaXQgZ2V0VXNlckJ5RW1haWwoJ3Rlc3RAZXhhbXBsZS5jb20nKTtcbiAgICAgIGNvbnN0IGZvdW5kVXNlcjIgPSBhd2FpdCBnZXRVc2VyQnlFbWFpbCgnVEVTVEBFWEFNUExFLkNPTScpO1xuICAgICAgY29uc3QgZm91bmRVc2VyMyA9IGF3YWl0IGdldFVzZXJCeUVtYWlsKCdUZXN0QEV4YW1wbGUuQ09NJyk7XG5cbiAgICAgIGV4cGVjdChmb3VuZFVzZXIxKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGZvdW5kVXNlcjIpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoZm91bmRVc2VyMykudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChmb3VuZFVzZXIxLmlkKS50b0JlKGNyZWF0ZWRVc2VyLmlkKTtcbiAgICAgIGV4cGVjdChmb3VuZFVzZXIyLmlkKS50b0JlKGNyZWF0ZWRVc2VyLmlkKTtcbiAgICAgIGV4cGVjdChmb3VuZFVzZXIzLmlkKS50b0JlKGNyZWF0ZWRVc2VyLmlkKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gbnVsbCBmb3Igbm9uLWV4aXN0ZW50IGVtYWlsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGdldFVzZXJCeUVtYWlsKCdub25leGlzdGVudEBleGFtcGxlLmNvbScpO1xuICAgICAgZXhwZWN0KHVzZXIpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmV0cmlldmUgdXNlciBieSBJRCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RVc2VyID0gY3JlYXRlVGVzdFVzZXIoKTtcbiAgICAgIGNvbnN0IGNyZWF0ZWRVc2VyID0gYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RVc2VyKHRlc3RVc2VyKTtcblxuICAgICAgY29uc3QgZm91bmRVc2VyID0gYXdhaXQgZ2V0VXNlckJ5SWQoY3JlYXRlZFVzZXIuaWQpO1xuXG4gICAgICBleHBlY3QoZm91bmRVc2VyKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGZvdW5kVXNlci5pZCkudG9CZShjcmVhdGVkVXNlci5pZCk7XG4gICAgICBleHBlY3QoZm91bmRVc2VyLmVtYWlsKS50b0JlKGNyZWF0ZWRVc2VyLmVtYWlsKTtcbiAgICAgIGV4cGVjdChmb3VuZFVzZXIubmFtZSkudG9CZShjcmVhdGVkVXNlci5uYW1lKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gbnVsbCBmb3Igbm9uLWV4aXN0ZW50IHVzZXIgSUQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgZ2V0VXNlckJ5SWQoOTk5OTkpO1xuICAgICAgZXhwZWN0KHVzZXIpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcHJldmVudCBkdXBsaWNhdGUgZW1haWwgcmVnaXN0cmF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZW1haWwgPSAnZHVwbGljYXRlQGV4YW1wbGUuY29tJztcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGZpcnN0IHVzZXJcbiAgICAgIGF3YWl0IGNyZWF0ZVVzZXIoZW1haWwsICdwYXNzd29yZDEnLCAnVXNlciAxJyk7XG4gICAgICBcbiAgICAgIC8vIEF0dGVtcHQgdG8gY3JlYXRlIHNlY29uZCB1c2VyIHdpdGggc2FtZSBlbWFpbCBzaG91bGQgZmFpbFxuICAgICAgYXdhaXQgZXhwZWN0KGNyZWF0ZVVzZXIoZW1haWwsICdwYXNzd29yZDInLCAnVXNlciAyJykpLnJlamVjdHMudG9UaHJvdygpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUGFzc3dvcmQgSGFzaGluZyBhbmQgVmVyaWZpY2F0aW9uJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBoYXNoIHBhc3N3b3JkcyBzZWN1cmVseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHBhc3N3b3JkID0gJ3Rlc3RwYXNzd29yZDEyMyc7XG4gICAgICBjb25zdCBoYXNoMSA9IGF3YWl0IGhhc2hQYXNzd29yZChwYXNzd29yZCk7XG4gICAgICBjb25zdCBoYXNoMiA9IGF3YWl0IGhhc2hQYXNzd29yZChwYXNzd29yZCk7XG5cbiAgICAgIGV4cGVjdChoYXNoMSkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChoYXNoMikudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChoYXNoMSkubm90LnRvQmUocGFzc3dvcmQpO1xuICAgICAgZXhwZWN0KGhhc2gyKS5ub3QudG9CZShwYXNzd29yZCk7XG4gICAgICBleHBlY3QoaGFzaDEpLm5vdC50b0JlKGhhc2gyKTsgLy8gU2hvdWxkIHVzZSBzYWx0LCBzbyBoYXNoZXMgZGlmZmVyXG4gICAgICBleHBlY3QoaGFzaDEubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oNTApOyAvLyBiY3J5cHQgaGFzaGVzIGFyZSBsb25nXG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgdmVyaWZ5IGNvcnJlY3QgcGFzc3dvcmRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcGFzc3dvcmQgPSAndGVzdHBhc3N3b3JkMTIzJztcbiAgICAgIGNvbnN0IGhhc2ggPSBhd2FpdCBoYXNoUGFzc3dvcmQocGFzc3dvcmQpO1xuXG4gICAgICBjb25zdCBpc1ZhbGlkID0gYXdhaXQgdmVyaWZ5UGFzc3dvcmQocGFzc3dvcmQsIGhhc2gpO1xuICAgICAgZXhwZWN0KGlzVmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmVqZWN0IGluY29ycmVjdCBwYXNzd29yZHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwYXNzd29yZCA9ICd0ZXN0cGFzc3dvcmQxMjMnO1xuICAgICAgY29uc3Qgd3JvbmdQYXNzd29yZCA9ICd3cm9uZ3Bhc3N3b3JkJztcbiAgICAgIGNvbnN0IGhhc2ggPSBhd2FpdCBoYXNoUGFzc3dvcmQocGFzc3dvcmQpO1xuXG4gICAgICBjb25zdCBpc1ZhbGlkID0gYXdhaXQgdmVyaWZ5UGFzc3dvcmQod3JvbmdQYXNzd29yZCwgaGFzaCk7XG4gICAgICBleHBlY3QoaXNWYWxpZCkudG9CZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIGVtcHR5IHBhc3N3b3JkcyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IGhhc2hQYXNzd29yZCgndmFsaWRwYXNzd29yZCcpO1xuICAgICAgXG4gICAgICBjb25zdCBpc1ZhbGlkID0gYXdhaXQgdmVyaWZ5UGFzc3dvcmQoJycsIGhhc2gpO1xuICAgICAgZXhwZWN0KGlzVmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU2Vzc2lvbiBNYW5hZ2VtZW50JywgKCkgPT4ge1xuICAgIHRlc3QoJ3Nob3VsZCBjcmVhdGUgc2Vzc2lvbiBmb3IgdXNlcicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RVc2VyID0gY3JlYXRlVGVzdFVzZXIoKTtcbiAgICAgIGNvbnN0IGNyZWF0ZWRVc2VyID0gYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RVc2VyKHRlc3RVc2VyKTtcblxuICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IGNyZWF0ZVNlc3Npb24oY3JlYXRlZFVzZXIuaWQpO1xuXG4gICAgICBleHBlY3Qoc2Vzc2lvbikudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChzZXNzaW9uLmlkKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHNlc3Npb24udXNlcklkKS50b0JlKGNyZWF0ZWRVc2VyLmlkKTtcbiAgICAgIGV4cGVjdChzZXNzaW9uLmV4cGlyZXNBdCkudG9CZUluc3RhbmNlT2YoRGF0ZSk7XG4gICAgICBleHBlY3Qoc2Vzc2lvbi5leHBpcmVzQXQuZ2V0VGltZSgpKS50b0JlR3JlYXRlclRoYW4oRGF0ZS5ub3coKSk7XG5cbiAgICAgIC8vIFRyYWNrIGZvciBjbGVhbnVwXG4gICAgICBkYk1hbmFnZXIuY3JlYXRlZFNlc3Npb25zLnB1c2goc2Vzc2lvbi5pZCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmV0cmlldmUgc2Vzc2lvbiBieSBJRCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RVc2VyID0gY3JlYXRlVGVzdFVzZXIoKTtcbiAgICAgIGNvbnN0IGNyZWF0ZWRVc2VyID0gYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RVc2VyKHRlc3RVc2VyKTtcbiAgICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBjcmVhdGVTZXNzaW9uKGNyZWF0ZWRVc2VyLmlkKTtcbiAgICAgIGRiTWFuYWdlci5jcmVhdGVkU2Vzc2lvbnMucHVzaChzZXNzaW9uLmlkKTtcblxuICAgICAgY29uc3QgZm91bmRTZXNzaW9uID0gYXdhaXQgZGJNYW5hZ2VyLmdldFNlc3Npb25CeUlkKHNlc3Npb24uaWQpO1xuXG4gICAgICBleHBlY3QoZm91bmRTZXNzaW9uKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGZvdW5kU2Vzc2lvbi5pZCkudG9CZShzZXNzaW9uLmlkKTtcbiAgICAgIGV4cGVjdChmb3VuZFNlc3Npb24udXNlcklkKS50b0JlKGNyZWF0ZWRVc2VyLmlkKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZXRyaWV2ZSBzZXNzaW9ucyBieSB1c2VyIElEJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFVzZXIgPSBjcmVhdGVUZXN0VXNlcigpO1xuICAgICAgY29uc3QgY3JlYXRlZFVzZXIgPSBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdFVzZXIodGVzdFVzZXIpO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgbXVsdGlwbGUgc2Vzc2lvbnMgZm9yIHRoZSB1c2VyXG4gICAgICBjb25zdCBzZXNzaW9uMSA9IGF3YWl0IGNyZWF0ZVNlc3Npb24oY3JlYXRlZFVzZXIuaWQpO1xuICAgICAgY29uc3Qgc2Vzc2lvbjIgPSBhd2FpdCBjcmVhdGVTZXNzaW9uKGNyZWF0ZWRVc2VyLmlkKTtcbiAgICAgIGRiTWFuYWdlci5jcmVhdGVkU2Vzc2lvbnMucHVzaChzZXNzaW9uMS5pZCwgc2Vzc2lvbjIuaWQpO1xuXG4gICAgICBjb25zdCB1c2VyU2Vzc2lvbnMgPSBhd2FpdCBkYk1hbmFnZXIuZ2V0U2Vzc2lvbnNCeVVzZXJJZChjcmVhdGVkVXNlci5pZCk7XG5cbiAgICAgIGV4cGVjdCh1c2VyU2Vzc2lvbnMpLnRvSGF2ZUxlbmd0aCgyKTtcbiAgICAgIGV4cGVjdCh1c2VyU2Vzc2lvbnMubWFwKHMgPT4gcy5pZCkpLnRvQ29udGFpbihzZXNzaW9uMS5pZCk7XG4gICAgICBleHBlY3QodXNlclNlc3Npb25zLm1hcChzID0+IHMuaWQpKS50b0NvbnRhaW4oc2Vzc2lvbjIuaWQpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGludmFsaWRhdGUgc2Vzc2lvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RVc2VyID0gY3JlYXRlVGVzdFVzZXIoKTtcbiAgICAgIGNvbnN0IGNyZWF0ZWRVc2VyID0gYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RVc2VyKHRlc3RVc2VyKTtcbiAgICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBjcmVhdGVTZXNzaW9uKGNyZWF0ZWRVc2VyLmlkKTtcbiAgICAgIGRiTWFuYWdlci5jcmVhdGVkU2Vzc2lvbnMucHVzaChzZXNzaW9uLmlkKTtcblxuICAgICAgLy8gVmVyaWZ5IHNlc3Npb24gZXhpc3RzXG4gICAgICBsZXQgZm91bmRTZXNzaW9uID0gYXdhaXQgZGJNYW5hZ2VyLmdldFNlc3Npb25CeUlkKHNlc3Npb24uaWQpO1xuICAgICAgZXhwZWN0KGZvdW5kU2Vzc2lvbikudG9CZURlZmluZWQoKTtcblxuICAgICAgLy8gSW52YWxpZGF0ZSBzZXNzaW9uXG4gICAgICBhd2FpdCBpbnZhbGlkYXRlU2Vzc2lvbihzZXNzaW9uLmlkKTtcblxuICAgICAgLy8gU2Vzc2lvbiBzaG91bGQgbm8gbG9uZ2VyIGV4aXN0XG4gICAgICBmb3VuZFNlc3Npb24gPSBhd2FpdCBkYk1hbmFnZXIuZ2V0U2Vzc2lvbkJ5SWQoc2Vzc2lvbi5pZCk7XG4gICAgICBleHBlY3QoZm91bmRTZXNzaW9uKS50b0JlTnVsbCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQXV0aGVudGljYXRpb24gRmxvd3MnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHNpZ24gaW4gd2l0aCB2YWxpZCBjcmVkZW50aWFscycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGVtYWlsID0gJ3NpZ25pbkBleGFtcGxlLmNvbSc7XG4gICAgICBjb25zdCBwYXNzd29yZCA9ICd0ZXN0cGFzc3dvcmQxMjMnO1xuICAgICAgY29uc3QgbmFtZSA9ICdTaWduIEluIFVzZXInO1xuXG4gICAgICAvLyBDcmVhdGUgdXNlciBmaXJzdFxuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGNyZWF0ZVVzZXIoZW1haWwsIHBhc3N3b3JkLCBuYW1lKTtcbiAgICAgIGRiTWFuYWdlci5jcmVhdGVkVXNlcnMucHVzaCh1c2VyLmlkKTtcblxuICAgICAgLy8gQXR0ZW1wdCBzaWduIGluXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW4oZW1haWwsIHBhc3N3b3JkKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQudXNlcikudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc2Vzc2lvbikudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQudXNlci5pZCkudG9CZSh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdChyZXN1bHQudXNlci5lbWFpbCkudG9CZShlbWFpbC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc2Vzc2lvbi51c2VySWQpLnRvQmUodXNlci5pZCk7XG4gICAgICBleHBlY3QocmVzdWx0LnNlc3Npb24uaWQpLnRvQmVEZWZpbmVkKCk7XG5cbiAgICAgIC8vIFRyYWNrIHNlc3Npb24gZm9yIGNsZWFudXBcbiAgICAgIGRiTWFuYWdlci5jcmVhdGVkU2Vzc2lvbnMucHVzaChyZXN1bHQuc2Vzc2lvbi5pZCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgcmVqZWN0IHNpZ24gaW4gd2l0aCBpbnZhbGlkIGVtYWlsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnbkluKCdub25leGlzdGVudEBleGFtcGxlLmNvbScsICdwYXNzd29yZCcpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZWplY3Qgc2lnbiBpbiB3aXRoIGludmFsaWQgcGFzc3dvcmQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBlbWFpbCA9ICdzaWduaW4yQGV4YW1wbGUuY29tJztcbiAgICAgIGNvbnN0IHBhc3N3b3JkID0gJ2NvcnJlY3RwYXNzd29yZCc7XG4gICAgICBjb25zdCB3cm9uZ1Bhc3N3b3JkID0gJ3dyb25ncGFzc3dvcmQnO1xuXG4gICAgICAvLyBDcmVhdGUgdXNlclxuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGNyZWF0ZVVzZXIoZW1haWwsIHBhc3N3b3JkLCAnVGVzdCBVc2VyJyk7XG4gICAgICBkYk1hbmFnZXIuY3JlYXRlZFVzZXJzLnB1c2godXNlci5pZCk7XG5cbiAgICAgIC8vIEF0dGVtcHQgc2lnbiBpbiB3aXRoIHdyb25nIHBhc3N3b3JkXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW4oZW1haWwsIHdyb25nUGFzc3dvcmQpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCBzaWduIHVwIG5ldyB1c2VyIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGVtYWlsID0gJ3NpZ251cEBleGFtcGxlLmNvbSc7XG4gICAgICBjb25zdCBwYXNzd29yZCA9ICd0ZXN0cGFzc3dvcmQxMjMnO1xuICAgICAgY29uc3QgbmFtZSA9ICdTaWduIFVwIFVzZXInO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduVXAoZW1haWwsIHBhc3N3b3JkLCBuYW1lKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQudXNlcikudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc2Vzc2lvbikudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQudXNlci5lbWFpbCkudG9CZShlbWFpbC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIGV4cGVjdChyZXN1bHQudXNlci5uYW1lKS50b0JlKG5hbWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5zZXNzaW9uLnVzZXJJZCkudG9CZShyZXN1bHQudXNlci5pZCk7XG5cbiAgICAgIC8vIFRyYWNrIGZvciBjbGVhbnVwXG4gICAgICBkYk1hbmFnZXIuY3JlYXRlZFVzZXJzLnB1c2gocmVzdWx0LnVzZXIuaWQpO1xuICAgICAgZGJNYW5hZ2VyLmNyZWF0ZWRTZXNzaW9ucy5wdXNoKHJlc3VsdC5zZXNzaW9uLmlkKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Nob3VsZCByZWplY3Qgc2lnbiB1cCB3aXRoIGV4aXN0aW5nIGVtYWlsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZW1haWwgPSAnZXhpc3RpbmdAZXhhbXBsZS5jb20nO1xuICAgICAgY29uc3QgcGFzc3dvcmQgPSAndGVzdHBhc3N3b3JkMTIzJztcblxuICAgICAgLy8gQ3JlYXRlIGZpcnN0IHVzZXJcbiAgICAgIGNvbnN0IHVzZXIxID0gYXdhaXQgY3JlYXRlVXNlcihlbWFpbCwgcGFzc3dvcmQsICdGaXJzdCBVc2VyJyk7XG4gICAgICBkYk1hbmFnZXIuY3JlYXRlZFVzZXJzLnB1c2godXNlcjEuaWQpO1xuXG4gICAgICAvLyBBdHRlbXB0IHRvIHNpZ24gdXAgd2l0aCBzYW1lIGVtYWlsXG4gICAgICBhd2FpdCBleHBlY3Qoc2lnblVwKGVtYWlsLCBwYXNzd29yZCwgJ1NlY29uZCBVc2VyJykpLnJlamVjdHMudG9UaHJvdygnVXNlciBhbHJlYWR5IGV4aXN0cycpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBjYXNlIGluc2Vuc2l0aXZlIGVtYWlsIGluIHNpZ24gaW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBlbWFpbCA9ICdDYXNlVGVzdEBFeGFtcGxlLkNPTSc7XG4gICAgICBjb25zdCBwYXNzd29yZCA9ICd0ZXN0cGFzc3dvcmQxMjMnO1xuXG4gICAgICAvLyBDcmVhdGUgdXNlciB3aXRoIG1peGVkIGNhc2UgZW1haWxcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBjcmVhdGVVc2VyKGVtYWlsLCBwYXNzd29yZCwgJ0Nhc2UgVGVzdCBVc2VyJyk7XG4gICAgICBkYk1hbmFnZXIuY3JlYXRlZFVzZXJzLnB1c2godXNlci5pZCk7XG5cbiAgICAgIC8vIFNpZ24gaW4gd2l0aCBkaWZmZXJlbnQgY2FzZVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnbkluKCdjYXNldGVzdEBleGFtcGxlLmNvbScsIHBhc3N3b3JkKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQudXNlci5pZCkudG9CZSh1c2VyLmlkKTtcblxuICAgICAgLy8gVHJhY2sgc2Vzc2lvbiBmb3IgY2xlYW51cFxuICAgICAgZGJNYW5hZ2VyLmNyZWF0ZWRTZXNzaW9ucy5wdXNoKHJlc3VsdC5zZXNzaW9uLmlkKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0VtYWlsIFZlcmlmaWNhdGlvbiBDb2RlIE1hbmFnZW1lbnQnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIGNyZWF0ZSBhbmQgcmV0cmlldmUgZW1haWwgdmVyaWZpY2F0aW9uIGNvZGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFVzZXIgPSBjcmVhdGVUZXN0VXNlcigpO1xuICAgICAgY29uc3QgY3JlYXRlZFVzZXIgPSBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdFVzZXIodGVzdFVzZXIpO1xuXG4gICAgICBjb25zdCBjb2RlRGF0YSA9IHtcbiAgICAgICAgdXNlcklkOiBjcmVhdGVkVXNlci5pZCxcbiAgICAgICAgY29kZTogJzEyMzQ1NicsXG4gICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIDE1ICogNjAgKiAxMDAwKSwgLy8gMTUgbWludXRlc1xuICAgICAgICBhdHRlbXB0c1VzZWQ6IDAsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBjcmVhdGVkQ29kZSA9IGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0RW1haWxDb2RlKGNvZGVEYXRhKTtcblxuICAgICAgZXhwZWN0KGNyZWF0ZWRDb2RlKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGNyZWF0ZWRDb2RlLnVzZXJJZCkudG9CZShjcmVhdGVkVXNlci5pZCk7XG4gICAgICBleHBlY3QoY3JlYXRlZENvZGUuY29kZSkudG9CZSgnMTIzNDU2Jyk7XG4gICAgICBleHBlY3QoY3JlYXRlZENvZGUuZXhwaXJlc0F0KS50b0JlSW5zdGFuY2VPZihEYXRlKTtcblxuICAgICAgLy8gUmV0cmlldmUgY29kZXMgZm9yIHVzZXJcbiAgICAgIGNvbnN0IHVzZXJDb2RlcyA9IGF3YWl0IGRiTWFuYWdlci5nZXRFbWFpbENvZGVzQnlVc2VySWQoY3JlYXRlZFVzZXIuaWQpO1xuICAgICAgZXhwZWN0KHVzZXJDb2RlcykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KHVzZXJDb2Rlc1swXS5pZCkudG9CZShjcmVhdGVkQ29kZS5pZCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdzaG91bGQgaGFuZGxlIG11bHRpcGxlIHZlcmlmaWNhdGlvbiBjb2RlcyBmb3IgdXNlcicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RVc2VyID0gY3JlYXRlVGVzdFVzZXIoKTtcbiAgICAgIGNvbnN0IGNyZWF0ZWRVc2VyID0gYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RVc2VyKHRlc3RVc2VyKTtcblxuICAgICAgLy8gQ3JlYXRlIG11bHRpcGxlIGNvZGVzIChzaW11bGF0aW5nIGNvZGUgcmVnZW5lcmF0aW9uKVxuICAgICAgY29uc3QgY29kZTEgPSBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdEVtYWlsQ29kZSh7XG4gICAgICAgIHVzZXJJZDogY3JlYXRlZFVzZXIuaWQsXG4gICAgICAgIGNvZGU6ICcxMTExMTEnLFxuICAgICAgICBleHBpcmVzQXQ6IG5ldyBEYXRlKERhdGUubm93KCkgKyAxNSAqIDYwICogMTAwMCksXG4gICAgICAgIGF0dGVtcHRzVXNlZDogMCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBjb2RlMiA9IGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0RW1haWxDb2RlKHtcbiAgICAgICAgdXNlcklkOiBjcmVhdGVkVXNlci5pZCxcbiAgICAgICAgY29kZTogJzIyMjIyMicsXG4gICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIDE1ICogNjAgKiAxMDAwKSxcbiAgICAgICAgYXR0ZW1wdHNVc2VkOiAwLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHVzZXJDb2RlcyA9IGF3YWl0IGRiTWFuYWdlci5nZXRFbWFpbENvZGVzQnlVc2VySWQoY3JlYXRlZFVzZXIuaWQpO1xuICAgICAgZXhwZWN0KHVzZXJDb2RlcykudG9IYXZlTGVuZ3RoKDIpO1xuICAgICAgZXhwZWN0KHVzZXJDb2Rlcy5tYXAoYyA9PiBjLmNvZGUpKS50b0NvbnRhaW4oJzExMTExMScpO1xuICAgICAgZXhwZWN0KHVzZXJDb2Rlcy5tYXAoYyA9PiBjLmNvZGUpKS50b0NvbnRhaW4oJzIyMjIyMicpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRGF0YWJhc2UgQ29ubmVjdGlvbiBhbmQgRXJyb3IgSGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgdGVzdCgnc2hvdWxkIHZlcmlmeSBkYXRhYmFzZSBjb25uZWN0aW9uIGlzIHdvcmtpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpc0Nvbm5lY3RlZCA9IGF3YWl0IGRiTWFuYWdlci5pc0Nvbm5lY3RlZCgpO1xuICAgICAgZXhwZWN0KGlzQ29ubmVjdGVkKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnc2hvdWxkIGhhbmRsZSBkYXRhYmFzZSBjb25zdHJhaW50IHZpb2xhdGlvbnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGVtYWlsID0gJ2NvbnN0cmFpbnRAZXhhbXBsZS5jb20nO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgZmlyc3QgdXNlclxuICAgICAgY29uc3QgdXNlcjEgPSBhd2FpdCBjcmVhdGVVc2VyKGVtYWlsLCAncGFzc3dvcmQxJywgJ1VzZXIgMScpO1xuICAgICAgZGJNYW5hZ2VyLmNyZWF0ZWRVc2Vycy5wdXNoKHVzZXIxLmlkKTtcblxuICAgICAgLy8gQXR0ZW1wdCB0byBjcmVhdGUgZHVwbGljYXRlIHNob3VsZCB0aHJvdyBlcnJvclxuICAgICAgYXdhaXQgZXhwZWN0KGNyZWF0ZVVzZXIoZW1haWwsICdwYXNzd29yZDInLCAnVXNlciAyJykpLnJlamVjdHMudG9UaHJvdygpO1xuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJkZXNjcmliZSIsImRiTWFuYWdlciIsImJlZm9yZUVhY2giLCJjcmVhdGVEYXRhYmFzZVRlc3RNYW5hZ2VyIiwiYWZ0ZXJFYWNoIiwiY2xlYW51cCIsInRlc3QiLCJlbWFpbCIsInBhc3N3b3JkIiwibmFtZSIsInVzZXIiLCJjcmVhdGVVc2VyIiwiZXhwZWN0IiwidG9CZURlZmluZWQiLCJpZCIsInRvQmUiLCJ0b0xvd2VyQ2FzZSIsImhhc2hlZFBhc3N3b3JkIiwibm90IiwiaXNDdXJhdG9yIiwiaXNFbWFpbFZlcmlmaWVkIiwiY3JlYXRlZEF0IiwidG9CZUluc3RhbmNlT2YiLCJEYXRlIiwidXBkYXRlZEF0IiwiY3JlYXRlZFVzZXJzIiwicHVzaCIsInRlc3RVc2VyIiwiY3JlYXRlVGVzdFVzZXIiLCJjcmVhdGVkVXNlciIsImZvdW5kVXNlcjEiLCJnZXRVc2VyQnlFbWFpbCIsImZvdW5kVXNlcjIiLCJmb3VuZFVzZXIzIiwidG9CZU51bGwiLCJmb3VuZFVzZXIiLCJnZXRVc2VyQnlJZCIsInJlamVjdHMiLCJ0b1Rocm93IiwiaGFzaDEiLCJoYXNoUGFzc3dvcmQiLCJoYXNoMiIsImxlbmd0aCIsInRvQmVHcmVhdGVyVGhhbiIsImhhc2giLCJpc1ZhbGlkIiwidmVyaWZ5UGFzc3dvcmQiLCJ3cm9uZ1Bhc3N3b3JkIiwic2Vzc2lvbiIsImNyZWF0ZVNlc3Npb24iLCJ1c2VySWQiLCJleHBpcmVzQXQiLCJnZXRUaW1lIiwibm93IiwiY3JlYXRlZFNlc3Npb25zIiwiZm91bmRTZXNzaW9uIiwiZ2V0U2Vzc2lvbkJ5SWQiLCJzZXNzaW9uMSIsInNlc3Npb24yIiwidXNlclNlc3Npb25zIiwiZ2V0U2Vzc2lvbnNCeVVzZXJJZCIsInRvSGF2ZUxlbmd0aCIsIm1hcCIsInMiLCJ0b0NvbnRhaW4iLCJpbnZhbGlkYXRlU2Vzc2lvbiIsInJlc3VsdCIsInNpZ25JbiIsInNpZ25VcCIsInVzZXIxIiwiY29kZURhdGEiLCJjb2RlIiwiYXR0ZW1wdHNVc2VkIiwiY3JlYXRlZENvZGUiLCJjcmVhdGVUZXN0RW1haWxDb2RlIiwidXNlckNvZGVzIiwiZ2V0RW1haWxDb2Rlc0J5VXNlcklkIiwiY29kZTEiLCJjb2RlMiIsImMiLCJpc0Nvbm5lY3RlZCJdLCJtYXBwaW5ncyI6IkFBQUE7OztDQUdDOzs7O3NCQVlNO3FDQUNtQzs2QkFDbUM7QUFFN0VBLFNBQVMsNENBQTRDO0lBQ25ELElBQUlDO0lBRUpDLFdBQVc7UUFDVEQsWUFBWUUsSUFBQUEsOENBQXlCO0lBQ3ZDO0lBRUFDLFVBQVU7UUFDUixNQUFNSCxVQUFVSSxPQUFPO0lBQ3pCO0lBRUFMLFNBQVMsK0JBQStCO1FBQ3RDTSxLQUFLLGlEQUFpRDtZQUNwRCxNQUFNQyxRQUFRO1lBQ2QsTUFBTUMsV0FBVztZQUNqQixNQUFNQyxPQUFPO1lBRWIsTUFBTUMsT0FBTyxNQUFNQyxJQUFBQSxnQkFBVSxFQUFDSixPQUFPQyxVQUFVQztZQUUvQ0csT0FBT0YsTUFBTUcsV0FBVztZQUN4QkQsT0FBT0YsS0FBS0ksRUFBRSxFQUFFRCxXQUFXO1lBQzNCRCxPQUFPRixLQUFLSCxLQUFLLEVBQUVRLElBQUksQ0FBQ1IsTUFBTVMsV0FBVztZQUN6Q0osT0FBT0YsS0FBS0QsSUFBSSxFQUFFTSxJQUFJLENBQUNOO1lBQ3ZCRyxPQUFPRixLQUFLTyxjQUFjLEVBQUVKLFdBQVc7WUFDdkNELE9BQU9GLEtBQUtPLGNBQWMsRUFBRUMsR0FBRyxDQUFDSCxJQUFJLENBQUNQLFdBQVcsbUJBQW1CO1lBQ25FSSxPQUFPRixLQUFLUyxTQUFTLEVBQUVKLElBQUksQ0FBQztZQUM1QkgsT0FBT0YsS0FBS1UsZUFBZSxFQUFFTCxJQUFJLENBQUM7WUFDbENILE9BQU9GLEtBQUtXLFNBQVMsRUFBRUMsY0FBYyxDQUFDQztZQUN0Q1gsT0FBT0YsS0FBS2MsU0FBUyxFQUFFRixjQUFjLENBQUNDO1lBRXRDLG9CQUFvQjtZQUNwQnRCLFVBQVV3QixZQUFZLENBQUNDLElBQUksQ0FBQ2hCLEtBQUtJLEVBQUU7UUFDckM7UUFFQVIsS0FBSyxvREFBb0Q7WUFDdkQsTUFBTXFCLFdBQVdDLElBQUFBLDJCQUFjLEVBQUM7Z0JBQzlCckIsT0FBTztZQUNUO1lBRUEsTUFBTXNCLGNBQWMsTUFBTTVCLFVBQVUyQixjQUFjLENBQUNEO1lBRW5ELGtDQUFrQztZQUNsQyxNQUFNRyxhQUFhLE1BQU1DLElBQUFBLG9CQUFjLEVBQUM7WUFDeEMsTUFBTUMsYUFBYSxNQUFNRCxJQUFBQSxvQkFBYyxFQUFDO1lBQ3hDLE1BQU1FLGFBQWEsTUFBTUYsSUFBQUEsb0JBQWMsRUFBQztZQUV4Q25CLE9BQU9rQixZQUFZakIsV0FBVztZQUM5QkQsT0FBT29CLFlBQVluQixXQUFXO1lBQzlCRCxPQUFPcUIsWUFBWXBCLFdBQVc7WUFDOUJELE9BQU9rQixXQUFXaEIsRUFBRSxFQUFFQyxJQUFJLENBQUNjLFlBQVlmLEVBQUU7WUFDekNGLE9BQU9vQixXQUFXbEIsRUFBRSxFQUFFQyxJQUFJLENBQUNjLFlBQVlmLEVBQUU7WUFDekNGLE9BQU9xQixXQUFXbkIsRUFBRSxFQUFFQyxJQUFJLENBQUNjLFlBQVlmLEVBQUU7UUFDM0M7UUFFQVIsS0FBSyw2Q0FBNkM7WUFDaEQsTUFBTUksT0FBTyxNQUFNcUIsSUFBQUEsb0JBQWMsRUFBQztZQUNsQ25CLE9BQU9GLE1BQU13QixRQUFRO1FBQ3ZCO1FBRUE1QixLQUFLLDhCQUE4QjtZQUNqQyxNQUFNcUIsV0FBV0MsSUFBQUEsMkJBQWM7WUFDL0IsTUFBTUMsY0FBYyxNQUFNNUIsVUFBVTJCLGNBQWMsQ0FBQ0Q7WUFFbkQsTUFBTVEsWUFBWSxNQUFNQyxJQUFBQSxpQkFBVyxFQUFDUCxZQUFZZixFQUFFO1lBRWxERixPQUFPdUIsV0FBV3RCLFdBQVc7WUFDN0JELE9BQU91QixVQUFVckIsRUFBRSxFQUFFQyxJQUFJLENBQUNjLFlBQVlmLEVBQUU7WUFDeENGLE9BQU91QixVQUFVNUIsS0FBSyxFQUFFUSxJQUFJLENBQUNjLFlBQVl0QixLQUFLO1lBQzlDSyxPQUFPdUIsVUFBVTFCLElBQUksRUFBRU0sSUFBSSxDQUFDYyxZQUFZcEIsSUFBSTtRQUM5QztRQUVBSCxLQUFLLCtDQUErQztZQUNsRCxNQUFNSSxPQUFPLE1BQU0wQixJQUFBQSxpQkFBVyxFQUFDO1lBQy9CeEIsT0FBT0YsTUFBTXdCLFFBQVE7UUFDdkI7UUFFQTVCLEtBQUssK0NBQStDO1lBQ2xELE1BQU1DLFFBQVE7WUFFZCxvQkFBb0I7WUFDcEIsTUFBTUksSUFBQUEsZ0JBQVUsRUFBQ0osT0FBTyxhQUFhO1lBRXJDLDREQUE0RDtZQUM1RCxNQUFNSyxPQUFPRCxJQUFBQSxnQkFBVSxFQUFDSixPQUFPLGFBQWEsV0FBVzhCLE9BQU8sQ0FBQ0MsT0FBTztRQUN4RTtJQUNGO0lBRUF0QyxTQUFTLHFDQUFxQztRQUM1Q00sS0FBSyxrQ0FBa0M7WUFDckMsTUFBTUUsV0FBVztZQUNqQixNQUFNK0IsUUFBUSxNQUFNQyxJQUFBQSxrQkFBWSxFQUFDaEM7WUFDakMsTUFBTWlDLFFBQVEsTUFBTUQsSUFBQUEsa0JBQVksRUFBQ2hDO1lBRWpDSSxPQUFPMkIsT0FBTzFCLFdBQVc7WUFDekJELE9BQU82QixPQUFPNUIsV0FBVztZQUN6QkQsT0FBTzJCLE9BQU9yQixHQUFHLENBQUNILElBQUksQ0FBQ1A7WUFDdkJJLE9BQU82QixPQUFPdkIsR0FBRyxDQUFDSCxJQUFJLENBQUNQO1lBQ3ZCSSxPQUFPMkIsT0FBT3JCLEdBQUcsQ0FBQ0gsSUFBSSxDQUFDMEIsUUFBUSxvQ0FBb0M7WUFDbkU3QixPQUFPMkIsTUFBTUcsTUFBTSxFQUFFQyxlQUFlLENBQUMsS0FBSyx5QkFBeUI7UUFDckU7UUFFQXJDLEtBQUssbUNBQW1DO1lBQ3RDLE1BQU1FLFdBQVc7WUFDakIsTUFBTW9DLE9BQU8sTUFBTUosSUFBQUEsa0JBQVksRUFBQ2hDO1lBRWhDLE1BQU1xQyxVQUFVLE1BQU1DLElBQUFBLG9CQUFjLEVBQUN0QyxVQUFVb0M7WUFDL0NoQyxPQUFPaUMsU0FBUzlCLElBQUksQ0FBQztRQUN2QjtRQUVBVCxLQUFLLHFDQUFxQztZQUN4QyxNQUFNRSxXQUFXO1lBQ2pCLE1BQU11QyxnQkFBZ0I7WUFDdEIsTUFBTUgsT0FBTyxNQUFNSixJQUFBQSxrQkFBWSxFQUFDaEM7WUFFaEMsTUFBTXFDLFVBQVUsTUFBTUMsSUFBQUEsb0JBQWMsRUFBQ0MsZUFBZUg7WUFDcERoQyxPQUFPaUMsU0FBUzlCLElBQUksQ0FBQztRQUN2QjtRQUVBVCxLQUFLLDRDQUE0QztZQUMvQyxNQUFNc0MsT0FBTyxNQUFNSixJQUFBQSxrQkFBWSxFQUFDO1lBRWhDLE1BQU1LLFVBQVUsTUFBTUMsSUFBQUEsb0JBQWMsRUFBQyxJQUFJRjtZQUN6Q2hDLE9BQU9pQyxTQUFTOUIsSUFBSSxDQUFDO1FBQ3ZCO0lBQ0Y7SUFFQWYsU0FBUyxzQkFBc0I7UUFDN0JNLEtBQUssa0NBQWtDO1lBQ3JDLE1BQU1xQixXQUFXQyxJQUFBQSwyQkFBYztZQUMvQixNQUFNQyxjQUFjLE1BQU01QixVQUFVMkIsY0FBYyxDQUFDRDtZQUVuRCxNQUFNcUIsVUFBVSxNQUFNQyxJQUFBQSxtQkFBYSxFQUFDcEIsWUFBWWYsRUFBRTtZQUVsREYsT0FBT29DLFNBQVNuQyxXQUFXO1lBQzNCRCxPQUFPb0MsUUFBUWxDLEVBQUUsRUFBRUQsV0FBVztZQUM5QkQsT0FBT29DLFFBQVFFLE1BQU0sRUFBRW5DLElBQUksQ0FBQ2MsWUFBWWYsRUFBRTtZQUMxQ0YsT0FBT29DLFFBQVFHLFNBQVMsRUFBRTdCLGNBQWMsQ0FBQ0M7WUFDekNYLE9BQU9vQyxRQUFRRyxTQUFTLENBQUNDLE9BQU8sSUFBSVQsZUFBZSxDQUFDcEIsS0FBSzhCLEdBQUc7WUFFNUQsb0JBQW9CO1lBQ3BCcEQsVUFBVXFELGVBQWUsQ0FBQzVCLElBQUksQ0FBQ3NCLFFBQVFsQyxFQUFFO1FBQzNDO1FBRUFSLEtBQUssaUNBQWlDO1lBQ3BDLE1BQU1xQixXQUFXQyxJQUFBQSwyQkFBYztZQUMvQixNQUFNQyxjQUFjLE1BQU01QixVQUFVMkIsY0FBYyxDQUFDRDtZQUNuRCxNQUFNcUIsVUFBVSxNQUFNQyxJQUFBQSxtQkFBYSxFQUFDcEIsWUFBWWYsRUFBRTtZQUNsRGIsVUFBVXFELGVBQWUsQ0FBQzVCLElBQUksQ0FBQ3NCLFFBQVFsQyxFQUFFO1lBRXpDLE1BQU15QyxlQUFlLE1BQU10RCxVQUFVdUQsY0FBYyxDQUFDUixRQUFRbEMsRUFBRTtZQUU5REYsT0FBTzJDLGNBQWMxQyxXQUFXO1lBQ2hDRCxPQUFPMkMsYUFBYXpDLEVBQUUsRUFBRUMsSUFBSSxDQUFDaUMsUUFBUWxDLEVBQUU7WUFDdkNGLE9BQU8yQyxhQUFhTCxNQUFNLEVBQUVuQyxJQUFJLENBQUNjLFlBQVlmLEVBQUU7UUFDakQ7UUFFQVIsS0FBSyx1Q0FBdUM7WUFDMUMsTUFBTXFCLFdBQVdDLElBQUFBLDJCQUFjO1lBQy9CLE1BQU1DLGNBQWMsTUFBTTVCLFVBQVUyQixjQUFjLENBQUNEO1lBRW5ELHdDQUF3QztZQUN4QyxNQUFNOEIsV0FBVyxNQUFNUixJQUFBQSxtQkFBYSxFQUFDcEIsWUFBWWYsRUFBRTtZQUNuRCxNQUFNNEMsV0FBVyxNQUFNVCxJQUFBQSxtQkFBYSxFQUFDcEIsWUFBWWYsRUFBRTtZQUNuRGIsVUFBVXFELGVBQWUsQ0FBQzVCLElBQUksQ0FBQytCLFNBQVMzQyxFQUFFLEVBQUU0QyxTQUFTNUMsRUFBRTtZQUV2RCxNQUFNNkMsZUFBZSxNQUFNMUQsVUFBVTJELG1CQUFtQixDQUFDL0IsWUFBWWYsRUFBRTtZQUV2RUYsT0FBTytDLGNBQWNFLFlBQVksQ0FBQztZQUNsQ2pELE9BQU8rQyxhQUFhRyxHQUFHLENBQUNDLENBQUFBLElBQUtBLEVBQUVqRCxFQUFFLEdBQUdrRCxTQUFTLENBQUNQLFNBQVMzQyxFQUFFO1lBQ3pERixPQUFPK0MsYUFBYUcsR0FBRyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFakQsRUFBRSxHQUFHa0QsU0FBUyxDQUFDTixTQUFTNUMsRUFBRTtRQUMzRDtRQUVBUixLQUFLLDZCQUE2QjtZQUNoQyxNQUFNcUIsV0FBV0MsSUFBQUEsMkJBQWM7WUFDL0IsTUFBTUMsY0FBYyxNQUFNNUIsVUFBVTJCLGNBQWMsQ0FBQ0Q7WUFDbkQsTUFBTXFCLFVBQVUsTUFBTUMsSUFBQUEsbUJBQWEsRUFBQ3BCLFlBQVlmLEVBQUU7WUFDbERiLFVBQVVxRCxlQUFlLENBQUM1QixJQUFJLENBQUNzQixRQUFRbEMsRUFBRTtZQUV6Qyx3QkFBd0I7WUFDeEIsSUFBSXlDLGVBQWUsTUFBTXRELFVBQVV1RCxjQUFjLENBQUNSLFFBQVFsQyxFQUFFO1lBQzVERixPQUFPMkMsY0FBYzFDLFdBQVc7WUFFaEMscUJBQXFCO1lBQ3JCLE1BQU1vRCxJQUFBQSx1QkFBaUIsRUFBQ2pCLFFBQVFsQyxFQUFFO1lBRWxDLGlDQUFpQztZQUNqQ3lDLGVBQWUsTUFBTXRELFVBQVV1RCxjQUFjLENBQUNSLFFBQVFsQyxFQUFFO1lBQ3hERixPQUFPMkMsY0FBY3JCLFFBQVE7UUFDL0I7SUFDRjtJQUVBbEMsU0FBUyx3QkFBd0I7UUFDL0JNLEtBQUsseUNBQXlDO1lBQzVDLE1BQU1DLFFBQVE7WUFDZCxNQUFNQyxXQUFXO1lBQ2pCLE1BQU1DLE9BQU87WUFFYixvQkFBb0I7WUFDcEIsTUFBTUMsT0FBTyxNQUFNQyxJQUFBQSxnQkFBVSxFQUFDSixPQUFPQyxVQUFVQztZQUMvQ1IsVUFBVXdCLFlBQVksQ0FBQ0MsSUFBSSxDQUFDaEIsS0FBS0ksRUFBRTtZQUVuQyxrQkFBa0I7WUFDbEIsTUFBTW9ELFNBQVMsTUFBTUMsSUFBQUEsWUFBTSxFQUFDNUQsT0FBT0M7WUFFbkNJLE9BQU9zRCxRQUFRckQsV0FBVztZQUMxQkQsT0FBT3NELE9BQU94RCxJQUFJLEVBQUVHLFdBQVc7WUFDL0JELE9BQU9zRCxPQUFPbEIsT0FBTyxFQUFFbkMsV0FBVztZQUNsQ0QsT0FBT3NELE9BQU94RCxJQUFJLENBQUNJLEVBQUUsRUFBRUMsSUFBSSxDQUFDTCxLQUFLSSxFQUFFO1lBQ25DRixPQUFPc0QsT0FBT3hELElBQUksQ0FBQ0gsS0FBSyxFQUFFUSxJQUFJLENBQUNSLE1BQU1TLFdBQVc7WUFDaERKLE9BQU9zRCxPQUFPbEIsT0FBTyxDQUFDRSxNQUFNLEVBQUVuQyxJQUFJLENBQUNMLEtBQUtJLEVBQUU7WUFDMUNGLE9BQU9zRCxPQUFPbEIsT0FBTyxDQUFDbEMsRUFBRSxFQUFFRCxXQUFXO1lBRXJDLDRCQUE0QjtZQUM1QlosVUFBVXFELGVBQWUsQ0FBQzVCLElBQUksQ0FBQ3dDLE9BQU9sQixPQUFPLENBQUNsQyxFQUFFO1FBQ2xEO1FBRUFSLEtBQUssNENBQTRDO1lBQy9DLE1BQU00RCxTQUFTLE1BQU1DLElBQUFBLFlBQU0sRUFBQywyQkFBMkI7WUFDdkR2RCxPQUFPc0QsUUFBUWhDLFFBQVE7UUFDekI7UUFFQTVCLEtBQUssK0NBQStDO1lBQ2xELE1BQU1DLFFBQVE7WUFDZCxNQUFNQyxXQUFXO1lBQ2pCLE1BQU11QyxnQkFBZ0I7WUFFdEIsY0FBYztZQUNkLE1BQU1yQyxPQUFPLE1BQU1DLElBQUFBLGdCQUFVLEVBQUNKLE9BQU9DLFVBQVU7WUFDL0NQLFVBQVV3QixZQUFZLENBQUNDLElBQUksQ0FBQ2hCLEtBQUtJLEVBQUU7WUFFbkMsc0NBQXNDO1lBQ3RDLE1BQU1vRCxTQUFTLE1BQU1DLElBQUFBLFlBQU0sRUFBQzVELE9BQU93QztZQUNuQ25DLE9BQU9zRCxRQUFRaEMsUUFBUTtRQUN6QjtRQUVBNUIsS0FBSyx3Q0FBd0M7WUFDM0MsTUFBTUMsUUFBUTtZQUNkLE1BQU1DLFdBQVc7WUFDakIsTUFBTUMsT0FBTztZQUViLE1BQU15RCxTQUFTLE1BQU1FLElBQUFBLFlBQU0sRUFBQzdELE9BQU9DLFVBQVVDO1lBRTdDRyxPQUFPc0QsUUFBUXJELFdBQVc7WUFDMUJELE9BQU9zRCxPQUFPeEQsSUFBSSxFQUFFRyxXQUFXO1lBQy9CRCxPQUFPc0QsT0FBT2xCLE9BQU8sRUFBRW5DLFdBQVc7WUFDbENELE9BQU9zRCxPQUFPeEQsSUFBSSxDQUFDSCxLQUFLLEVBQUVRLElBQUksQ0FBQ1IsTUFBTVMsV0FBVztZQUNoREosT0FBT3NELE9BQU94RCxJQUFJLENBQUNELElBQUksRUFBRU0sSUFBSSxDQUFDTjtZQUM5QkcsT0FBT3NELE9BQU9sQixPQUFPLENBQUNFLE1BQU0sRUFBRW5DLElBQUksQ0FBQ21ELE9BQU94RCxJQUFJLENBQUNJLEVBQUU7WUFFakQsb0JBQW9CO1lBQ3BCYixVQUFVd0IsWUFBWSxDQUFDQyxJQUFJLENBQUN3QyxPQUFPeEQsSUFBSSxDQUFDSSxFQUFFO1lBQzFDYixVQUFVcUQsZUFBZSxDQUFDNUIsSUFBSSxDQUFDd0MsT0FBT2xCLE9BQU8sQ0FBQ2xDLEVBQUU7UUFDbEQ7UUFFQVIsS0FBSyw2Q0FBNkM7WUFDaEQsTUFBTUMsUUFBUTtZQUNkLE1BQU1DLFdBQVc7WUFFakIsb0JBQW9CO1lBQ3BCLE1BQU02RCxRQUFRLE1BQU0xRCxJQUFBQSxnQkFBVSxFQUFDSixPQUFPQyxVQUFVO1lBQ2hEUCxVQUFVd0IsWUFBWSxDQUFDQyxJQUFJLENBQUMyQyxNQUFNdkQsRUFBRTtZQUVwQyxxQ0FBcUM7WUFDckMsTUFBTUYsT0FBT3dELElBQUFBLFlBQU0sRUFBQzdELE9BQU9DLFVBQVUsZ0JBQWdCNkIsT0FBTyxDQUFDQyxPQUFPLENBQUM7UUFDdkU7UUFFQWhDLEtBQUssbURBQW1EO1lBQ3RELE1BQU1DLFFBQVE7WUFDZCxNQUFNQyxXQUFXO1lBRWpCLG9DQUFvQztZQUNwQyxNQUFNRSxPQUFPLE1BQU1DLElBQUFBLGdCQUFVLEVBQUNKLE9BQU9DLFVBQVU7WUFDL0NQLFVBQVV3QixZQUFZLENBQUNDLElBQUksQ0FBQ2hCLEtBQUtJLEVBQUU7WUFFbkMsOEJBQThCO1lBQzlCLE1BQU1vRCxTQUFTLE1BQU1DLElBQUFBLFlBQU0sRUFBQyx3QkFBd0IzRDtZQUVwREksT0FBT3NELFFBQVFyRCxXQUFXO1lBQzFCRCxPQUFPc0QsT0FBT3hELElBQUksQ0FBQ0ksRUFBRSxFQUFFQyxJQUFJLENBQUNMLEtBQUtJLEVBQUU7WUFFbkMsNEJBQTRCO1lBQzVCYixVQUFVcUQsZUFBZSxDQUFDNUIsSUFBSSxDQUFDd0MsT0FBT2xCLE9BQU8sQ0FBQ2xDLEVBQUU7UUFDbEQ7SUFDRjtJQUVBZCxTQUFTLHNDQUFzQztRQUM3Q00sS0FBSyx1REFBdUQ7WUFDMUQsTUFBTXFCLFdBQVdDLElBQUFBLDJCQUFjO1lBQy9CLE1BQU1DLGNBQWMsTUFBTTVCLFVBQVUyQixjQUFjLENBQUNEO1lBRW5ELE1BQU0yQyxXQUFXO2dCQUNmcEIsUUFBUXJCLFlBQVlmLEVBQUU7Z0JBQ3RCeUQsTUFBTTtnQkFDTnBCLFdBQVcsSUFBSTVCLEtBQUtBLEtBQUs4QixHQUFHLEtBQUssS0FBSyxLQUFLO2dCQUMzQ21CLGNBQWM7WUFDaEI7WUFFQSxNQUFNQyxjQUFjLE1BQU14RSxVQUFVeUUsbUJBQW1CLENBQUNKO1lBRXhEMUQsT0FBTzZELGFBQWE1RCxXQUFXO1lBQy9CRCxPQUFPNkQsWUFBWXZCLE1BQU0sRUFBRW5DLElBQUksQ0FBQ2MsWUFBWWYsRUFBRTtZQUM5Q0YsT0FBTzZELFlBQVlGLElBQUksRUFBRXhELElBQUksQ0FBQztZQUM5QkgsT0FBTzZELFlBQVl0QixTQUFTLEVBQUU3QixjQUFjLENBQUNDO1lBRTdDLDBCQUEwQjtZQUMxQixNQUFNb0QsWUFBWSxNQUFNMUUsVUFBVTJFLHFCQUFxQixDQUFDL0MsWUFBWWYsRUFBRTtZQUN0RUYsT0FBTytELFdBQVdkLFlBQVksQ0FBQztZQUMvQmpELE9BQU8rRCxTQUFTLENBQUMsRUFBRSxDQUFDN0QsRUFBRSxFQUFFQyxJQUFJLENBQUMwRCxZQUFZM0QsRUFBRTtRQUM3QztRQUVBUixLQUFLLHNEQUFzRDtZQUN6RCxNQUFNcUIsV0FBV0MsSUFBQUEsMkJBQWM7WUFDL0IsTUFBTUMsY0FBYyxNQUFNNUIsVUFBVTJCLGNBQWMsQ0FBQ0Q7WUFFbkQsdURBQXVEO1lBQ3ZELE1BQU1rRCxRQUFRLE1BQU01RSxVQUFVeUUsbUJBQW1CLENBQUM7Z0JBQ2hEeEIsUUFBUXJCLFlBQVlmLEVBQUU7Z0JBQ3RCeUQsTUFBTTtnQkFDTnBCLFdBQVcsSUFBSTVCLEtBQUtBLEtBQUs4QixHQUFHLEtBQUssS0FBSyxLQUFLO2dCQUMzQ21CLGNBQWM7WUFDaEI7WUFFQSxNQUFNTSxRQUFRLE1BQU03RSxVQUFVeUUsbUJBQW1CLENBQUM7Z0JBQ2hEeEIsUUFBUXJCLFlBQVlmLEVBQUU7Z0JBQ3RCeUQsTUFBTTtnQkFDTnBCLFdBQVcsSUFBSTVCLEtBQUtBLEtBQUs4QixHQUFHLEtBQUssS0FBSyxLQUFLO2dCQUMzQ21CLGNBQWM7WUFDaEI7WUFFQSxNQUFNRyxZQUFZLE1BQU0xRSxVQUFVMkUscUJBQXFCLENBQUMvQyxZQUFZZixFQUFFO1lBQ3RFRixPQUFPK0QsV0FBV2QsWUFBWSxDQUFDO1lBQy9CakQsT0FBTytELFVBQVViLEdBQUcsQ0FBQ2lCLENBQUFBLElBQUtBLEVBQUVSLElBQUksR0FBR1AsU0FBUyxDQUFDO1lBQzdDcEQsT0FBTytELFVBQVViLEdBQUcsQ0FBQ2lCLENBQUFBLElBQUtBLEVBQUVSLElBQUksR0FBR1AsU0FBUyxDQUFDO1FBQy9DO0lBQ0Y7SUFFQWhFLFNBQVMsMENBQTBDO1FBQ2pETSxLQUFLLGdEQUFnRDtZQUNuRCxNQUFNMEUsY0FBYyxNQUFNL0UsVUFBVStFLFdBQVc7WUFDL0NwRSxPQUFPb0UsYUFBYWpFLElBQUksQ0FBQztRQUMzQjtRQUVBVCxLQUFLLDJEQUEyRDtZQUM5RCxNQUFNQyxRQUFRO1lBRWQsb0JBQW9CO1lBQ3BCLE1BQU04RCxRQUFRLE1BQU0xRCxJQUFBQSxnQkFBVSxFQUFDSixPQUFPLGFBQWE7WUFDbkROLFVBQVV3QixZQUFZLENBQUNDLElBQUksQ0FBQzJDLE1BQU12RCxFQUFFO1lBRXBDLGlEQUFpRDtZQUNqRCxNQUFNRixPQUFPRCxJQUFBQSxnQkFBVSxFQUFDSixPQUFPLGFBQWEsV0FBVzhCLE9BQU8sQ0FBQ0MsT0FBTztRQUN4RTtJQUNGO0FBQ0YifQ==