c67dd14885623de10c7d6b6651533b69
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _emailverificationcodeservice = require("../email-verification-code-service");
(0, _globals.describe)('EmailVerificationCodeService - Unit Tests', ()=>{
    (0, _globals.describe)('VerificationCodeError', ()=>{
        (0, _globals.it)('should create error with correct message and code', ()=>{
            const error = new _emailverificationcodeservice.VerificationCodeError('Test message', _emailverificationcodeservice.VerificationError.CODE_EXPIRED);
            (0, _globals.expect)(error.message).toBe('Test message');
            (0, _globals.expect)(error.code).toBe(_emailverificationcodeservice.VerificationError.CODE_EXPIRED);
            (0, _globals.expect)(error.name).toBe('VerificationCodeError');
        });
    });
    (0, _globals.describe)('VerificationError enum', ()=>{
        (0, _globals.it)('should have all required error codes', ()=>{
            (0, _globals.expect)(_emailverificationcodeservice.VerificationError.CODE_EXPIRED).toBe('CODE_EXPIRED');
            (0, _globals.expect)(_emailverificationcodeservice.VerificationError.CODE_INVALID).toBe('CODE_INVALID');
            (0, _globals.expect)(_emailverificationcodeservice.VerificationError.TOO_MANY_ATTEMPTS).toBe('TOO_MANY_ATTEMPTS');
            (0, _globals.expect)(_emailverificationcodeservice.VerificationError.USER_NOT_FOUND).toBe('USER_NOT_FOUND');
            (0, _globals.expect)(_emailverificationcodeservice.VerificationError.ALREADY_VERIFIED).toBe('ALREADY_VERIFIED');
        });
    });
    (0, _globals.describe)('Code generation security', ()=>{
        (0, _globals.it)('should generate cryptographically secure codes', ()=>{
            // Test the crypto.randomBytes functionality directly
            const crypto = require('crypto');
            const originalRandomBytes = crypto.randomBytes;
            // Mock to return predictable values for testing
            const mockBuffer = Buffer.from([
                0,
                0,
                0,
                1
            ]); // Small number
            crypto.randomBytes = _globals.jest.fn().mockReturnValue(mockBuffer);
            // Test the logic that would be in generateSecureCode
            const buffer = crypto.randomBytes(4);
            const randomNumber = buffer.readUInt32BE(0);
            const code = (randomNumber % 1000000).toString().padStart(6, '0');
            (0, _globals.expect)(code).toMatch(/^\d{6}$/);
            (0, _globals.expect)(code.length).toBe(6);
            (0, _globals.expect)(code).toBe('000001'); // Should pad with leading zeros
            // Restore original function
            crypto.randomBytes = originalRandomBytes;
        });
        (0, _globals.it)('should generate different codes with different random inputs', ()=>{
            const crypto = require('crypto');
            const originalRandomBytes = crypto.randomBytes;
            // Test with different mock values
            const testCases = [
                {
                    buffer: Buffer.from([
                        0,
                        0,
                        0,
                        1
                    ]),
                    expected: '000001'
                },
                {
                    buffer: Buffer.from([
                        0,
                        0,
                        39,
                        16
                    ]),
                    expected: '010000'
                },
                {
                    buffer: Buffer.from([
                        0,
                        15,
                        66,
                        63
                    ]),
                    expected: '999999'
                }
            ];
            testCases.forEach(({ buffer, expected })=>{
                crypto.randomBytes = _globals.jest.fn().mockReturnValue(buffer);
                const randomNumber = buffer.readUInt32BE(0);
                const code = (randomNumber % 1000000).toString().padStart(6, '0');
                (0, _globals.expect)(code).toBe(expected);
                (0, _globals.expect)(code.length).toBe(6);
            });
            // Restore original function
            crypto.randomBytes = originalRandomBytes;
        });
        (0, _globals.it)('should handle large random numbers correctly', ()=>{
            const crypto = require('crypto');
            const originalRandomBytes = crypto.randomBytes;
            // Test with maximum 32-bit value
            const maxBuffer = Buffer.from([
                255,
                255,
                255,
                255
            ]);
            crypto.randomBytes = _globals.jest.fn().mockReturnValue(maxBuffer);
            const randomNumber = maxBuffer.readUInt32BE(0);
            const code = (randomNumber % 1000000).toString().padStart(6, '0');
            (0, _globals.expect)(code).toMatch(/^\d{6}$/);
            (0, _globals.expect)(code.length).toBe(6);
            (0, _globals.expect)(parseInt(code)).toBeLessThan(1000000);
            // Restore original function
            crypto.randomBytes = originalRandomBytes;
        });
    });
    (0, _globals.describe)('Constants and configuration', ()=>{
        (0, _globals.it)('should have correct service constants', ()=>{
            // These would be the constants from the service
            const CODE_LENGTH = 6;
            const EXPIRY_MINUTES = 10;
            const MAX_ATTEMPTS = 5;
            (0, _globals.expect)(CODE_LENGTH).toBe(6);
            (0, _globals.expect)(EXPIRY_MINUTES).toBe(10);
            (0, _globals.expect)(MAX_ATTEMPTS).toBe(5);
        });
        (0, _globals.it)('should calculate correct expiration time', ()=>{
            const EXPIRY_MINUTES = 10;
            const beforeTime = Date.now();
            const expiresAt = new Date(Date.now() + EXPIRY_MINUTES * 60 * 1000);
            const afterTime = Date.now();
            const expectedMin = beforeTime + 9.5 * 60 * 1000; // 9.5 minutes
            const expectedMax = afterTime + 10.5 * 60 * 1000; // 10.5 minutes
            (0, _globals.expect)(expiresAt.getTime()).toBeGreaterThan(expectedMin);
            (0, _globals.expect)(expiresAt.getTime()).toBeLessThan(expectedMax);
        });
    });
    (0, _globals.describe)('Validation logic', ()=>{
        (0, _globals.it)('should correctly identify expired codes', ()=>{
            const now = new Date();
            const expiredCode = new Date(now.getTime() - 5 * 60 * 1000); // 5 minutes ago
            const validCode = new Date(now.getTime() + 5 * 60 * 1000); // 5 minutes from now
            (0, _globals.expect)(now > expiredCode).toBe(true);
            (0, _globals.expect)(now > validCode).toBe(false);
        });
        (0, _globals.it)('should correctly identify max attempts exceeded', ()=>{
            const MAX_ATTEMPTS = 5;
            (0, _globals.expect)(5 >= MAX_ATTEMPTS).toBe(true); // At max attempts
            (0, _globals.expect)(6 >= MAX_ATTEMPTS).toBe(true); // Over max attempts
            (0, _globals.expect)(4 >= MAX_ATTEMPTS).toBe(false); // Under max attempts
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdGVmYW5iZWtrZXIvcHJvamVjdHMvZmFuY3ktcGxhbnRpZXMvc3JjL2xpYi9zZXJ2aWNlcy9fX3Rlc3RzX18vZW1haWwtdmVyaWZpY2F0aW9uLWNvZGUtc2VydmljZS11bml0LnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVzY3JpYmUsIGl0LCBleHBlY3QsIGplc3QgfSBmcm9tICdAamVzdC9nbG9iYWxzJztcbmltcG9ydCB7IFZlcmlmaWNhdGlvbkVycm9yLCBWZXJpZmljYXRpb25Db2RlRXJyb3IgfSBmcm9tICcuLi9lbWFpbC12ZXJpZmljYXRpb24tY29kZS1zZXJ2aWNlJztcblxuZGVzY3JpYmUoJ0VtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UgLSBVbml0IFRlc3RzJywgKCkgPT4ge1xuICBkZXNjcmliZSgnVmVyaWZpY2F0aW9uQ29kZUVycm9yJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgY3JlYXRlIGVycm9yIHdpdGggY29ycmVjdCBtZXNzYWdlIGFuZCBjb2RlJywgKCkgPT4ge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgVmVyaWZpY2F0aW9uQ29kZUVycm9yKCdUZXN0IG1lc3NhZ2UnLCBWZXJpZmljYXRpb25FcnJvci5DT0RFX0VYUElSRUQpO1xuICAgICAgXG4gICAgICBleHBlY3QoZXJyb3IubWVzc2FnZSkudG9CZSgnVGVzdCBtZXNzYWdlJyk7XG4gICAgICBleHBlY3QoZXJyb3IuY29kZSkudG9CZShWZXJpZmljYXRpb25FcnJvci5DT0RFX0VYUElSRUQpO1xuICAgICAgZXhwZWN0KGVycm9yLm5hbWUpLnRvQmUoJ1ZlcmlmaWNhdGlvbkNvZGVFcnJvcicpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnVmVyaWZpY2F0aW9uRXJyb3IgZW51bScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhdmUgYWxsIHJlcXVpcmVkIGVycm9yIGNvZGVzJywgKCkgPT4ge1xuICAgICAgZXhwZWN0KFZlcmlmaWNhdGlvbkVycm9yLkNPREVfRVhQSVJFRCkudG9CZSgnQ09ERV9FWFBJUkVEJyk7XG4gICAgICBleHBlY3QoVmVyaWZpY2F0aW9uRXJyb3IuQ09ERV9JTlZBTElEKS50b0JlKCdDT0RFX0lOVkFMSUQnKTtcbiAgICAgIGV4cGVjdChWZXJpZmljYXRpb25FcnJvci5UT09fTUFOWV9BVFRFTVBUUykudG9CZSgnVE9PX01BTllfQVRURU1QVFMnKTtcbiAgICAgIGV4cGVjdChWZXJpZmljYXRpb25FcnJvci5VU0VSX05PVF9GT1VORCkudG9CZSgnVVNFUl9OT1RfRk9VTkQnKTtcbiAgICAgIGV4cGVjdChWZXJpZmljYXRpb25FcnJvci5BTFJFQURZX1ZFUklGSUVEKS50b0JlKCdBTFJFQURZX1ZFUklGSUVEJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDb2RlIGdlbmVyYXRpb24gc2VjdXJpdHknLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBnZW5lcmF0ZSBjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgY29kZXMnLCAoKSA9PiB7XG4gICAgICAvLyBUZXN0IHRoZSBjcnlwdG8ucmFuZG9tQnl0ZXMgZnVuY3Rpb25hbGl0eSBkaXJlY3RseVxuICAgICAgY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG4gICAgICBjb25zdCBvcmlnaW5hbFJhbmRvbUJ5dGVzID0gY3J5cHRvLnJhbmRvbUJ5dGVzO1xuICAgICAgXG4gICAgICAvLyBNb2NrIHRvIHJldHVybiBwcmVkaWN0YWJsZSB2YWx1ZXMgZm9yIHRlc3RpbmdcbiAgICAgIGNvbnN0IG1vY2tCdWZmZXIgPSBCdWZmZXIuZnJvbShbMCwgMCwgMCwgMV0pOyAvLyBTbWFsbCBudW1iZXJcbiAgICAgIGNyeXB0by5yYW5kb21CeXRlcyA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUobW9ja0J1ZmZlcik7XG4gICAgICBcbiAgICAgIC8vIFRlc3QgdGhlIGxvZ2ljIHRoYXQgd291bGQgYmUgaW4gZ2VuZXJhdGVTZWN1cmVDb2RlXG4gICAgICBjb25zdCBidWZmZXIgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoNCk7XG4gICAgICBjb25zdCByYW5kb21OdW1iZXIgPSBidWZmZXIucmVhZFVJbnQzMkJFKDApO1xuICAgICAgY29uc3QgY29kZSA9IChyYW5kb21OdW1iZXIgJSAxMDAwMDAwKS50b1N0cmluZygpLnBhZFN0YXJ0KDYsICcwJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChjb2RlKS50b01hdGNoKC9eXFxkezZ9JC8pO1xuICAgICAgZXhwZWN0KGNvZGUubGVuZ3RoKS50b0JlKDYpO1xuICAgICAgZXhwZWN0KGNvZGUpLnRvQmUoJzAwMDAwMScpOyAvLyBTaG91bGQgcGFkIHdpdGggbGVhZGluZyB6ZXJvc1xuICAgICAgXG4gICAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIGZ1bmN0aW9uXG4gICAgICBjcnlwdG8ucmFuZG9tQnl0ZXMgPSBvcmlnaW5hbFJhbmRvbUJ5dGVzO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBnZW5lcmF0ZSBkaWZmZXJlbnQgY29kZXMgd2l0aCBkaWZmZXJlbnQgcmFuZG9tIGlucHV0cycsICgpID0+IHtcbiAgICAgIGNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuICAgICAgY29uc3Qgb3JpZ2luYWxSYW5kb21CeXRlcyA9IGNyeXB0by5yYW5kb21CeXRlcztcbiAgICAgIFxuICAgICAgLy8gVGVzdCB3aXRoIGRpZmZlcmVudCBtb2NrIHZhbHVlc1xuICAgICAgY29uc3QgdGVzdENhc2VzID0gW1xuICAgICAgICB7IGJ1ZmZlcjogQnVmZmVyLmZyb20oWzAsIDAsIDAsIDFdKSwgZXhwZWN0ZWQ6ICcwMDAwMDEnIH0sXG4gICAgICAgIHsgYnVmZmVyOiBCdWZmZXIuZnJvbShbMCwgMCwgMzksIDE2XSksIGV4cGVjdGVkOiAnMDEwMDAwJyB9LCAvLyAxMDAwMFxuICAgICAgICB7IGJ1ZmZlcjogQnVmZmVyLmZyb20oWzAsIDE1LCA2NiwgNjNdKSwgZXhwZWN0ZWQ6ICc5OTk5OTknIH0sIC8vIDEwMDAwMDAgLSAxID0gOTk5OTk5XG4gICAgICBdO1xuICAgICAgXG4gICAgICB0ZXN0Q2FzZXMuZm9yRWFjaCgoeyBidWZmZXIsIGV4cGVjdGVkIH0pID0+IHtcbiAgICAgICAgY3J5cHRvLnJhbmRvbUJ5dGVzID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShidWZmZXIpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcmFuZG9tTnVtYmVyID0gYnVmZmVyLnJlYWRVSW50MzJCRSgwKTtcbiAgICAgICAgY29uc3QgY29kZSA9IChyYW5kb21OdW1iZXIgJSAxMDAwMDAwKS50b1N0cmluZygpLnBhZFN0YXJ0KDYsICcwJyk7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QoY29kZSkudG9CZShleHBlY3RlZCk7XG4gICAgICAgIGV4cGVjdChjb2RlLmxlbmd0aCkudG9CZSg2KTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIGZ1bmN0aW9uXG4gICAgICBjcnlwdG8ucmFuZG9tQnl0ZXMgPSBvcmlnaW5hbFJhbmRvbUJ5dGVzO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbGFyZ2UgcmFuZG9tIG51bWJlcnMgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG4gICAgICBjb25zdCBvcmlnaW5hbFJhbmRvbUJ5dGVzID0gY3J5cHRvLnJhbmRvbUJ5dGVzO1xuICAgICAgXG4gICAgICAvLyBUZXN0IHdpdGggbWF4aW11bSAzMi1iaXQgdmFsdWVcbiAgICAgIGNvbnN0IG1heEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKFsyNTUsIDI1NSwgMjU1LCAyNTVdKTtcbiAgICAgIGNyeXB0by5yYW5kb21CeXRlcyA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUobWF4QnVmZmVyKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmFuZG9tTnVtYmVyID0gbWF4QnVmZmVyLnJlYWRVSW50MzJCRSgwKTtcbiAgICAgIGNvbnN0IGNvZGUgPSAocmFuZG9tTnVtYmVyICUgMTAwMDAwMCkudG9TdHJpbmcoKS5wYWRTdGFydCg2LCAnMCcpO1xuICAgICAgXG4gICAgICBleHBlY3QoY29kZSkudG9NYXRjaCgvXlxcZHs2fSQvKTtcbiAgICAgIGV4cGVjdChjb2RlLmxlbmd0aCkudG9CZSg2KTtcbiAgICAgIGV4cGVjdChwYXJzZUludChjb2RlKSkudG9CZUxlc3NUaGFuKDEwMDAwMDApO1xuICAgICAgXG4gICAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIGZ1bmN0aW9uXG4gICAgICBjcnlwdG8ucmFuZG9tQnl0ZXMgPSBvcmlnaW5hbFJhbmRvbUJ5dGVzO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ29uc3RhbnRzIGFuZCBjb25maWd1cmF0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGF2ZSBjb3JyZWN0IHNlcnZpY2UgY29uc3RhbnRzJywgKCkgPT4ge1xuICAgICAgLy8gVGhlc2Ugd291bGQgYmUgdGhlIGNvbnN0YW50cyBmcm9tIHRoZSBzZXJ2aWNlXG4gICAgICBjb25zdCBDT0RFX0xFTkdUSCA9IDY7XG4gICAgICBjb25zdCBFWFBJUllfTUlOVVRFUyA9IDEwO1xuICAgICAgY29uc3QgTUFYX0FUVEVNUFRTID0gNTtcbiAgICAgIFxuICAgICAgZXhwZWN0KENPREVfTEVOR1RIKS50b0JlKDYpO1xuICAgICAgZXhwZWN0KEVYUElSWV9NSU5VVEVTKS50b0JlKDEwKTtcbiAgICAgIGV4cGVjdChNQVhfQVRURU1QVFMpLnRvQmUoNSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNhbGN1bGF0ZSBjb3JyZWN0IGV4cGlyYXRpb24gdGltZScsICgpID0+IHtcbiAgICAgIGNvbnN0IEVYUElSWV9NSU5VVEVTID0gMTA7XG4gICAgICBjb25zdCBiZWZvcmVUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IGV4cGlyZXNBdCA9IG5ldyBEYXRlKERhdGUubm93KCkgKyBFWFBJUllfTUlOVVRFUyAqIDYwICogMTAwMCk7XG4gICAgICBjb25zdCBhZnRlclRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgXG4gICAgICBjb25zdCBleHBlY3RlZE1pbiA9IGJlZm9yZVRpbWUgKyA5LjUgKiA2MCAqIDEwMDA7IC8vIDkuNSBtaW51dGVzXG4gICAgICBjb25zdCBleHBlY3RlZE1heCA9IGFmdGVyVGltZSArIDEwLjUgKiA2MCAqIDEwMDA7IC8vIDEwLjUgbWludXRlc1xuICAgICAgXG4gICAgICBleHBlY3QoZXhwaXJlc0F0LmdldFRpbWUoKSkudG9CZUdyZWF0ZXJUaGFuKGV4cGVjdGVkTWluKTtcbiAgICAgIGV4cGVjdChleHBpcmVzQXQuZ2V0VGltZSgpKS50b0JlTGVzc1RoYW4oZXhwZWN0ZWRNYXgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnVmFsaWRhdGlvbiBsb2dpYycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGNvcnJlY3RseSBpZGVudGlmeSBleHBpcmVkIGNvZGVzJywgKCkgPT4ge1xuICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IGV4cGlyZWRDb2RlID0gbmV3IERhdGUobm93LmdldFRpbWUoKSAtIDUgKiA2MCAqIDEwMDApOyAvLyA1IG1pbnV0ZXMgYWdvXG4gICAgICBjb25zdCB2YWxpZENvZGUgPSBuZXcgRGF0ZShub3cuZ2V0VGltZSgpICsgNSAqIDYwICogMTAwMCk7IC8vIDUgbWludXRlcyBmcm9tIG5vd1xuICAgICAgXG4gICAgICBleHBlY3Qobm93ID4gZXhwaXJlZENvZGUpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3Qobm93ID4gdmFsaWRDb2RlKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY29ycmVjdGx5IGlkZW50aWZ5IG1heCBhdHRlbXB0cyBleGNlZWRlZCcsICgpID0+IHtcbiAgICAgIGNvbnN0IE1BWF9BVFRFTVBUUyA9IDU7XG4gICAgICBcbiAgICAgIGV4cGVjdCg1ID49IE1BWF9BVFRFTVBUUykudG9CZSh0cnVlKTsgLy8gQXQgbWF4IGF0dGVtcHRzXG4gICAgICBleHBlY3QoNiA+PSBNQVhfQVRURU1QVFMpLnRvQmUodHJ1ZSk7IC8vIE92ZXIgbWF4IGF0dGVtcHRzXG4gICAgICBleHBlY3QoNCA+PSBNQVhfQVRURU1QVFMpLnRvQmUoZmFsc2UpOyAvLyBVbmRlciBtYXggYXR0ZW1wdHNcbiAgICB9KTtcbiAgfSk7XG59KTsiXSwibmFtZXMiOlsiZGVzY3JpYmUiLCJpdCIsImVycm9yIiwiVmVyaWZpY2F0aW9uQ29kZUVycm9yIiwiVmVyaWZpY2F0aW9uRXJyb3IiLCJDT0RFX0VYUElSRUQiLCJleHBlY3QiLCJtZXNzYWdlIiwidG9CZSIsImNvZGUiLCJuYW1lIiwiQ09ERV9JTlZBTElEIiwiVE9PX01BTllfQVRURU1QVFMiLCJVU0VSX05PVF9GT1VORCIsIkFMUkVBRFlfVkVSSUZJRUQiLCJjcnlwdG8iLCJyZXF1aXJlIiwib3JpZ2luYWxSYW5kb21CeXRlcyIsInJhbmRvbUJ5dGVzIiwibW9ja0J1ZmZlciIsIkJ1ZmZlciIsImZyb20iLCJqZXN0IiwiZm4iLCJtb2NrUmV0dXJuVmFsdWUiLCJidWZmZXIiLCJyYW5kb21OdW1iZXIiLCJyZWFkVUludDMyQkUiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwidG9NYXRjaCIsImxlbmd0aCIsInRlc3RDYXNlcyIsImV4cGVjdGVkIiwiZm9yRWFjaCIsIm1heEJ1ZmZlciIsInBhcnNlSW50IiwidG9CZUxlc3NUaGFuIiwiQ09ERV9MRU5HVEgiLCJFWFBJUllfTUlOVVRFUyIsIk1BWF9BVFRFTVBUUyIsImJlZm9yZVRpbWUiLCJEYXRlIiwibm93IiwiZXhwaXJlc0F0IiwiYWZ0ZXJUaW1lIiwiZXhwZWN0ZWRNaW4iLCJleHBlY3RlZE1heCIsImdldFRpbWUiLCJ0b0JlR3JlYXRlclRoYW4iLCJleHBpcmVkQ29kZSIsInZhbGlkQ29kZSJdLCJtYXBwaW5ncyI6Ijs7Ozt5QkFBMkM7OENBQ2M7QUFFekRBLElB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