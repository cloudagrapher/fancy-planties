{"version":3,"sources":["/Users/stefanbekker/projects/fancy-planties/src/lib/auth/middleware.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { validateRequest } from './server';\nimport type { User } from '../db/schema';\n\n// Rate limiting store (in production, use Redis or similar)\nconst rateLimitStore = new Map<string, { count: number; resetTime: number }>();\n\n// Rate limiting configuration\nconst RATE_LIMIT_WINDOW = 15 * 60 * 1000; // 15 minutes\nconst RATE_LIMIT_MAX_REQUESTS = 100; // Max requests per window\n\n// CSRF token generation and validation\nexport function generateCSRFToken(): string {\n  return crypto.randomUUID();\n}\n\nexport function validateCSRFToken(token: string, sessionToken: string): boolean {\n  // Simple CSRF validation - in production, use more sophisticated approach\n  return token === sessionToken;\n}\n\n// Rate limiting middleware\nexport function rateLimit(identifier: string): { success: boolean; remaining: number; resetTime: number } {\n  const now = Date.now();\n  \n  // Clean up old entries\n  for (const [key, value] of rateLimitStore.entries()) {\n    if (value.resetTime < now) {\n      rateLimitStore.delete(key);\n    }\n  }\n  \n  const current = rateLimitStore.get(identifier);\n  \n  if (!current || current.resetTime < now) {\n    // New window or expired window\n    const resetTime = now + RATE_LIMIT_WINDOW;\n    rateLimitStore.set(identifier, { count: 1, resetTime });\n    return {\n      success: true,\n      remaining: RATE_LIMIT_MAX_REQUESTS - 1,\n      resetTime,\n    };\n  }\n  \n  if (current.count >= RATE_LIMIT_MAX_REQUESTS) {\n    return {\n      success: false,\n      remaining: 0,\n      resetTime: current.resetTime,\n    };\n  }\n  \n  current.count++;\n  rateLimitStore.set(identifier, current);\n  \n  return {\n    success: true,\n    remaining: RATE_LIMIT_MAX_REQUESTS - current.count,\n    resetTime: current.resetTime,\n  };\n}\n\n// Authentication middleware for API routes\nexport async function withAuth(\n  request: NextRequest,\n  handler: (request: NextRequest, user: User) => Promise<NextResponse>\n): Promise<NextResponse> {\n  try {\n    const { user, session } = await validateRequest();\n    \n    if (!user || !session) {\n      return NextResponse.json(\n        { error: 'Unauthorized' },\n        { status: 401 }\n      );\n    }\n    \n    return await handler(request, user);\n  } catch (error) {\n    console.error('Auth middleware error:', error);\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    );\n  }\n}\n\n// Rate limiting middleware for API routes\nexport async function withRateLimit(\n  request: NextRequest,\n  handler: (request: NextRequest) => Promise<NextResponse>\n): Promise<NextResponse> {\n  try {\n    // Use IP address for rate limiting (in production, consider user ID for authenticated requests)\n    const identifier = request.headers.get('x-forwarded-for') || \n                      request.headers.get('x-real-ip') || \n                      'unknown';\n    \n    const rateLimitResult = rateLimit(identifier);\n    \n    if (!rateLimitResult.success) {\n      return NextResponse.json(\n        { \n          error: 'Too many requests',\n          resetTime: rateLimitResult.resetTime,\n        },\n        { \n          status: 429,\n          headers: {\n            'X-RateLimit-Limit': RATE_LIMIT_MAX_REQUESTS.toString(),\n            'X-RateLimit-Remaining': rateLimitResult.remaining.toString(),\n            'X-RateLimit-Reset': rateLimitResult.resetTime.toString(),\n          },\n        }\n      );\n    }\n    \n    const response = await handler(request);\n    \n    // Add rate limit headers to successful responses\n    response.headers.set('X-RateLimit-Limit', RATE_LIMIT_MAX_REQUESTS.toString());\n    response.headers.set('X-RateLimit-Remaining', rateLimitResult.remaining.toString());\n    response.headers.set('X-RateLimit-Reset', rateLimitResult.resetTime.toString());\n    \n    return response;\n  } catch (error) {\n    console.error('Rate limit middleware error:', error);\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    );\n  }\n}\n\n// Combined middleware for authenticated and rate-limited routes\nexport async function withAuthAndRateLimit(\n  request: NextRequest,\n  handler: (request: NextRequest, user: User) => Promise<NextResponse>\n): Promise<NextResponse> {\n  return withRateLimit(request, async (req) => {\n    return withAuth(req, handler);\n  });\n}\n\n// CSRF protection middleware\nexport async function withCSRFProtection(\n  request: NextRequest,\n  handler: (request: NextRequest) => Promise<NextResponse>\n): Promise<NextResponse> {\n  try {\n    // Skip CSRF for GET requests\n    if (request.method === 'GET') {\n      return await handler(request);\n    }\n    \n    const csrfToken = request.headers.get('x-csrf-token');\n    const sessionCookie = request.cookies.get('auth-session');\n    \n    if (!csrfToken || !sessionCookie) {\n      return NextResponse.json(\n        { error: 'CSRF token missing' },\n        { status: 403 }\n      );\n    }\n    \n    // In a real implementation, you'd validate the CSRF token properly\n    // For now, we'll just check that it exists\n    if (!validateCSRFToken(csrfToken, sessionCookie.value)) {\n      return NextResponse.json(\n        { error: 'Invalid CSRF token' },\n        { status: 403 }\n      );\n    }\n    \n    return await handler(request);\n  } catch (error) {\n    console.error('CSRF middleware error:', error);\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    );\n  }\n}\n\n// Route protection helper for pages\nexport async function requireAuth(): Promise<{ user: User; session: { id: string; userId: number; expiresAt: Date } } | null> {\n  const { user, session } = await validateRequest();\n  \n  if (!user || !session) {\n    return null;\n  }\n  \n  return { user, session };\n}"],"names":["generateCSRFToken","rateLimit","requireAuth","validateCSRFToken","withAuth","withAuthAndRateLimit","withCSRFProtection","withRateLimit","rateLimitStore","Map","RATE_LIMIT_WINDOW","RATE_LIMIT_MAX_REQUESTS","crypto","randomUUID","token","sessionToken","identifier","now","Date","key","value","entries","resetTime","delete","current","get","set","count","success","remaining","request","handler","user","session","validateRequest","NextResponse","json","error","status","console","headers","rateLimitResult","toString","response","req","method","csrfToken","sessionCookie","cookies"],"mappings":"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"}