{"version":3,"sources":["/Users/stefanbekker/projects/fancy-planties/src/test-utils/helpers/interaction-helpers.js"],"sourcesContent":["// User interaction test helpers\n\nimport { screen, waitFor, fireEvent } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\n\n/**\n * Click a button by text or role\n * @param {string} buttonText - Button text or accessible name\n * @param {Object} user - userEvent instance (optional, will create if not provided)\n * @returns {Promise} Promise that resolves after click\n */\nexport const clickButton = async (buttonText, user = null) => {\n  const userEventInstance = user || userEvent.setup();\n  const button = screen.getByRole('button', { name: new RegExp(buttonText, 'i') });\n  await userEventInstance.click(button);\n  return button;\n};\n\n/**\n * Click a link by text or role\n * @param {string} linkText - Link text or accessible name\n * @param {Object} user - userEvent instance (optional)\n * @returns {Promise} Promise that resolves after click\n */\nexport const clickLink = async (linkText, user = null) => {\n  const userEventInstance = user || userEvent.setup();\n  const link = screen.getByRole('link', { name: new RegExp(linkText, 'i') });\n  await userEventInstance.click(link);\n  return link;\n};\n\n/**\n * Type text into an input field\n * @param {string} fieldLabel - Field label, placeholder, or accessible name\n * @param {string} text - Text to type\n * @param {Object} user - userEvent instance (optional)\n * @param {Object} options - Additional options\n * @returns {Promise} Promise that resolves after typing\n */\nexport const typeInField = async (fieldLabel, text, user = null, options = {}) => {\n  const userEventInstance = user || userEvent.setup();\n  const { clear = true, delay = null } = options;\n  \n  // Try multiple ways to find the field\n  let field;\n  try {\n    field = screen.getByLabelText(new RegExp(fieldLabel, 'i'));\n  } catch {\n    try {\n      field = screen.getByPlaceholderText(new RegExp(fieldLabel, 'i'));\n    } catch {\n      try {\n        field = screen.getByRole('textbox', { name: new RegExp(fieldLabel, 'i') });\n      } catch {\n        field = screen.getByDisplayValue(''); // Fallback for empty fields\n      }\n    }\n  }\n  \n  if (clear) {\n    await userEventInstance.clear(field);\n  }\n  \n  if (delay) {\n    await userEventInstance.type(field, text, { delay });\n  } else {\n    await userEventInstance.type(field, text);\n  }\n  \n  return field;\n};\n\n/**\n * Select an option from a dropdown/select element\n * @param {string} selectLabel - Select element label or accessible name\n * @param {string} optionText - Option text to select\n * @param {Object} user - userEvent instance (optional)\n * @returns {Promise} Promise that resolves after selection\n */\nexport const selectOption = async (selectLabel, optionText, user = null) => {\n  const userEventInstance = user || userEvent.setup();\n  \n  const select = screen.getByLabelText(new RegExp(selectLabel, 'i')) ||\n                screen.getByRole('combobox', { name: new RegExp(selectLabel, 'i') });\n  \n  await userEventInstance.selectOptions(select, optionText);\n  return select;\n};\n\n/**\n * Check or uncheck a checkbox\n * @param {string} checkboxLabel - Checkbox label or accessible name\n * @param {boolean} checked - Whether to check (true) or uncheck (false)\n * @param {Object} user - userEvent instance (optional)\n * @returns {Promise} Promise that resolves after interaction\n */\nexport const toggleCheckbox = async (checkboxLabel, checked = true, user = null) => {\n  const userEventInstance = user || userEvent.setup();\n  \n  const checkbox = screen.getByLabelText(new RegExp(checkboxLabel, 'i')) ||\n                  screen.getByRole('checkbox', { name: new RegExp(checkboxLabel, 'i') });\n  \n  if (checkbox.checked !== checked) {\n    await userEventInstance.click(checkbox);\n  }\n  \n  return checkbox;\n};\n\n/**\n * Upload a file to a file input\n * @param {string} inputLabel - File input label or accessible name\n * @param {File|Array<File>} files - File(s) to upload\n * @param {Object} user - userEvent instance (optional)\n * @returns {Promise} Promise that resolves after upload\n */\nexport const uploadFile = async (inputLabel, files, user = null) => {\n  const userEventInstance = user || userEvent.setup();\n  \n  const fileInput = screen.getByLabelText(new RegExp(inputLabel, 'i')) ||\n                   screen.getByRole('button', { name: new RegExp(inputLabel, 'i') });\n  \n  await userEventInstance.upload(fileInput, files);\n  return fileInput;\n};\n\n/**\n * Submit a form by clicking the submit button\n * @param {string} submitText - Submit button text (default: 'submit')\n * @param {Object} user - userEvent instance (optional)\n * @returns {Promise} Promise that resolves after submission\n */\nexport const submitForm = async (submitText = 'submit', user = null) => {\n  const userEventInstance = user || userEvent.setup();\n  \n  const submitButton = screen.getByRole('button', { name: new RegExp(submitText, 'i') }) ||\n                      screen.getByRole('button', { type: 'submit' });\n  \n  await userEventInstance.click(submitButton);\n  return submitButton;\n};\n\n/**\n * Fill out an entire form with provided data\n * @param {Object} formData - Object with field names as keys and values to enter\n * @param {Object} user - userEvent instance (optional)\n * @returns {Promise} Promise that resolves after filling all fields\n */\nexport const fillForm = async (formData, user = null) => {\n  const userEventInstance = user || userEvent.setup();\n  const filledFields = {};\n  \n  for (const [fieldName, value] of Object.entries(formData)) {\n    if (value !== null && value !== undefined) {\n      try {\n        const field = await typeInField(fieldName, value.toString(), userEventInstance);\n        filledFields[fieldName] = field;\n      } catch (error) {\n        console.warn(`Could not fill field \"${fieldName}\":`, error.message);\n      }\n    }\n  }\n  \n  return filledFields;\n};\n\n/**\n * Wait for an element to appear and then interact with it\n * @param {Function} findElement - Function that returns the element\n * @param {Function} interaction - Function that performs the interaction\n * @param {Object} options - Wait options\n * @returns {Promise} Promise that resolves after interaction\n */\nexport const waitAndInteract = async (findElement, interaction, options = {}) => {\n  const { timeout = 5000 } = options;\n  \n  await waitFor(findElement, { timeout });\n  const element = findElement();\n  await interaction(element);\n  return element;\n};\n\n/**\n * Simulate keyboard navigation\n * @param {string} key - Key to press (e.g., 'Tab', 'Enter', 'Escape')\n * @param {Object} user - userEvent instance (optional)\n * @param {Object} options - Key press options\n * @returns {Promise} Promise that resolves after key press\n */\nexport const pressKey = async (key, user = null, options = {}) => {\n  const userEventInstance = user || userEvent.setup();\n  await userEventInstance.keyboard(`{${key}}`);\n};\n\n/**\n * Simulate typing a sequence of keys\n * @param {string} keys - Key sequence to type\n * @param {Object} user - userEvent instance (optional)\n * @returns {Promise} Promise that resolves after typing\n */\nexport const typeKeys = async (keys, user = null) => {\n  const userEventInstance = user || userEvent.setup();\n  await userEventInstance.keyboard(keys);\n};\n\n/**\n * Hover over an element\n * @param {HTMLElement|string} elementOrText - Element or text to find element\n * @param {Object} user - userEvent instance (optional)\n * @returns {Promise} Promise that resolves after hover\n */\nexport const hoverElement = async (elementOrText, user = null) => {\n  const userEventInstance = user || userEvent.setup();\n  \n  let element;\n  if (typeof elementOrText === 'string') {\n    element = screen.getByText(new RegExp(elementOrText, 'i'));\n  } else {\n    element = elementOrText;\n  }\n  \n  await userEventInstance.hover(element);\n  return element;\n};\n\n/**\n * Simulate drag and drop interaction\n * @param {HTMLElement|string} source - Source element or text to find it\n * @param {HTMLElement|string} target - Target element or text to find it\n * @returns {Promise} Promise that resolves after drag and drop\n */\nexport const dragAndDrop = async (source, target) => {\n  let sourceElement, targetElement;\n  \n  if (typeof source === 'string') {\n    sourceElement = screen.getByText(new RegExp(source, 'i'));\n  } else {\n    sourceElement = source;\n  }\n  \n  if (typeof target === 'string') {\n    targetElement = screen.getByText(new RegExp(target, 'i'));\n  } else {\n    targetElement = target;\n  }\n  \n  fireEvent.dragStart(sourceElement);\n  fireEvent.dragEnter(targetElement);\n  fireEvent.dragOver(targetElement);\n  fireEvent.drop(targetElement);\n  fireEvent.dragEnd(sourceElement);\n  \n  return { source: sourceElement, target: targetElement };\n};\n\n/**\n * Wait for loading states to complete\n * @param {Object} options - Wait options\n * @returns {Promise} Promise that resolves when loading is complete\n */\nexport const waitForLoadingToComplete = async (options = {}) => {\n  const { timeout = 10000 } = options;\n  \n  await waitFor(() => {\n    // Check for common loading indicators\n    expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();\n    expect(screen.queryByText(/please wait/i)).not.toBeInTheDocument();\n    expect(screen.queryByRole('progressbar')).not.toBeInTheDocument();\n    expect(screen.queryByTestId('loading-spinner')).not.toBeInTheDocument();\n  }, { timeout });\n};\n\n/**\n * Simulate mobile touch interactions\n */\nexport const mobileInteractions = {\n  /**\n   * Simulate a swipe gesture\n   * @param {HTMLElement} element - Element to swipe on\n   * @param {string} direction - Swipe direction ('left', 'right', 'up', 'down')\n   * @param {number} distance - Swipe distance in pixels\n   */\n  swipe: async (element, direction = 'left', distance = 100) => {\n    const startCoords = { x: 100, y: 100 };\n    const endCoords = { ...startCoords };\n    \n    switch (direction) {\n      case 'left':\n        endCoords.x -= distance;\n        break;\n      case 'right':\n        endCoords.x += distance;\n        break;\n      case 'up':\n        endCoords.y -= distance;\n        break;\n      case 'down':\n        endCoords.y += distance;\n        break;\n    }\n    \n    fireEvent.touchStart(element, {\n      touches: [{ clientX: startCoords.x, clientY: startCoords.y }]\n    });\n    \n    fireEvent.touchMove(element, {\n      touches: [{ clientX: endCoords.x, clientY: endCoords.y }]\n    });\n    \n    fireEvent.touchEnd(element);\n  },\n\n  /**\n   * Simulate a long press\n   * @param {HTMLElement} element - Element to long press\n   * @param {number} duration - Press duration in milliseconds\n   */\n  longPress: async (element, duration = 500) => {\n    fireEvent.touchStart(element);\n    \n    await new Promise(resolve => setTimeout(resolve, duration));\n    \n    fireEvent.touchEnd(element);\n  },\n\n  /**\n   * Simulate a pinch gesture\n   * @param {HTMLElement} element - Element to pinch\n   * @param {number} scale - Scale factor (< 1 for pinch in, > 1 for pinch out)\n   */\n  pinch: async (element, scale = 0.5) => {\n    const centerX = 100;\n    const centerY = 100;\n    const distance = 50;\n    \n    // Start with two fingers apart\n    fireEvent.touchStart(element, {\n      touches: [\n        { clientX: centerX - distance, clientY: centerY },\n        { clientX: centerX + distance, clientY: centerY }\n      ]\n    });\n    \n    // Move fingers closer together or further apart\n    const newDistance = distance * scale;\n    fireEvent.touchMove(element, {\n      touches: [\n        { clientX: centerX - newDistance, clientY: centerY },\n        { clientX: centerX + newDistance, clientY: centerY }\n      ]\n    });\n    \n    fireEvent.touchEnd(element);\n  },\n};\n\n/**\n * Common form interaction patterns\n */\nexport const formInteractions = {\n  /**\n   * Complete a login form\n   * @param {string} email - Email to enter\n   * @param {string} password - Password to enter\n   * @param {Object} user - userEvent instance (optional)\n   */\n  login: async (email, password, user = null) => {\n    await fillForm({ email, password }, user);\n    await submitForm('sign in', user);\n  },\n\n  /**\n   * Complete a signup form\n   * @param {Object} userData - User data object\n   * @param {Object} user - userEvent instance (optional)\n   */\n  signup: async (userData, user = null) => {\n    const { email, password, name, confirmPassword } = userData;\n    await fillForm({ \n      email, \n      password, \n      name, \n      'confirm password': confirmPassword || password \n    }, user);\n    await submitForm('sign up', user);\n  },\n\n  /**\n   * Complete a plant instance form\n   * @param {Object} plantData - Plant instance data\n   * @param {Object} user - userEvent instance (optional)\n   */\n  createPlantInstance: async (plantData, user = null) => {\n    const { nickname, location, notes } = plantData;\n    await fillForm({ nickname, location, notes }, user);\n    await submitForm('save', user);\n  },\n\n  /**\n   * Complete a care record form\n   * @param {Object} careData - Care record data\n   * @param {Object} user - userEvent instance (optional)\n   */\n  logCare: async (careData, user = null) => {\n    const { careType, notes, date } = careData;\n    \n    if (careType) {\n      await selectOption('care type', careType, user);\n    }\n    \n    if (date) {\n      await typeInField('date', date, user);\n    }\n    \n    if (notes) {\n      await typeInField('notes', notes, user);\n    }\n    \n    await submitForm('log care', user);\n  },\n};"],"names":["clickButton","clickLink","dragAndDrop","fillForm","formInteractions","hoverElement","mobileInteractions","pressKey","selectOption","submitForm","toggleCheckbox","typeInField","typeKeys","uploadFile","waitAndInteract","waitForLoadingToComplete","buttonText","user","userEventInstance","userEvent","setup","button","screen","getByRole","name","RegExp","click","linkText","link","fieldLabel","text","options","clear","delay","field","getByLabelText","getByPlaceholderText","getByDisplayValue","type","selectLabel","optionText","select","selectOptions","checkboxLabel","checked","checkbox","inputLabel","files","fileInput","upload","submitText","submitButton","formData","filledFields","fieldName","value","Object","entries","undefined","toString","error","console","warn","message","findElement","interaction","timeout","waitFor","element","key","keyboard","keys","elementOrText","getByText","hover","source","target","sourceElement","targetElement","fireEvent","dragStart","dragEnter","dragOver","drop","dragEnd","expect","queryByText","not","toBeInTheDocument","queryByRole","queryByTestId","swipe","direction","distance","startCoords","x","y","endCoords","touchStart","touches","clientX","clientY","touchMove","touchEnd","longPress","duration","Promise","resolve","setTimeout","pinch","scale","centerX","centerY","newDistance","login","email","password","signup","userData","confirmPassword","createPlantInstance","plantData","nickname","location","notes","logCare","careData","careType","date"],"mappings":"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"}