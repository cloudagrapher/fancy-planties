86fa724f02403f792f6e7e3ab6a7aa60
/**
 * Email Verification Flow Integration Tests
 * Tests complete signup and verification process, resend functionality, and rate limiting
 * Requirements: 1.1, 1.4, 2.1, 2.2
 */ "use strict";
// Mock email service
jest.mock('@/lib/services/resend-email-service');
jest.mock('@/lib/services/email-service');
// Mock database
jest.mock('@/lib/db', ()=>({
        db: {
            select: jest.fn().mockReturnThis(),
            from: jest.fn().mockReturnThis(),
            where: jest.fn().mockReturnThis(),
            insert: jest.fn().mockReturnThis(),
            values: jest.fn().mockReturnThis(),
            update: jest.fn().mockReturnThis(),
            set: jest.fn().mockReturnThis(),
            delete: jest.fn().mockReturnThis(),
            returning: jest.fn(),
            execute: jest.fn()
        }
    }));
// Mock auth functions
jest.mock('@/lib/auth', ()=>({
        getUserByEmail: jest.fn(),
        getUserById: jest.fn()
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _emailverificationcodeservice = require("../../lib/services/email-verification-code-service");
const _resendemailservice = require("../../lib/services/resend-email-service");
const mockEmailService = {
    sendVerificationEmail: jest.fn()
};
const mockCreateEmailService = _resendemailservice.createEmailService;
const mockSendEmailWithRetry = require('@/lib/services/email-service').sendEmailWithRetry;
const mockDb = require('@/lib/db').db;
const mockGetUserByEmail = require('@/lib/auth').getUserByEmail;
const mockGetUserById = require('@/lib/auth').getUserById;
// Mock environment variables
const originalEnv = process.env;
beforeAll(()=>{
    process.env = {
        ...originalEnv,
        RESEND_API_KEY: 'test-api-key',
        FROM_EMAIL: 'test@example.com',
        FROM_NAME: 'Test App',
        VERIFICATION_CODE_EXPIRY_MINUTES: '10',
        MAX_VERIFICATION_ATTEMPTS: '5',
        RESEND_COOLDOWN_SECONDS: '60',
        MAX_RESEND_PER_HOUR: '5',
        NODE_ENV: 'test'
    };
});
afterAll(()=>{
    process.env = originalEnv;
});
describe('Email Verification Flow Integration Tests', ()=>{
    let dbManager;
    beforeEach(async ()=>{
        jest.clearAllMocks();
        dbManager = createDatabaseTestManager();
        // Mock email service to always succeed
        mockCreateEmailService.mockReturnValue(mockEmailService);
        mockSendEmailWithRetry.mockResolvedValue(true);
        mockEmailService.sendVerificationEmail.mockResolvedValue(true);
    });
    afterEach(async ()=>{
        await dbManager.cleanup();
    });
    describe('Complete Signup and Verification Process', ()=>{
        it('should complete full signup and verification workflow', async ()=>{
            // Step 1: Create user and verification code directly
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Step 2: Generate verification code
            const verificationCode = await _emailverificationcodeservice.emailVerificationCodeService.generateCode(user.id);
            expect(verificationCode).toMatch(/^\d{6}$/);
            // Step 3: Verify the code was stored in database
            const emailCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(emailCodes).toHaveLength(1);
            expect(emailCodes[0].code).toBe(verificationCode);
            // Step 4: Validate the verification code
            const isValid = await _emailverificationcodeservice.emailVerificationCodeService.validateCode('test@example.com', verificationCode);
            expect(isValid).toBe(true);
            // Step 5: Verify user is now verified in database
            const verifiedUser = await dbManager.getUserById(user.id);
            expect(verifiedUser.isEmailVerified).toBe(true);
            // Step 6: Verify verification code was deleted
            const remainingCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(remainingCodes).toHaveLength(0);
        });
        it('should handle email service failure gracefully during code generation', async ()=>{
            // Create user
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Generate verification code (this should work even if email fails)
            const verificationCode = await _emailverificationcodeservice.emailVerificationCodeService.generateCode(user.id);
            expect(verificationCode).toMatch(/^\d{6}$/);
            // Verify code was stored in database
            const emailCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(emailCodes).toHaveLength(1);
            expect(emailCodes[0].code).toBe(verificationCode);
            // User should still be unverified
            const unverifiedUser = await dbManager.getUserById(user.id);
            expect(unverifiedUser.isEmailVerified).toBe(false);
        });
        it('should reject verification with invalid code', async ()=>{
            // Create user and verification code
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '123456',
                expiresAt: new Date(Date.now() + 10 * 60 * 1000),
                attemptsUsed: 0
            });
            // Try to verify with wrong code using service directly
            try {
                await _emailverificationcodeservice.emailVerificationCodeService.validateCode('test@example.com', '654321');
                fail('Should have thrown an error for invalid code');
            } catch (error) {
                expect(error.code).toBe('CODE_INVALID');
            }
            // Verify user is still not verified
            const unverifiedUser = await dbManager.getUserById(user.id);
            expect(unverifiedUser.isEmailVerified).toBe(false);
        });
        it('should reject verification with expired code', async ()=>{
            // Create user and expired verification code
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '123456',
                expiresAt: new Date(Date.now() - 1000),
                attemptsUsed: 0
            });
            // Try to verify with expired code using service directly
            try {
                await _emailverificationcodeservice.emailVerificationCodeService.validateCode('test@example.com', '123456');
                fail('Should have thrown an error for expired code');
            } catch (error) {
                expect(error.code).toBe('CODE_EXPIRED');
            }
            // Verify user is still not verified
            const unverifiedUser = await dbManager.getUserById(user.id);
            expect(unverifiedUser.isEmailVerified).toBe(false);
        });
    });
    describe('Resend Verification Code Functionality', ()=>{
        it('should resend verification code by generating new code', async ()=>{
            // Create unverified user
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Create existing verification code
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '123456',
                expiresAt: new Date(Date.now() + 10 * 60 * 1000),
                attemptsUsed: 0
            });
            // Generate new verification code (simulating resend)
            const newCode = await _emailverificationcodeservice.emailVerificationCodeService.generateCode(user.id);
            expect(newCode).toMatch(/^\d{6}$/);
            expect(newCode).not.toBe('123456'); // Should be a new code
            // Verify new code was generated (old one should be invalidated)
            const emailCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(emailCodes).toHaveLength(1);
            expect(emailCodes[0].code).toBe(newCode);
        });
        it('should handle resend for already verified user', async ()=>{
            // Create verified user
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: true
            });
            // Try to generate code for already verified user
            try {
                await _emailverificationcodeservice.emailVerificationCodeService.generateCode(user.id);
                fail('Should have thrown an error for already verified user');
            } catch (error) {
                expect(error.code).toBe('ALREADY_VERIFIED');
            }
        });
        it('should handle resend for non-existent user', async ()=>{
            // Try to validate code for non-existent user
            try {
                await _emailverificationcodeservice.emailVerificationCodeService.validateCode('nonexistent@example.com', '123456');
                fail('Should have thrown an error for non-existent user');
            } catch (error) {
                expect(error.code).toBe('USER_NOT_FOUND');
            }
        });
    });
    describe('Rate Limiting Enforcement', ()=>{
        it('should enforce verification attempt limits', async ()=>{
            // Create user and verification code
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            const emailCode = await dbManager.createTestEmailCode({
                userId: user.id,
                code: '123456',
                expiresAt: new Date(Date.now() + 10 * 60 * 1000),
                attemptsUsed: 5
            });
            // Try to verify with max attempts reached
            try {
                await _emailverificationcodeservice.emailVerificationCodeService.validateCode('test@example.com', '123456');
                fail('Should have thrown an error for too many attempts');
            } catch (error) {
                expect(error.code).toBe('TOO_MANY_ATTEMPTS');
            }
            // Verify user is still not verified
            const unverifiedUser = await dbManager.getUserById(user.id);
            expect(unverifiedUser.isEmailVerified).toBe(false);
        });
        it('should handle validation at service level', async ()=>{
            // Create user for testing
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Generate valid code
            const validCode = await _emailverificationcodeservice.emailVerificationCodeService.generateCode(user.id);
            expect(validCode).toMatch(/^\d{6}$/);
            // Test that service validates codes properly
            const isValid = await _emailverificationcodeservice.emailVerificationCodeService.validateCode('test@example.com', validCode);
            expect(isValid).toBe(true);
            // Verify user is now verified
            const verifiedUser = await dbManager.getUserById(user.id);
            expect(verifiedUser.isEmailVerified).toBe(true);
        });
    });
    describe('Edge Cases and Error Scenarios', ()=>{
        it('should handle duplicate verification code generation', async ()=>{
            // Create user
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Generate first code
            const firstCode = await _emailverificationcodeservice.emailVerificationCodeService.generateCode(user.id);
            expect(firstCode).toMatch(/^\d{6}$/);
            // Generate second code (should invalidate first)
            const secondCode = await _emailverificationcodeservice.emailVerificationCodeService.generateCode(user.id);
            expect(secondCode).toMatch(/^\d{6}$/);
            expect(secondCode).not.toBe(firstCode);
            // Verify only one code exists
            const emailCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(emailCodes).toHaveLength(1);
            expect(emailCodes[0].code).toBe(secondCode);
        });
        it('should handle service errors gracefully', async ()=>{
            // Test with non-existent user ID
            try {
                await _emailverificationcodeservice.emailVerificationCodeService.generateCode(99999); // Non-existent user ID
                fail('Should have thrown an error for non-existent user');
            } catch (error) {
                expect(error.code).toBe('USER_NOT_FOUND');
            }
        });
        it('should handle cleanup of expired codes', async ()=>{
            // Create user with expired code
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '123456',
                expiresAt: new Date(Date.now() - 60000),
                attemptsUsed: 0
            });
            // Run cleanup
            await _emailverificationcodeservice.emailVerificationCodeService.cleanupExpiredCodes();
            // Verify expired code was cleaned up
            const remainingCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(remainingCodes).toHaveLength(0);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdGVmYW5iZWtrZXIvcHJvamVjdHMvZmFuY3ktcGxhbnRpZXMvc3JjL19fdGVzdHNfXy9pbnRlZ3JhdGlvbi9lbWFpbC12ZXJpZmljYXRpb24tZmxvdy50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRW1haWwgVmVyaWZpY2F0aW9uIEZsb3cgSW50ZWdyYXRpb24gVGVzdHNcbiAqIFRlc3RzIGNvbXBsZXRlIHNpZ251cCBhbmQgdmVyaWZpY2F0aW9uIHByb2Nlc3MsIHJlc2VuZCBmdW5jdGlvbmFsaXR5LCBhbmQgcmF0ZSBsaW1pdGluZ1xuICogUmVxdWlyZW1lbnRzOiAxLjEsIDEuNCwgMi4xLCAyLjJcbiAqL1xuXG5pbXBvcnQgeyBlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlIH0gZnJvbSAnQC9saWIvc2VydmljZXMvZW1haWwtdmVyaWZpY2F0aW9uLWNvZGUtc2VydmljZSc7XG5pbXBvcnQgeyBjcmVhdGVFbWFpbFNlcnZpY2UgfSBmcm9tICdAL2xpYi9zZXJ2aWNlcy9yZXNlbmQtZW1haWwtc2VydmljZSc7XG5cbi8vIE1vY2sgZW1haWwgc2VydmljZVxuamVzdC5tb2NrKCdAL2xpYi9zZXJ2aWNlcy9yZXNlbmQtZW1haWwtc2VydmljZScpO1xuamVzdC5tb2NrKCdAL2xpYi9zZXJ2aWNlcy9lbWFpbC1zZXJ2aWNlJyk7XG5cbi8vIE1vY2sgZGF0YWJhc2Vcbmplc3QubW9jaygnQC9saWIvZGInLCAoKSA9PiAoe1xuICBkYjoge1xuICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgZnJvbTogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgd2hlcmU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxuICAgIGluc2VydDogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgdmFsdWVzOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgICB1cGRhdGU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxuICAgIHNldDogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgZGVsZXRlOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgICByZXR1cm5pbmc6IGplc3QuZm4oKSxcbiAgICBleGVjdXRlOiBqZXN0LmZuKCksXG4gIH0sXG59KSk7XG5cbi8vIE1vY2sgYXV0aCBmdW5jdGlvbnNcbmplc3QubW9jaygnQC9saWIvYXV0aCcsICgpID0+ICh7XG4gIGdldFVzZXJCeUVtYWlsOiBqZXN0LmZuKCksXG4gIGdldFVzZXJCeUlkOiBqZXN0LmZuKCksXG59KSk7XG5cbmNvbnN0IG1vY2tFbWFpbFNlcnZpY2UgPSB7XG4gIHNlbmRWZXJpZmljYXRpb25FbWFpbDogamVzdC5mbigpLFxufTtcblxuY29uc3QgbW9ja0NyZWF0ZUVtYWlsU2VydmljZSA9IGNyZWF0ZUVtYWlsU2VydmljZSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiBjcmVhdGVFbWFpbFNlcnZpY2U+O1xuY29uc3QgbW9ja1NlbmRFbWFpbFdpdGhSZXRyeSA9IHJlcXVpcmUoJ0AvbGliL3NlcnZpY2VzL2VtYWlsLXNlcnZpY2UnKS5zZW5kRW1haWxXaXRoUmV0cnkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+O1xuY29uc3QgbW9ja0RiID0gcmVxdWlyZSgnQC9saWIvZGInKS5kYjtcbmNvbnN0IG1vY2tHZXRVc2VyQnlFbWFpbCA9IHJlcXVpcmUoJ0AvbGliL2F1dGgnKS5nZXRVc2VyQnlFbWFpbCBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT47XG5jb25zdCBtb2NrR2V0VXNlckJ5SWQgPSByZXF1aXJlKCdAL2xpYi9hdXRoJykuZ2V0VXNlckJ5SWQgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+O1xuXG4vLyBNb2NrIGVudmlyb25tZW50IHZhcmlhYmxlc1xuY29uc3Qgb3JpZ2luYWxFbnYgPSBwcm9jZXNzLmVudjtcblxuYmVmb3JlQWxsKCgpID0+IHtcbiAgcHJvY2Vzcy5lbnYgPSB7XG4gICAgLi4ub3JpZ2luYWxFbnYsXG4gICAgUkVTRU5EX0FQSV9LRVk6ICd0ZXN0LWFwaS1rZXknLFxuICAgIEZST01fRU1BSUw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICBGUk9NX05BTUU6ICdUZXN0IEFwcCcsXG4gICAgVkVSSUZJQ0FUSU9OX0NPREVfRVhQSVJZX01JTlVURVM6ICcxMCcsXG4gICAgTUFYX1ZFUklGSUNBVElPTl9BVFRFTVBUUzogJzUnLFxuICAgIFJFU0VORF9DT09MRE9XTl9TRUNPTkRTOiAnNjAnLFxuICAgIE1BWF9SRVNFTkRfUEVSX0hPVVI6ICc1JyxcbiAgICBOT0RFX0VOVjogJ3Rlc3QnLFxuICB9O1xufSk7XG5cbmFmdGVyQWxsKCgpID0+IHtcbiAgcHJvY2Vzcy5lbnYgPSBvcmlnaW5hbEVudjtcbn0pO1xuXG5kZXNjcmliZSgnRW1haWwgVmVyaWZpY2F0aW9uIEZsb3cgSW50ZWdyYXRpb24gVGVzdHMnLCAoKSA9PiB7XG4gIGxldCBkYk1hbmFnZXI6IGFueTtcblxuICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICBkYk1hbmFnZXIgPSBjcmVhdGVEYXRhYmFzZVRlc3RNYW5hZ2VyKCk7XG4gICAgXG4gICAgLy8gTW9jayBlbWFpbCBzZXJ2aWNlIHRvIGFsd2F5cyBzdWNjZWVkXG4gICAgbW9ja0NyZWF0ZUVtYWlsU2VydmljZS5tb2NrUmV0dXJuVmFsdWUobW9ja0VtYWlsU2VydmljZSk7XG4gICAgbW9ja1NlbmRFbWFpbFdpdGhSZXRyeS5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKTtcbiAgICBtb2NrRW1haWxTZXJ2aWNlLnNlbmRWZXJpZmljYXRpb25FbWFpbC5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBkYk1hbmFnZXIuY2xlYW51cCgpO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ29tcGxldGUgU2lnbnVwIGFuZCBWZXJpZmljYXRpb24gUHJvY2VzcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGNvbXBsZXRlIGZ1bGwgc2lnbnVwIGFuZCB2ZXJpZmljYXRpb24gd29ya2Zsb3cnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBTdGVwIDE6IENyZWF0ZSB1c2VyIGFuZCB2ZXJpZmljYXRpb24gY29kZSBkaXJlY3RseVxuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0VXNlcih7XG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgICBwYXNzd29yZEhhc2g6ICdoYXNoZWRfcGFzc3dvcmQnLFxuICAgICAgICBpc0VtYWlsVmVyaWZpZWQ6IGZhbHNlLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFN0ZXAgMjogR2VuZXJhdGUgdmVyaWZpY2F0aW9uIGNvZGVcbiAgICAgIGNvbnN0IHZlcmlmaWNhdGlvbkNvZGUgPSBhd2FpdCBlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlLmdlbmVyYXRlQ29kZSh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdCh2ZXJpZmljYXRpb25Db2RlKS50b01hdGNoKC9eXFxkezZ9JC8pO1xuXG4gICAgICAvLyBTdGVwIDM6IFZlcmlmeSB0aGUgY29kZSB3YXMgc3RvcmVkIGluIGRhdGFiYXNlXG4gICAgICBjb25zdCBlbWFpbENvZGVzID0gYXdhaXQgZGJNYW5hZ2VyLmdldEVtYWlsQ29kZXNCeVVzZXJJZCh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdChlbWFpbENvZGVzKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QoZW1haWxDb2Rlc1swXS5jb2RlKS50b0JlKHZlcmlmaWNhdGlvbkNvZGUpO1xuXG4gICAgICAvLyBTdGVwIDQ6IFZhbGlkYXRlIHRoZSB2ZXJpZmljYXRpb24gY29kZVxuICAgICAgY29uc3QgaXNWYWxpZCA9IGF3YWl0IGVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UudmFsaWRhdGVDb2RlKCd0ZXN0QGV4YW1wbGUuY29tJywgdmVyaWZpY2F0aW9uQ29kZSk7XG4gICAgICBleHBlY3QoaXNWYWxpZCkudG9CZSh0cnVlKTtcblxuICAgICAgLy8gU3RlcCA1OiBWZXJpZnkgdXNlciBpcyBub3cgdmVyaWZpZWQgaW4gZGF0YWJhc2VcbiAgICAgIGNvbnN0IHZlcmlmaWVkVXNlciA9IGF3YWl0IGRiTWFuYWdlci5nZXRVc2VyQnlJZCh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdCh2ZXJpZmllZFVzZXIuaXNFbWFpbFZlcmlmaWVkKS50b0JlKHRydWUpO1xuXG4gICAgICAvLyBTdGVwIDY6IFZlcmlmeSB2ZXJpZmljYXRpb24gY29kZSB3YXMgZGVsZXRlZFxuICAgICAgY29uc3QgcmVtYWluaW5nQ29kZXMgPSBhd2FpdCBkYk1hbmFnZXIuZ2V0RW1haWxDb2Rlc0J5VXNlcklkKHVzZXIuaWQpO1xuICAgICAgZXhwZWN0KHJlbWFpbmluZ0NvZGVzKS50b0hhdmVMZW5ndGgoMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBlbWFpbCBzZXJ2aWNlIGZhaWx1cmUgZ3JhY2VmdWxseSBkdXJpbmcgY29kZSBnZW5lcmF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIHVzZXJcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdFVzZXIoe1xuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAnVGVzdCBVc2VyJyxcbiAgICAgICAgcGFzc3dvcmRIYXNoOiAnaGFzaGVkX3Bhc3N3b3JkJyxcbiAgICAgICAgaXNFbWFpbFZlcmlmaWVkOiBmYWxzZSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBHZW5lcmF0ZSB2ZXJpZmljYXRpb24gY29kZSAodGhpcyBzaG91bGQgd29yayBldmVuIGlmIGVtYWlsIGZhaWxzKVxuICAgICAgY29uc3QgdmVyaWZpY2F0aW9uQ29kZSA9IGF3YWl0IGVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UuZ2VuZXJhdGVDb2RlKHVzZXIuaWQpO1xuICAgICAgZXhwZWN0KHZlcmlmaWNhdGlvbkNvZGUpLnRvTWF0Y2goL15cXGR7Nn0kLyk7XG5cbiAgICAgIC8vIFZlcmlmeSBjb2RlIHdhcyBzdG9yZWQgaW4gZGF0YWJhc2VcbiAgICAgIGNvbnN0IGVtYWlsQ29kZXMgPSBhd2FpdCBkYk1hbmFnZXIuZ2V0RW1haWxDb2Rlc0J5VXNlcklkKHVzZXIuaWQpO1xuICAgICAgZXhwZWN0KGVtYWlsQ29kZXMpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChlbWFpbENvZGVzWzBdLmNvZGUpLnRvQmUodmVyaWZpY2F0aW9uQ29kZSk7XG5cbiAgICAgIC8vIFVzZXIgc2hvdWxkIHN0aWxsIGJlIHVudmVyaWZpZWRcbiAgICAgIGNvbnN0IHVudmVyaWZpZWRVc2VyID0gYXdhaXQgZGJNYW5hZ2VyLmdldFVzZXJCeUlkKHVzZXIuaWQpO1xuICAgICAgZXhwZWN0KHVudmVyaWZpZWRVc2VyLmlzRW1haWxWZXJpZmllZCkudG9CZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCB2ZXJpZmljYXRpb24gd2l0aCBpbnZhbGlkIGNvZGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBDcmVhdGUgdXNlciBhbmQgdmVyaWZpY2F0aW9uIGNvZGVcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdFVzZXIoe1xuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAnVGVzdCBVc2VyJyxcbiAgICAgICAgcGFzc3dvcmRIYXNoOiAnaGFzaGVkX3Bhc3N3b3JkJyxcbiAgICAgICAgaXNFbWFpbFZlcmlmaWVkOiBmYWxzZSxcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdEVtYWlsQ29kZSh7XG4gICAgICAgIHVzZXJJZDogdXNlci5pZCxcbiAgICAgICAgY29kZTogJzEyMzQ1NicsXG4gICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIDEwICogNjAgKiAxMDAwKSwgLy8gMTAgbWludXRlcyBmcm9tIG5vd1xuICAgICAgICBhdHRlbXB0c1VzZWQ6IDAsXG4gICAgICB9KTtcblxuICAgICAgLy8gVHJ5IHRvIHZlcmlmeSB3aXRoIHdyb25nIGNvZGUgdXNpbmcgc2VydmljZSBkaXJlY3RseVxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS52YWxpZGF0ZUNvZGUoJ3Rlc3RAZXhhbXBsZS5jb20nLCAnNjU0MzIxJyk7XG4gICAgICAgIGZhaWwoJ1Nob3VsZCBoYXZlIHRocm93biBhbiBlcnJvciBmb3IgaW52YWxpZCBjb2RlJyk7XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIGV4cGVjdChlcnJvci5jb2RlKS50b0JlKCdDT0RFX0lOVkFMSUQnKTtcbiAgICAgIH1cblxuICAgICAgLy8gVmVyaWZ5IHVzZXIgaXMgc3RpbGwgbm90IHZlcmlmaWVkXG4gICAgICBjb25zdCB1bnZlcmlmaWVkVXNlciA9IGF3YWl0IGRiTWFuYWdlci5nZXRVc2VyQnlJZCh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdCh1bnZlcmlmaWVkVXNlci5pc0VtYWlsVmVyaWZpZWQpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3QgdmVyaWZpY2F0aW9uIHdpdGggZXhwaXJlZCBjb2RlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIHVzZXIgYW5kIGV4cGlyZWQgdmVyaWZpY2F0aW9uIGNvZGVcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdFVzZXIoe1xuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAnVGVzdCBVc2VyJyxcbiAgICAgICAgcGFzc3dvcmRIYXNoOiAnaGFzaGVkX3Bhc3N3b3JkJyxcbiAgICAgICAgaXNFbWFpbFZlcmlmaWVkOiBmYWxzZSxcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdEVtYWlsQ29kZSh7XG4gICAgICAgIHVzZXJJZDogdXNlci5pZCxcbiAgICAgICAgY29kZTogJzEyMzQ1NicsXG4gICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDEwMDApLCAvLyBFeHBpcmVkIDEgc2Vjb25kIGFnb1xuICAgICAgICBhdHRlbXB0c1VzZWQ6IDAsXG4gICAgICB9KTtcblxuICAgICAgLy8gVHJ5IHRvIHZlcmlmeSB3aXRoIGV4cGlyZWQgY29kZSB1c2luZyBzZXJ2aWNlIGRpcmVjdGx5XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlLnZhbGlkYXRlQ29kZSgndGVzdEBleGFtcGxlLmNvbScsICcxMjM0NTYnKTtcbiAgICAgICAgZmFpbCgnU2hvdWxkIGhhdmUgdGhyb3duIGFuIGVycm9yIGZvciBleHBpcmVkIGNvZGUnKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgZXhwZWN0KGVycm9yLmNvZGUpLnRvQmUoJ0NPREVfRVhQSVJFRCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBWZXJpZnkgdXNlciBpcyBzdGlsbCBub3QgdmVyaWZpZWRcbiAgICAgIGNvbnN0IHVudmVyaWZpZWRVc2VyID0gYXdhaXQgZGJNYW5hZ2VyLmdldFVzZXJCeUlkKHVzZXIuaWQpO1xuICAgICAgZXhwZWN0KHVudmVyaWZpZWRVc2VyLmlzRW1haWxWZXJpZmllZCkudG9CZShmYWxzZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdSZXNlbmQgVmVyaWZpY2F0aW9uIENvZGUgRnVuY3Rpb25hbGl0eScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJlc2VuZCB2ZXJpZmljYXRpb24gY29kZSBieSBnZW5lcmF0aW5nIG5ldyBjb2RlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIHVudmVyaWZpZWQgdXNlclxuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0VXNlcih7XG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgICBwYXNzd29yZEhhc2g6ICdoYXNoZWRfcGFzc3dvcmQnLFxuICAgICAgICBpc0VtYWlsVmVyaWZpZWQ6IGZhbHNlLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIENyZWF0ZSBleGlzdGluZyB2ZXJpZmljYXRpb24gY29kZVxuICAgICAgYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RFbWFpbENvZGUoe1xuICAgICAgICB1c2VySWQ6IHVzZXIuaWQsXG4gICAgICAgIGNvZGU6ICcxMjM0NTYnLFxuICAgICAgICBleHBpcmVzQXQ6IG5ldyBEYXRlKERhdGUubm93KCkgKyAxMCAqIDYwICogMTAwMCksXG4gICAgICAgIGF0dGVtcHRzVXNlZDogMCxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBHZW5lcmF0ZSBuZXcgdmVyaWZpY2F0aW9uIGNvZGUgKHNpbXVsYXRpbmcgcmVzZW5kKVxuICAgICAgY29uc3QgbmV3Q29kZSA9IGF3YWl0IGVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UuZ2VuZXJhdGVDb2RlKHVzZXIuaWQpO1xuICAgICAgZXhwZWN0KG5ld0NvZGUpLnRvTWF0Y2goL15cXGR7Nn0kLyk7XG4gICAgICBleHBlY3QobmV3Q29kZSkubm90LnRvQmUoJzEyMzQ1NicpOyAvLyBTaG91bGQgYmUgYSBuZXcgY29kZVxuXG4gICAgICAvLyBWZXJpZnkgbmV3IGNvZGUgd2FzIGdlbmVyYXRlZCAob2xkIG9uZSBzaG91bGQgYmUgaW52YWxpZGF0ZWQpXG4gICAgICBjb25zdCBlbWFpbENvZGVzID0gYXdhaXQgZGJNYW5hZ2VyLmdldEVtYWlsQ29kZXNCeVVzZXJJZCh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdChlbWFpbENvZGVzKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QoZW1haWxDb2Rlc1swXS5jb2RlKS50b0JlKG5ld0NvZGUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgcmVzZW5kIGZvciBhbHJlYWR5IHZlcmlmaWVkIHVzZXInLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBDcmVhdGUgdmVyaWZpZWQgdXNlclxuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0VXNlcih7XG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgICBwYXNzd29yZEhhc2g6ICdoYXNoZWRfcGFzc3dvcmQnLFxuICAgICAgICBpc0VtYWlsVmVyaWZpZWQ6IHRydWUsIC8vIEFscmVhZHkgdmVyaWZpZWRcbiAgICAgIH0pO1xuXG4gICAgICAvLyBUcnkgdG8gZ2VuZXJhdGUgY29kZSBmb3IgYWxyZWFkeSB2ZXJpZmllZCB1c2VyXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlLmdlbmVyYXRlQ29kZSh1c2VyLmlkKTtcbiAgICAgICAgZmFpbCgnU2hvdWxkIGhhdmUgdGhyb3duIGFuIGVycm9yIGZvciBhbHJlYWR5IHZlcmlmaWVkIHVzZXInKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgZXhwZWN0KGVycm9yLmNvZGUpLnRvQmUoJ0FMUkVBRFlfVkVSSUZJRUQnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHJlc2VuZCBmb3Igbm9uLWV4aXN0ZW50IHVzZXInLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBUcnkgdG8gdmFsaWRhdGUgY29kZSBmb3Igbm9uLWV4aXN0ZW50IHVzZXJcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UudmFsaWRhdGVDb2RlKCdub25leGlzdGVudEBleGFtcGxlLmNvbScsICcxMjM0NTYnKTtcbiAgICAgICAgZmFpbCgnU2hvdWxkIGhhdmUgdGhyb3duIGFuIGVycm9yIGZvciBub24tZXhpc3RlbnQgdXNlcicpO1xuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBleHBlY3QoZXJyb3IuY29kZSkudG9CZSgnVVNFUl9OT1RfRk9VTkQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1JhdGUgTGltaXRpbmcgRW5mb3JjZW1lbnQnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBlbmZvcmNlIHZlcmlmaWNhdGlvbiBhdHRlbXB0IGxpbWl0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSB1c2VyIGFuZCB2ZXJpZmljYXRpb24gY29kZVxuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0VXNlcih7XG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgICBwYXNzd29yZEhhc2g6ICdoYXNoZWRfcGFzc3dvcmQnLFxuICAgICAgICBpc0VtYWlsVmVyaWZpZWQ6IGZhbHNlLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGVtYWlsQ29kZSA9IGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0RW1haWxDb2RlKHtcbiAgICAgICAgdXNlcklkOiB1c2VyLmlkLFxuICAgICAgICBjb2RlOiAnMTIzNDU2JyxcbiAgICAgICAgZXhwaXJlc0F0OiBuZXcgRGF0ZShEYXRlLm5vdygpICsgMTAgKiA2MCAqIDEwMDApLFxuICAgICAgICBhdHRlbXB0c1VzZWQ6IDUsIC8vIEFscmVhZHkgYXQgbWF4IGF0dGVtcHRzIChsaW1pdCBpcyA1KVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFRyeSB0byB2ZXJpZnkgd2l0aCBtYXggYXR0ZW1wdHMgcmVhY2hlZFxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS52YWxpZGF0ZUNvZGUoJ3Rlc3RAZXhhbXBsZS5jb20nLCAnMTIzNDU2Jyk7XG4gICAgICAgIGZhaWwoJ1Nob3VsZCBoYXZlIHRocm93biBhbiBlcnJvciBmb3IgdG9vIG1hbnkgYXR0ZW1wdHMnKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgZXhwZWN0KGVycm9yLmNvZGUpLnRvQmUoJ1RPT19NQU5ZX0FUVEVNUFRTJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFZlcmlmeSB1c2VyIGlzIHN0aWxsIG5vdCB2ZXJpZmllZFxuICAgICAgY29uc3QgdW52ZXJpZmllZFVzZXIgPSBhd2FpdCBkYk1hbmFnZXIuZ2V0VXNlckJ5SWQodXNlci5pZCk7XG4gICAgICBleHBlY3QodW52ZXJpZmllZFVzZXIuaXNFbWFpbFZlcmlmaWVkKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHZhbGlkYXRpb24gYXQgc2VydmljZSBsZXZlbCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSB1c2VyIGZvciB0ZXN0aW5nXG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RVc2VyKHtcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgICAgIHBhc3N3b3JkSGFzaDogJ2hhc2hlZF9wYXNzd29yZCcsXG4gICAgICAgIGlzRW1haWxWZXJpZmllZDogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgLy8gR2VuZXJhdGUgdmFsaWQgY29kZVxuICAgICAgY29uc3QgdmFsaWRDb2RlID0gYXdhaXQgZW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS5nZW5lcmF0ZUNvZGUodXNlci5pZCk7XG4gICAgICBleHBlY3QodmFsaWRDb2RlKS50b01hdGNoKC9eXFxkezZ9JC8pO1xuXG4gICAgICAvLyBUZXN0IHRoYXQgc2VydmljZSB2YWxpZGF0ZXMgY29kZXMgcHJvcGVybHlcbiAgICAgIGNvbnN0IGlzVmFsaWQgPSBhd2FpdCBlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlLnZhbGlkYXRlQ29kZSgndGVzdEBleGFtcGxlLmNvbScsIHZhbGlkQ29kZSk7XG4gICAgICBleHBlY3QoaXNWYWxpZCkudG9CZSh0cnVlKTtcblxuICAgICAgLy8gVmVyaWZ5IHVzZXIgaXMgbm93IHZlcmlmaWVkXG4gICAgICBjb25zdCB2ZXJpZmllZFVzZXIgPSBhd2FpdCBkYk1hbmFnZXIuZ2V0VXNlckJ5SWQodXNlci5pZCk7XG4gICAgICBleHBlY3QodmVyaWZpZWRVc2VyLmlzRW1haWxWZXJpZmllZCkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0VkZ2UgQ2FzZXMgYW5kIEVycm9yIFNjZW5hcmlvcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBkdXBsaWNhdGUgdmVyaWZpY2F0aW9uIGNvZGUgZ2VuZXJhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSB1c2VyXG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RVc2VyKHtcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgICAgIHBhc3N3b3JkSGFzaDogJ2hhc2hlZF9wYXNzd29yZCcsXG4gICAgICAgIGlzRW1haWxWZXJpZmllZDogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgLy8gR2VuZXJhdGUgZmlyc3QgY29kZVxuICAgICAgY29uc3QgZmlyc3RDb2RlID0gYXdhaXQgZW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS5nZW5lcmF0ZUNvZGUodXNlci5pZCk7XG4gICAgICBleHBlY3QoZmlyc3RDb2RlKS50b01hdGNoKC9eXFxkezZ9JC8pO1xuXG4gICAgICAvLyBHZW5lcmF0ZSBzZWNvbmQgY29kZSAoc2hvdWxkIGludmFsaWRhdGUgZmlyc3QpXG4gICAgICBjb25zdCBzZWNvbmRDb2RlID0gYXdhaXQgZW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS5nZW5lcmF0ZUNvZGUodXNlci5pZCk7XG4gICAgICBleHBlY3Qoc2Vjb25kQ29kZSkudG9NYXRjaCgvXlxcZHs2fSQvKTtcbiAgICAgIGV4cGVjdChzZWNvbmRDb2RlKS5ub3QudG9CZShmaXJzdENvZGUpO1xuXG4gICAgICAvLyBWZXJpZnkgb25seSBvbmUgY29kZSBleGlzdHNcbiAgICAgIGNvbnN0IGVtYWlsQ29kZXMgPSBhd2FpdCBkYk1hbmFnZXIuZ2V0RW1haWxDb2Rlc0J5VXNlcklkKHVzZXIuaWQpO1xuICAgICAgZXhwZWN0KGVtYWlsQ29kZXMpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChlbWFpbENvZGVzWzBdLmNvZGUpLnRvQmUoc2Vjb25kQ29kZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBzZXJ2aWNlIGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gVGVzdCB3aXRoIG5vbi1leGlzdGVudCB1c2VyIElEXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlLmdlbmVyYXRlQ29kZSg5OTk5OSk7IC8vIE5vbi1leGlzdGVudCB1c2VyIElEXG4gICAgICAgIGZhaWwoJ1Nob3VsZCBoYXZlIHRocm93biBhbiBlcnJvciBmb3Igbm9uLWV4aXN0ZW50IHVzZXInKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgZXhwZWN0KGVycm9yLmNvZGUpLnRvQmUoJ1VTRVJfTk9UX0ZPVU5EJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjbGVhbnVwIG9mIGV4cGlyZWQgY29kZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBDcmVhdGUgdXNlciB3aXRoIGV4cGlyZWQgY29kZVxuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0VXNlcih7XG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgICBwYXNzd29yZEhhc2g6ICdoYXNoZWRfcGFzc3dvcmQnLFxuICAgICAgICBpc0VtYWlsVmVyaWZpZWQ6IGZhbHNlLFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0RW1haWxDb2RlKHtcbiAgICAgICAgdXNlcklkOiB1c2VyLmlkLFxuICAgICAgICBjb2RlOiAnMTIzNDU2JyxcbiAgICAgICAgZXhwaXJlc0F0OiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gNjAwMDApLCAvLyBFeHBpcmVkIDEgbWludXRlIGFnb1xuICAgICAgICBhdHRlbXB0c1VzZWQ6IDAsXG4gICAgICB9KTtcblxuICAgICAgLy8gUnVuIGNsZWFudXBcbiAgICAgIGF3YWl0IGVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UuY2xlYW51cEV4cGlyZWRDb2RlcygpO1xuXG4gICAgICAvLyBWZXJpZnkgZXhwaXJlZCBjb2RlIHdhcyBjbGVhbmVkIHVwXG4gICAgICBjb25zdCByZW1haW5pbmdDb2RlcyA9IGF3YWl0IGRiTWFuYWdlci5nZXRFbWFpbENvZGVzQnlVc2VySWQodXNlci5pZCk7XG4gICAgICBleHBlY3QocmVtYWluaW5nQ29kZXMpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICB9KTtcbiAgfSk7XG59KTsiXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJkYiIsInNlbGVjdCIsImZuIiwibW9ja1JldHVyblRoaXMiLCJmcm9tIiwid2hlcmUiLCJpbnNlcnQiLCJ2YWx1ZXMiLCJ1cGRhdGUiLCJzZXQiLCJkZWxldGUiLCJyZXR1cm5pbmciLCJleGVjdXRlIiwiZ2V0VXNlckJ5RW1haWwiLCJnZXRVc2VyQnlJZCIsIm1vY2tFbWFpbFNlcnZpY2UiLCJzZW5kVmVyaWZpY2F0aW9uRW1haWwiLCJtb2NrQ3JlYXRlRW1haWxTZXJ2aWNlIiwiY3JlYXRlRW1haWxTZXJ2aWNlIiwibW9ja1NlbmRFbWFpbFdpdGhSZXRyeSIsInJlcXVpcmUiLCJzZW5kRW1haWxXaXRoUmV0cnkiLCJtb2NrRGIiLCJtb2NrR2V0VXNlckJ5RW1haWwiLCJtb2NrR2V0VXNlckJ5SWQiLCJvcmlnaW5hbEVudiIsInByb2Nlc3MiLCJlbnYiLCJiZWZvcmVBbGwiLCJSRVNFTkRfQVBJX0tFWSIsIkZST01fRU1BSUwiLCJGUk9NX05BTUUiLCJWRVJJRklDQVRJT05fQ09ERV9FWFBJUllfTUlOVVRFUyIsIk1BWF9WRVJJRklDQVRJT05fQVRURU1QVFMiLCJSRVNFTkRfQ09PTERPV05fU0VDT05EUyIsIk1BWF9SRVNFTkRfUEVSX0hPVVIiLCJOT0RFX0VOViIsImFmdGVyQWxsIiwiZGVzY3JpYmUiLCJkYk1hbmFnZXIiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsImNyZWF0ZURhdGFiYXNlVGVzdE1hbmFnZXIiLCJtb2NrUmV0dXJuVmFsdWUiLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsImFmdGVyRWFjaCIsImNsZWFudXAiLCJpdCIsInVzZXIiLCJjcmVhdGVUZXN0VXNlciIsImVtYWlsIiwibmFtZSIsInBhc3N3b3JkSGFzaCIsImlzRW1haWxWZXJpZmllZCIsInZlcmlmaWNhdGlvbkNvZGUiLCJlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlIiwiZ2VuZXJhdGVDb2RlIiwiaWQiLCJleHBlY3QiLCJ0b01hdGNoIiwiZW1haWxDb2RlcyIsImdldEVtYWlsQ29kZXNCeVVzZXJJZCIsInRvSGF2ZUxlbmd0aCIsImNvZGUiLCJ0b0JlIiwiaXNWYWxpZCIsInZhbGlkYXRlQ29kZSIsInZlcmlmaWVkVXNlciIsInJlbWFpbmluZ0NvZGVzIiwidW52ZXJpZmllZFVzZXIiLCJjcmVhdGVUZXN0RW1haWxDb2RlIiwidXNlcklkIiwiZXhwaXJlc0F0IiwiRGF0ZSIsIm5vdyIsImF0dGVtcHRzVXNlZCIsImZhaWwiLCJlcnJvciIsIm5ld0NvZGUiLCJub3QiLCJlbWFpbENvZGUiLCJ2YWxpZENvZGUiLCJmaXJzdENvZGUiLCJzZWNvbmRDb2RlIiwiY2xlYW51cEV4cGlyZWRDb2RlcyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Q0FJQztBQUtELHFCQUFxQjtBQUNyQkEsS0FBS0MsSUFBSSxDQUFDO0FBQ1ZELEtBQUtDLElBQUksQ0FBQztBQUVWLGdCQUFnQjtBQUNoQkQsS0FBS0MsSUFBSSxDQUFDLFlBQVksSUFBTyxDQUFBO1FBQzNCQyxJQUFJO1lBQ0ZDLFFBQVFILEtBQUtJLEVBQUUsR0FBR0MsY0FBYztZQUNoQ0MsTUFBTU4sS0FBS0ksRUFBRSxHQUFHQyxjQUFjO1lBQzlCRSxPQUFPUCxLQUFLSSxFQUFFLEdBQUdDLGNBQWM7WUFDL0JHLFFBQVFSLEtBQUtJLEVBQUUsR0FBR0MsY0FBYztZQUNoQ0ksUUFBUVQsS0FBS0ksRUFBRSxHQUFHQyxjQUFjO1lBQ2hDSyxRQUFRVixLQUFLSSxFQUFFLEdBQUdDLGNBQWM7WUFDaENNLEtBQUtYLEtBQUtJLEVBQUUsR0FBR0MsY0FBYztZQUM3Qk8sUUFBUVosS0FBS0ksRUFBRSxHQUFHQyxjQUFjO1lBQ2hDUSxXQUFXYixLQUFLSSxFQUFFO1lBQ2xCVSxTQUFTZCxLQUFLSSxFQUFFO1FBQ2xCO0lBQ0YsQ0FBQTtBQUVBLHNCQUFzQjtBQUN0QkosS0FBS0MsSUFBSSxDQUFDLGNBQWMsSUFBTyxDQUFBO1FBQzdCYyxnQkFBZ0JmLEtBQUtJLEVBQUU7UUFDdkJZLGFBQWFoQixLQUFLSSxFQUFFO0lBQ3RCLENBQUE7Ozs7OENBM0I2QztvQ0FDVjtBQTRCbkMsTUFBTWEsbUJBQW1CO0lBQ3ZCQyx1QkFBdUJsQixLQUFLSSxFQUFFO0FBQ2hDO0FBRUEsTUFBTWUseUJBQXlCQyxzQ0FBa0I7QUFDakQsTUFBTUMseUJBQXlCQyxR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