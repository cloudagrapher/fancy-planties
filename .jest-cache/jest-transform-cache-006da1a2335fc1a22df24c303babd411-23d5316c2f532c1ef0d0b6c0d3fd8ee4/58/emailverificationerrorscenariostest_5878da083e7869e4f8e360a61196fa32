890e5c104a169d30d4832b5552cb3477
/**
 * Email Verification Error Scenario Tests
 * Tests email service failure handling, retry logic, expired code scenarios, 
 * cleanup processes, and concurrent verification attempts
 * Requirements: 1.4, 3.1, 7.3, 7.4
 */ "use strict";
// Mock email service and related modules
jest.mock('@/lib/services/resend-email-service');
jest.mock('@/lib/services/email-service');
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _server = require("next/server");
const _route = require("../../app/api/auth/signup/route");
const _route1 = require("../../app/api/auth/verify-email/route");
const _route2 = require("../../app/api/auth/resend-verification/route");
const _databasetestmanager = require("../../test-utils/setup/database-test-manager.js");
const _emailverificationcodeservice = require("../../lib/services/email-verification-code-service");
const _resendemailservice = require("../../lib/services/resend-email-service");
const _emailservice = require("../../lib/services/email-service");
const mockEmailService = {
    sendVerificationEmail: jest.fn()
};
const mockCreateEmailService = _resendemailservice.createEmailService;
const mockSendEmailWithRetry = require('@/lib/services/email-service').sendEmailWithRetry;
// Mock environment variables
const originalEnv = process.env;
beforeAll(()=>{
    process.env = {
        ...originalEnv,
        RESEND_API_KEY: 'test-api-key',
        FROM_EMAIL: 'test@example.com',
        FROM_NAME: 'Test App',
        VERIFICATION_CODE_EXPIRY_MINUTES: '10',
        MAX_VERIFICATION_ATTEMPTS: '5',
        RESEND_COOLDOWN_SECONDS: '60',
        MAX_RESEND_PER_HOUR: '5',
        NODE_ENV: 'test'
    };
});
afterAll(()=>{
    process.env = originalEnv;
});
describe('Email Verification Error Scenario Tests', ()=>{
    let dbManager;
    beforeEach(async ()=>{
        jest.clearAllMocks();
        dbManager = (0, _databasetestmanager.createDatabaseTestManager)();
        // Default to successful email service
        mockCreateEmailService.mockReturnValue(mockEmailService);
        mockSendEmailWithRetry.mockResolvedValue(true);
        mockEmailService.sendVerificationEmail.mockResolvedValue(true);
    });
    afterEach(async ()=>{
        await dbManager.cleanup();
    });
    describe('Email Service Failure Handling and Retry Logic', ()=>{
        it('should handle quota exceeded error with appropriate response', async ()=>{
            // Mock quota exceeded error
            const quotaError = new _emailservice.EmailServiceError('Quota exceeded', 'QUOTA_EXCEEDED');
            mockSendEmailWithRetry.mockRejectedValue(quotaError);
            const signupRequest = new _server.NextRequest('http://localhost/api/auth/signup', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'SecurePass123!',
                    name: 'Test User'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            const signupResponse = await (0, _route.POST)(signupRequest);
            const signupData = await signupResponse.json();
            // Assert user is created but email error is reported
            expect(signupResponse.status).toBe(200);
            expect(signupData.success).toBe(true);
            expect(signupData.requiresVerification).toBe(true);
            expect(signupData.emailError).toContain('Email service quota exceeded');
            // Verify user was created in database
            const user = await dbManager.getUserByEmail('test@example.com');
            expect(user).toBeTruthy();
            expect(user.isEmailVerified).toBe(false);
            // Verify verification code was still generated
            const emailCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(emailCodes).toHaveLength(1);
        });
        it('should handle API error with retry logic', async ()=>{
            // Mock API error that should trigger retry
            const apiError = new _emailservice.EmailServiceError('API error', 'API_ERROR');
            mockSendEmailWithRetry.mockRejectedValue(apiError);
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            const resendRequest = new _server.NextRequest('http://localhost/api/auth/resend-verification', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            const resendResponse = await (0, _route2.POST)(resendRequest);
            const resendData = await resendResponse.json();
            // Assert appropriate error response
            expect(resendResponse.status).toBe(500);
            expect(resendData.error).toContain('Email service error');
            // Verify retry logic was attempted (sendEmailWithRetry should handle retries internally)
            expect(mockSendEmailWithRetry).toHaveBeenCalledTimes(1);
        });
        it('should handle network error with appropriate user message', async ()=>{
            // Mock network error
            const networkError = new _emailservice.EmailServiceError('Network timeout', 'NETWORK_ERROR');
            mockSendEmailWithRetry.mockRejectedValue(networkError);
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            const resendRequest = new _server.NextRequest('http://localhost/api/auth/resend-verification', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            const resendResponse = await (0, _route2.POST)(resendRequest);
            const resendData = await resendResponse.json();
            // Assert network error response
            expect(resendResponse.status).toBe(500);
            expect(resendData.error).toContain('Network error');
            expect(resendData.error).toContain('check your connection');
        });
        it('should handle invalid email error from service', async ()=>{
            // Mock invalid email error
            const invalidEmailError = new _emailservice.EmailServiceError('Invalid email', 'INVALID_EMAIL');
            mockSendEmailWithRetry.mockRejectedValue(invalidEmailError);
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            const resendRequest = new _server.NextRequest('http://localhost/api/auth/resend-verification', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            const resendResponse = await (0, _route2.POST)(resendRequest);
            const resendData = await resendResponse.json();
            // Assert invalid email error response
            expect(resendResponse.status).toBe(400);
            expect(resendData.error).toContain('Invalid email address');
        });
        it('should handle unknown email service errors gracefully', async ()=>{
            // Mock unknown error (not EmailServiceError)
            mockSendEmailWithRetry.mockRejectedValue(new Error('Unknown error'));
            const signupRequest = new _server.NextRequest('http://localhost/api/auth/signup', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'SecurePass123!',
                    name: 'Test User'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            const signupResponse = await (0, _route.POST)(signupRequest);
            const signupData = await signupResponse.json();
            // Assert graceful handling of unknown error
            expect(signupResponse.status).toBe(200);
            expect(signupData.success).toBe(true);
            expect(signupData.emailError).toContain('Failed to send verification email');
            expect(signupData.emailError).toContain('try resending');
        });
        it('should handle service unavailable scenario during resend', async ()=>{
            // Mock quota exceeded error during resend
            const quotaError = new _emailservice.EmailServiceError('Service quota exceeded', 'QUOTA_EXCEEDED');
            mockSendEmailWithRetry.mockRejectedValue(quotaError);
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            const resendRequest = new _server.NextRequest('http://localhost/api/auth/resend-verification', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            const resendResponse = await (0, _route2.POST)(resendRequest);
            const resendData = await resendResponse.json();
            // Assert service unavailable response
            expect(resendResponse.status).toBe(503);
            expect(resendData.error).toContain('Email service quota exceeded');
            expect(resendData.error).toContain('try again later');
        });
    });
    describe('Expired Code Scenarios and Cleanup Processes', ()=>{
        it('should handle expired verification codes properly', async ()=>{
            // Create user with expired verification code
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            const expiredCode = await dbManager.createTestEmailCode({
                userId: user.id,
                code: '123456',
                expiresAt: new Date(Date.now() - 60000),
                attemptsUsed: 0
            });
            // Try to verify with expired code
            const verifyRequest = new _server.NextRequest('http://localhost/api/auth/verify-email', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com',
                    code: '123456'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            const verifyResponse = await (0, _route1.POST)(verifyRequest);
            const verifyData = await verifyResponse.json();
            // Assert expired code error
            expect(verifyResponse.status).toBe(400);
            expect(verifyData.error).toContain('Verification code has expired');
            expect(verifyData.error).toContain('request a new one');
            // Verify user is still not verified
            const unverifiedUser = await dbManager.getUserById(user.id);
            expect(unverifiedUser.isEmailVerified).toBe(false);
        });
        it('should clean up expired codes during verification service operations', async ()=>{
            // Create user with multiple codes, some expired
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Create expired code
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '111111',
                expiresAt: new Date(Date.now() - 60000),
                attemptsUsed: 0
            });
            // Create valid code
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '222222',
                expiresAt: new Date(Date.now() + 600000),
                attemptsUsed: 0
            });
            // Trigger cleanup by calling the service method
            await _emailverificationcodeservice.emailVerificationCodeService.cleanupExpiredCodes();
            // Verify expired code was cleaned up
            const remainingCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(remainingCodes).toHaveLength(1);
            expect(remainingCodes[0].code).toBe('222222');
        });
        it('should handle cleanup when user is deleted', async ()=>{
            // Create user with verification codes
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '123456',
                expiresAt: new Date(Date.now() + 600000),
                attemptsUsed: 0
            });
            // Verify code exists
            let emailCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(emailCodes).toHaveLength(1);
            // Delete user (should cascade delete codes due to foreign key constraint)
            await dbManager.deleteUser(user.id);
            // Verify codes were cleaned up
            emailCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(emailCodes).toHaveLength(0);
        });
        it('should handle multiple expired codes for same user', async ()=>{
            // Create user with multiple expired codes
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Create multiple expired codes
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '111111',
                expiresAt: new Date(Date.now() - 120000),
                attemptsUsed: 0
            });
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '222222',
                expiresAt: new Date(Date.now() - 60000),
                attemptsUsed: 0
            });
            // Try to verify with one of the expired codes
            const verifyRequest = new _server.NextRequest('http://localhost/api/auth/verify-email', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com',
                    code: '111111'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            const verifyResponse = await (0, _route1.POST)(verifyRequest);
            const verifyData = await verifyResponse.json();
            // Assert expired code error
            expect(verifyResponse.status).toBe(400);
            expect(verifyData.error).toContain('Verification code has expired');
            // Cleanup expired codes
            await _emailverificationcodeservice.emailVerificationCodeService.cleanupExpiredCodes();
            // Verify all expired codes were cleaned up
            const remainingCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(remainingCodes).toHaveLength(0);
        });
    });
    describe('Concurrent Verification Attempts and Race Conditions', ()=>{
        it('should handle concurrent verification attempts safely', async ()=>{
            // Create user with verification code
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '123456',
                expiresAt: new Date(Date.now() + 600000),
                attemptsUsed: 0
            });
            // Create multiple concurrent verification requests
            const verifyRequest1 = new _server.NextRequest('http://localhost/api/auth/verify-email', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com',
                    code: '123456'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            const verifyRequest2 = new _server.NextRequest('http://localhost/api/auth/verify-email', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com',
                    code: '123456'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            // Execute concurrent requests
            const [response1, response2] = await Promise.all([
                (0, _route1.POST)(verifyRequest1),
                (0, _route1.POST)(verifyRequest2)
            ]);
            const data1 = await response1.json();
            const data2 = await response2.json();
            // One should succeed, one should fail (code already used)
            const responses = [
                {
                    status: response1.status,
                    data: data1
                },
                {
                    status: response2.status,
                    data: data2
                }
            ];
            const successResponses = responses.filter((r)=>r.status === 200);
            const failureResponses = responses.filter((r)=>r.status !== 200);
            expect(successResponses).toHaveLength(1);
            expect(failureResponses).toHaveLength(1);
            // Verify user is verified only once
            const verifiedUser = await dbManager.getUserById(user.id);
            expect(verifiedUser.isEmailVerified).toBe(true);
            // Verify code was deleted
            const remainingCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(remainingCodes).toHaveLength(0);
        });
        it('should handle concurrent resend requests safely', async ()=>{
            // Create user
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Create multiple concurrent resend requests
            const resendRequest1 = new _server.NextRequest('http://localhost/api/auth/resend-verification', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            const resendRequest2 = new _server.NextRequest('http://localhost/api/auth/resend-verification', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            // Execute concurrent requests
            const [response1, response2] = await Promise.all([
                (0, _route2.POST)(resendRequest1),
                (0, _route2.POST)(resendRequest2)
            ]);
            // Both should succeed (rate limiting is handled by middleware)
            expect(response1.status).toBe(200);
            expect(response2.status).toBe(200);
            // Verify only one code exists (latest one)
            const emailCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(emailCodes).toHaveLength(1);
            // Verify email service was called (possibly multiple times due to concurrency)
            expect(mockSendEmailWithRetry).toHaveBeenCalled();
        });
        it('should handle race condition between verification and code expiration', async ()=>{
            // Create user with code that expires very soon
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '123456',
                expiresAt: new Date(Date.now() + 100),
                attemptsUsed: 0
            });
            // Wait for code to expire
            await new Promise((resolve)=>setTimeout(resolve, 150));
            // Try to verify with expired code
            const verifyRequest = new _server.NextRequest('http://localhost/api/auth/verify-email', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com',
                    code: '123456'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            const verifyResponse = await (0, _route1.POST)(verifyRequest);
            const verifyData = await verifyResponse.json();
            // Should handle expired code gracefully
            expect(verifyResponse.status).toBe(400);
            expect(verifyData.error).toContain('expired');
            // User should remain unverified
            const unverifiedUser = await dbManager.getUserById(user.id);
            expect(unverifiedUser.isEmailVerified).toBe(false);
        });
        it('should handle concurrent signup attempts with same email', async ()=>{
            // Create concurrent signup requests with same email
            const signupRequest1 = new _server.NextRequest('http://localhost/api/auth/signup', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'SecurePass123!',
                    name: 'Test User 1'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            const signupRequest2 = new _server.NextRequest('http://localhost/api/auth/signup', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'AnotherPass123!',
                    name: 'Test User 2'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            // Execute concurrent requests
            const [response1, response2] = await Promise.all([
                (0, _route.POST)(signupRequest1),
                (0, _route.POST)(signupRequest2)
            ]);
            const data1 = await response1.json();
            const data2 = await response2.json();
            // One should succeed, one should fail with duplicate email error
            const responses = [
                {
                    status: response1.status,
                    data: data1
                },
                {
                    status: response2.status,
                    data: data2
                }
            ];
            const successResponses = responses.filter((r)=>r.status === 200);
            const conflictResponses = responses.filter((r)=>r.status === 409);
            expect(successResponses).toHaveLength(1);
            expect(conflictResponses).toHaveLength(1);
            // Verify only one user was created
            const user = await dbManager.getUserByEmail('test@example.com');
            expect(user).toBeTruthy();
            // Verify only one set of verification codes exists
            const emailCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(emailCodes).toHaveLength(1);
        });
    });
    describe('Database Error Scenarios', ()=>{
        it('should handle database connection failures gracefully', async ()=>{
            // Mock database connection failure
            const originalDb = require('@/lib/db').db;
            // Mock database to throw connection error
            jest.doMock('@/lib/db', ()=>({
                    db: {
                        select: jest.fn().mockRejectedValue(new Error('Database connection failed')),
                        insert: jest.fn().mockRejectedValue(new Error('Database connection failed')),
                        update: jest.fn().mockRejectedValue(new Error('Database connection failed')),
                        delete: jest.fn().mockRejectedValue(new Error('Database connection failed'))
                    }
                }));
            const verifyRequest = new _server.NextRequest('http://localhost/api/auth/verify-email', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com',
                    code: '123456'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            const verifyResponse = await (0, _route1.POST)(verifyRequest);
            const verifyData = await verifyResponse.json();
            // Should handle database error gracefully
            expect(verifyResponse.status).toBe(500);
            expect(verifyData.error).toBe('Internal server error');
            // Restore original database
            jest.doMock('@/lib/db', ()=>({
                    db: originalDb
                }));
        });
        it('should handle transaction rollback scenarios', async ()=>{
            // This test would require more complex database transaction mocking
            // For now, we'll test that the service handles errors during code validation
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Create code with maximum attempts reached
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '123456',
                expiresAt: new Date(Date.now() + 600000),
                attemptsUsed: 5
            });
            const verifyRequest = new _server.NextRequest('http://localhost/api/auth/verify-email', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com',
                    code: '123456'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            const verifyResponse = await (0, _route1.POST)(verifyRequest);
            const verifyData = await verifyResponse.json();
            // Should handle too many attempts error
            expect(verifyResponse.status).toBe(429);
            expect(verifyData.error).toContain('Too many verification attempts');
            // User should remain unverified
            const unverifiedUser = await dbManager.getUserById(user.id);
            expect(unverifiedUser.isEmailVerified).toBe(false);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdGVmYW5iZWtrZXIvcHJvamVjdHMvZmFuY3ktcGxhbnRpZXMvc3JjL19fdGVzdHNfXy9pbnRlZ3JhdGlvbi9lbWFpbC12ZXJpZmljYXRpb24tZXJyb3Itc2NlbmFyaW9zLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFbWFpbCBWZXJpZmljYXRpb24gRXJyb3IgU2NlbmFyaW8gVGVzdHNcbiAqIFRlc3RzIGVtYWlsIHNlcnZpY2UgZmFpbHVyZSBoYW5kbGluZywgcmV0cnkgbG9naWMsIGV4cGlyZWQgY29kZSBzY2VuYXJpb3MsIFxuICogY2xlYW51cCBwcm9jZXNzZXMsIGFuZCBjb25jdXJyZW50IHZlcmlmaWNhdGlvbiBhdHRlbXB0c1xuICogUmVxdWlyZW1lbnRzOiAxLjQsIDMuMSwgNy4zLCA3LjRcbiAqL1xuXG5pbXBvcnQgeyBOZXh0UmVxdWVzdCB9IGZyb20gJ25leHQvc2VydmVyJztcbmltcG9ydCB7IFBPU1QgYXMgc2lnbnVwSGFuZGxlciB9IGZyb20gJ0AvYXBwL2FwaS9hdXRoL3NpZ251cC9yb3V0ZSc7XG5pbXBvcnQgeyBQT1NUIGFzIHZlcmlmeUVtYWlsSGFuZGxlciB9IGZyb20gJ0AvYXBwL2FwaS9hdXRoL3ZlcmlmeS1lbWFpbC9yb3V0ZSc7XG5pbXBvcnQgeyBQT1NUIGFzIHJlc2VuZFZlcmlmaWNhdGlvbkhhbmRsZXIgfSBmcm9tICdAL2FwcC9hcGkvYXV0aC9yZXNlbmQtdmVyaWZpY2F0aW9uL3JvdXRlJztcbmltcG9ydCB7IGNyZWF0ZURhdGFiYXNlVGVzdE1hbmFnZXIgfSBmcm9tICdAL3Rlc3QtdXRpbHMvc2V0dXAvZGF0YWJhc2UtdGVzdC1tYW5hZ2VyJztcbmltcG9ydCB7IGVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UgfSBmcm9tICdAL2xpYi9zZXJ2aWNlcy9lbWFpbC12ZXJpZmljYXRpb24tY29kZS1zZXJ2aWNlJztcbmltcG9ydCB7IGNyZWF0ZUVtYWlsU2VydmljZSB9IGZyb20gJ0AvbGliL3NlcnZpY2VzL3Jlc2VuZC1lbWFpbC1zZXJ2aWNlJztcbmltcG9ydCB7IEVtYWlsU2VydmljZUVycm9yIH0gZnJvbSAnQC9saWIvc2VydmljZXMvZW1haWwtc2VydmljZSc7XG5cbi8vIE1vY2sgZW1haWwgc2VydmljZSBhbmQgcmVsYXRlZCBtb2R1bGVzXG5qZXN0Lm1vY2soJ0AvbGliL3NlcnZpY2VzL3Jlc2VuZC1lbWFpbC1zZXJ2aWNlJyk7XG5qZXN0Lm1vY2soJ0AvbGliL3NlcnZpY2VzL2VtYWlsLXNlcnZpY2UnKTtcblxuY29uc3QgbW9ja0VtYWlsU2VydmljZSA9IHtcbiAgc2VuZFZlcmlmaWNhdGlvbkVtYWlsOiBqZXN0LmZuKCksXG59O1xuXG5jb25zdCBtb2NrQ3JlYXRlRW1haWxTZXJ2aWNlID0gY3JlYXRlRW1haWxTZXJ2aWNlIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248dHlwZW9mIGNyZWF0ZUVtYWlsU2VydmljZT47XG5jb25zdCBtb2NrU2VuZEVtYWlsV2l0aFJldHJ5ID0gcmVxdWlyZSgnQC9saWIvc2VydmljZXMvZW1haWwtc2VydmljZScpLnNlbmRFbWFpbFdpdGhSZXRyeSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT47XG5cbi8vIE1vY2sgZW52aXJvbm1lbnQgdmFyaWFibGVzXG5jb25zdCBvcmlnaW5hbEVudiA9IHByb2Nlc3MuZW52O1xuXG5iZWZvcmVBbGwoKCkgPT4ge1xuICBwcm9jZXNzLmVudiA9IHtcbiAgICAuLi5vcmlnaW5hbEVudixcbiAgICBSRVNFTkRfQVBJX0tFWTogJ3Rlc3QtYXBpLWtleScsXG4gICAgRlJPTV9FTUFJTDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgIEZST01fTkFNRTogJ1Rlc3QgQXBwJyxcbiAgICBWRVJJRklDQVRJT05fQ09ERV9FWFBJUllfTUlOVVRFUzogJzEwJyxcbiAgICBNQVhfVkVSSUZJQ0FUSU9OX0FUVEVNUFRTOiAnNScsXG4gICAgUkVTRU5EX0NPT0xET1dOX1NFQ09ORFM6ICc2MCcsXG4gICAgTUFYX1JFU0VORF9QRVJfSE9VUjogJzUnLFxuICAgIE5PREVfRU5WOiAndGVzdCcsXG4gIH07XG59KTtcblxuYWZ0ZXJBbGwoKCkgPT4ge1xuICBwcm9jZXNzLmVudiA9IG9yaWdpbmFsRW52O1xufSk7XG5cbmRlc2NyaWJlKCdFbWFpbCBWZXJpZmljYXRpb24gRXJyb3IgU2NlbmFyaW8gVGVzdHMnLCAoKSA9PiB7XG4gIGxldCBkYk1hbmFnZXI6IGFueTtcblxuICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICBkYk1hbmFnZXIgPSBjcmVhdGVEYXRhYmFzZVRlc3RNYW5hZ2VyKCk7XG4gICAgXG4gICAgLy8gRGVmYXVsdCB0byBzdWNjZXNzZnVsIGVtYWlsIHNlcnZpY2VcbiAgICBtb2NrQ3JlYXRlRW1haWxTZXJ2aWNlLm1vY2tSZXR1cm5WYWx1ZShtb2NrRW1haWxTZXJ2aWNlKTtcbiAgICBtb2NrU2VuZEVtYWlsV2l0aFJldHJ5Lm1vY2tSZXNvbHZlZFZhbHVlKHRydWUpO1xuICAgIG1vY2tFbWFpbFNlcnZpY2Uuc2VuZFZlcmlmaWNhdGlvbkVtYWlsLm1vY2tSZXNvbHZlZFZhbHVlKHRydWUpO1xuICB9KTtcblxuICBhZnRlckVhY2goYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGRiTWFuYWdlci5jbGVhbnVwKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFbWFpbCBTZXJ2aWNlIEZhaWx1cmUgSGFuZGxpbmcgYW5kIFJldHJ5IExvZ2ljJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIHF1b3RhIGV4Y2VlZGVkIGVycm9yIHdpdGggYXBwcm9wcmlhdGUgcmVzcG9uc2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIHF1b3RhIGV4Y2VlZGVkIGVycm9yXG4gICAgICBjb25zdCBxdW90YUVycm9yID0gbmV3IEVtYWlsU2VydmljZUVycm9yKCdRdW90YSBleGNlZWRlZCcsICdRVU9UQV9FWENFRURFRCcpO1xuICAgICAgbW9ja1NlbmRFbWFpbFdpdGhSZXRyeS5tb2NrUmVqZWN0ZWRWYWx1ZShxdW90YUVycm9yKTtcblxuICAgICAgY29uc3Qgc2lnbnVwUmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdC9hcGkvYXV0aC9zaWdudXAnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBwYXNzd29yZDogJ1NlY3VyZVBhc3MxMjMhJyxcbiAgICAgICAgICBuYW1lOiAnVGVzdCBVc2VyJyxcbiAgICAgICAgfSksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHNpZ251cFJlc3BvbnNlID0gYXdhaXQgc2lnbnVwSGFuZGxlcihzaWdudXBSZXF1ZXN0KTtcbiAgICAgIGNvbnN0IHNpZ251cERhdGEgPSBhd2FpdCBzaWdudXBSZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIC8vIEFzc2VydCB1c2VyIGlzIGNyZWF0ZWQgYnV0IGVtYWlsIGVycm9yIGlzIHJlcG9ydGVkXG4gICAgICBleHBlY3Qoc2lnbnVwUmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICBleHBlY3Qoc2lnbnVwRGF0YS5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHNpZ251cERhdGEucmVxdWlyZXNWZXJpZmljYXRpb24pLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3Qoc2lnbnVwRGF0YS5lbWFpbEVycm9yKS50b0NvbnRhaW4oJ0VtYWlsIHNlcnZpY2UgcXVvdGEgZXhjZWVkZWQnKTtcblxuICAgICAgLy8gVmVyaWZ5IHVzZXIgd2FzIGNyZWF0ZWQgaW4gZGF0YWJhc2VcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBkYk1hbmFnZXIuZ2V0VXNlckJ5RW1haWwoJ3Rlc3RAZXhhbXBsZS5jb20nKTtcbiAgICAgIGV4cGVjdCh1c2VyKS50b0JlVHJ1dGh5KCk7XG4gICAgICBleHBlY3QodXNlci5pc0VtYWlsVmVyaWZpZWQpLnRvQmUoZmFsc2UpO1xuXG4gICAgICAvLyBWZXJpZnkgdmVyaWZpY2F0aW9uIGNvZGUgd2FzIHN0aWxsIGdlbmVyYXRlZFxuICAgICAgY29uc3QgZW1haWxDb2RlcyA9IGF3YWl0IGRiTWFuYWdlci5nZXRFbWFpbENvZGVzQnlVc2VySWQodXNlci5pZCk7XG4gICAgICBleHBlY3QoZW1haWxDb2RlcykudG9IYXZlTGVuZ3RoKDEpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgQVBJIGVycm9yIHdpdGggcmV0cnkgbG9naWMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIEFQSSBlcnJvciB0aGF0IHNob3VsZCB0cmlnZ2VyIHJldHJ5XG4gICAgICBjb25zdCBhcGlFcnJvciA9IG5ldyBFbWFpbFNlcnZpY2VFcnJvcignQVBJIGVycm9yJywgJ0FQSV9FUlJPUicpO1xuICAgICAgbW9ja1NlbmRFbWFpbFdpdGhSZXRyeS5tb2NrUmVqZWN0ZWRWYWx1ZShhcGlFcnJvcik7XG5cbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdFVzZXIoe1xuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAnVGVzdCBVc2VyJyxcbiAgICAgICAgcGFzc3dvcmRIYXNoOiAnaGFzaGVkX3Bhc3N3b3JkJyxcbiAgICAgICAgaXNFbWFpbFZlcmlmaWVkOiBmYWxzZSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNlbmRSZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0L2FwaS9hdXRoL3Jlc2VuZC12ZXJpZmljYXRpb24nLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgfSksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc2VuZFJlc3BvbnNlID0gYXdhaXQgcmVzZW5kVmVyaWZpY2F0aW9uSGFuZGxlcihyZXNlbmRSZXF1ZXN0KTtcbiAgICAgIGNvbnN0IHJlc2VuZERhdGEgPSBhd2FpdCByZXNlbmRSZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIC8vIEFzc2VydCBhcHByb3ByaWF0ZSBlcnJvciByZXNwb25zZVxuICAgICAgZXhwZWN0KHJlc2VuZFJlc3BvbnNlLnN0YXR1cykudG9CZSg1MDApO1xuICAgICAgZXhwZWN0KHJlc2VuZERhdGEuZXJyb3IpLnRvQ29udGFpbignRW1haWwgc2VydmljZSBlcnJvcicpO1xuXG4gICAgICAvLyBWZXJpZnkgcmV0cnkgbG9naWMgd2FzIGF0dGVtcHRlZCAoc2VuZEVtYWlsV2l0aFJldHJ5IHNob3VsZCBoYW5kbGUgcmV0cmllcyBpbnRlcm5hbGx5KVxuICAgICAgZXhwZWN0KG1vY2tTZW5kRW1haWxXaXRoUmV0cnkpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIG5ldHdvcmsgZXJyb3Igd2l0aCBhcHByb3ByaWF0ZSB1c2VyIG1lc3NhZ2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIG5ldHdvcmsgZXJyb3JcbiAgICAgIGNvbnN0IG5ldHdvcmtFcnJvciA9IG5ldyBFbWFpbFNlcnZpY2VFcnJvcignTmV0d29yayB0aW1lb3V0JywgJ05FVFdPUktfRVJST1InKTtcbiAgICAgIG1vY2tTZW5kRW1haWxXaXRoUmV0cnkubW9ja1JlamVjdGVkVmFsdWUobmV0d29ya0Vycm9yKTtcblxuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0VXNlcih7XG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgICBwYXNzd29yZEhhc2g6ICdoYXNoZWRfcGFzc3dvcmQnLFxuICAgICAgICBpc0VtYWlsVmVyaWZpZWQ6IGZhbHNlLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc2VuZFJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvYXBpL2F1dGgvcmVzZW5kLXZlcmlmaWNhdGlvbicsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICB9KSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzZW5kUmVzcG9uc2UgPSBhd2FpdCByZXNlbmRWZXJpZmljYXRpb25IYW5kbGVyKHJlc2VuZFJlcXVlc3QpO1xuICAgICAgY29uc3QgcmVzZW5kRGF0YSA9IGF3YWl0IHJlc2VuZFJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgLy8gQXNzZXJ0IG5ldHdvcmsgZXJyb3IgcmVzcG9uc2VcbiAgICAgIGV4cGVjdChyZXNlbmRSZXNwb25zZS5zdGF0dXMpLnRvQmUoNTAwKTtcbiAgICAgIGV4cGVjdChyZXNlbmREYXRhLmVycm9yKS50b0NvbnRhaW4oJ05ldHdvcmsgZXJyb3InKTtcbiAgICAgIGV4cGVjdChyZXNlbmREYXRhLmVycm9yKS50b0NvbnRhaW4oJ2NoZWNrIHlvdXIgY29ubmVjdGlvbicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgaW52YWxpZCBlbWFpbCBlcnJvciBmcm9tIHNlcnZpY2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIGludmFsaWQgZW1haWwgZXJyb3JcbiAgICAgIGNvbnN0IGludmFsaWRFbWFpbEVycm9yID0gbmV3IEVtYWlsU2VydmljZUVycm9yKCdJbnZhbGlkIGVtYWlsJywgJ0lOVkFMSURfRU1BSUwnKTtcbiAgICAgIG1vY2tTZW5kRW1haWxXaXRoUmV0cnkubW9ja1JlamVjdGVkVmFsdWUoaW52YWxpZEVtYWlsRXJyb3IpO1xuXG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RVc2VyKHtcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgICAgIHBhc3N3b3JkSGFzaDogJ2hhc2hlZF9wYXNzd29yZCcsXG4gICAgICAgIGlzRW1haWxWZXJpZmllZDogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzZW5kUmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdC9hcGkvYXV0aC9yZXNlbmQtdmVyaWZpY2F0aW9uJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIH0pLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNlbmRSZXNwb25zZSA9IGF3YWl0IHJlc2VuZFZlcmlmaWNhdGlvbkhhbmRsZXIocmVzZW5kUmVxdWVzdCk7XG4gICAgICBjb25zdCByZXNlbmREYXRhID0gYXdhaXQgcmVzZW5kUmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAvLyBBc3NlcnQgaW52YWxpZCBlbWFpbCBlcnJvciByZXNwb25zZVxuICAgICAgZXhwZWN0KHJlc2VuZFJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDApO1xuICAgICAgZXhwZWN0KHJlc2VuZERhdGEuZXJyb3IpLnRvQ29udGFpbignSW52YWxpZCBlbWFpbCBhZGRyZXNzJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSB1bmtub3duIGVtYWlsIHNlcnZpY2UgZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIHVua25vd24gZXJyb3IgKG5vdCBFbWFpbFNlcnZpY2VFcnJvcilcbiAgICAgIG1vY2tTZW5kRW1haWxXaXRoUmV0cnkubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdVbmtub3duIGVycm9yJykpO1xuXG4gICAgICBjb25zdCBzaWdudXBSZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0L2FwaS9hdXRoL3NpZ251cCcsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIHBhc3N3b3JkOiAnU2VjdXJlUGFzczEyMyEnLFxuICAgICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgICB9KSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgc2lnbnVwUmVzcG9uc2UgPSBhd2FpdCBzaWdudXBIYW5kbGVyKHNpZ251cFJlcXVlc3QpO1xuICAgICAgY29uc3Qgc2lnbnVwRGF0YSA9IGF3YWl0IHNpZ251cFJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgLy8gQXNzZXJ0IGdyYWNlZnVsIGhhbmRsaW5nIG9mIHVua25vd24gZXJyb3JcbiAgICAgIGV4cGVjdChzaWdudXBSZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgIGV4cGVjdChzaWdudXBEYXRhLnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3Qoc2lnbnVwRGF0YS5lbWFpbEVycm9yKS50b0NvbnRhaW4oJ0ZhaWxlZCB0byBzZW5kIHZlcmlmaWNhdGlvbiBlbWFpbCcpO1xuICAgICAgZXhwZWN0KHNpZ251cERhdGEuZW1haWxFcnJvcikudG9Db250YWluKCd0cnkgcmVzZW5kaW5nJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBzZXJ2aWNlIHVuYXZhaWxhYmxlIHNjZW5hcmlvIGR1cmluZyByZXNlbmQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIHF1b3RhIGV4Y2VlZGVkIGVycm9yIGR1cmluZyByZXNlbmRcbiAgICAgIGNvbnN0IHF1b3RhRXJyb3IgPSBuZXcgRW1haWxTZXJ2aWNlRXJyb3IoJ1NlcnZpY2UgcXVvdGEgZXhjZWVkZWQnLCAnUVVPVEFfRVhDRUVERUQnKTtcbiAgICAgIG1vY2tTZW5kRW1haWxXaXRoUmV0cnkubW9ja1JlamVjdGVkVmFsdWUocXVvdGFFcnJvcik7XG5cbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdFVzZXIoe1xuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAnVGVzdCBVc2VyJyxcbiAgICAgICAgcGFzc3dvcmRIYXNoOiAnaGFzaGVkX3Bhc3N3b3JkJyxcbiAgICAgICAgaXNFbWFpbFZlcmlmaWVkOiBmYWxzZSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNlbmRSZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0L2FwaS9hdXRoL3Jlc2VuZC12ZXJpZmljYXRpb24nLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgfSksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc2VuZFJlc3BvbnNlID0gYXdhaXQgcmVzZW5kVmVyaWZpY2F0aW9uSGFuZGxlcihyZXNlbmRSZXF1ZXN0KTtcbiAgICAgIGNvbnN0IHJlc2VuZERhdGEgPSBhd2FpdCByZXNlbmRSZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIC8vIEFzc2VydCBzZXJ2aWNlIHVuYXZhaWxhYmxlIHJlc3BvbnNlXG4gICAgICBleHBlY3QocmVzZW5kUmVzcG9uc2Uuc3RhdHVzKS50b0JlKDUwMyk7XG4gICAgICBleHBlY3QocmVzZW5kRGF0YS5lcnJvcikudG9Db250YWluKCdFbWFpbCBzZXJ2aWNlIHF1b3RhIGV4Y2VlZGVkJyk7XG4gICAgICBleHBlY3QocmVzZW5kRGF0YS5lcnJvcikudG9Db250YWluKCd0cnkgYWdhaW4gbGF0ZXInKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0V4cGlyZWQgQ29kZSBTY2VuYXJpb3MgYW5kIENsZWFudXAgUHJvY2Vzc2VzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIGV4cGlyZWQgdmVyaWZpY2F0aW9uIGNvZGVzIHByb3Blcmx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIHVzZXIgd2l0aCBleHBpcmVkIHZlcmlmaWNhdGlvbiBjb2RlXG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RVc2VyKHtcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgICAgIHBhc3N3b3JkSGFzaDogJ2hhc2hlZF9wYXNzd29yZCcsXG4gICAgICAgIGlzRW1haWxWZXJpZmllZDogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZXhwaXJlZENvZGUgPSBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdEVtYWlsQ29kZSh7XG4gICAgICAgIHVzZXJJZDogdXNlci5pZCxcbiAgICAgICAgY29kZTogJzEyMzQ1NicsXG4gICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDYwMDAwKSwgLy8gRXhwaXJlZCAxIG1pbnV0ZSBhZ29cbiAgICAgICAgYXR0ZW1wdHNVc2VkOiAwLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFRyeSB0byB2ZXJpZnkgd2l0aCBleHBpcmVkIGNvZGVcbiAgICAgIGNvbnN0IHZlcmlmeVJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvYXBpL2F1dGgvdmVyaWZ5LWVtYWlsJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgY29kZTogJzEyMzQ1NicsXG4gICAgICAgIH0pLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB2ZXJpZnlSZXNwb25zZSA9IGF3YWl0IHZlcmlmeUVtYWlsSGFuZGxlcih2ZXJpZnlSZXF1ZXN0KTtcbiAgICAgIGNvbnN0IHZlcmlmeURhdGEgPSBhd2FpdCB2ZXJpZnlSZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIC8vIEFzc2VydCBleHBpcmVkIGNvZGUgZXJyb3JcbiAgICAgIGV4cGVjdCh2ZXJpZnlSZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAwKTtcbiAgICAgIGV4cGVjdCh2ZXJpZnlEYXRhLmVycm9yKS50b0NvbnRhaW4oJ1ZlcmlmaWNhdGlvbiBjb2RlIGhhcyBleHBpcmVkJyk7XG4gICAgICBleHBlY3QodmVyaWZ5RGF0YS5lcnJvcikudG9Db250YWluKCdyZXF1ZXN0IGEgbmV3IG9uZScpO1xuXG4gICAgICAvLyBWZXJpZnkgdXNlciBpcyBzdGlsbCBub3QgdmVyaWZpZWRcbiAgICAgIGNvbnN0IHVudmVyaWZpZWRVc2VyID0gYXdhaXQgZGJNYW5hZ2VyLmdldFVzZXJCeUlkKHVzZXIuaWQpO1xuICAgICAgZXhwZWN0KHVudmVyaWZpZWRVc2VyLmlzRW1haWxWZXJpZmllZCkudG9CZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNsZWFuIHVwIGV4cGlyZWQgY29kZXMgZHVyaW5nIHZlcmlmaWNhdGlvbiBzZXJ2aWNlIG9wZXJhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBDcmVhdGUgdXNlciB3aXRoIG11bHRpcGxlIGNvZGVzLCBzb21lIGV4cGlyZWRcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdFVzZXIoe1xuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAnVGVzdCBVc2VyJyxcbiAgICAgICAgcGFzc3dvcmRIYXNoOiAnaGFzaGVkX3Bhc3N3b3JkJyxcbiAgICAgICAgaXNFbWFpbFZlcmlmaWVkOiBmYWxzZSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBDcmVhdGUgZXhwaXJlZCBjb2RlXG4gICAgICBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdEVtYWlsQ29kZSh7XG4gICAgICAgIHVzZXJJZDogdXNlci5pZCxcbiAgICAgICAgY29kZTogJzExMTExMScsXG4gICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDYwMDAwKSwgLy8gRXhwaXJlZFxuICAgICAgICBhdHRlbXB0c1VzZWQ6IDAsXG4gICAgICB9KTtcblxuICAgICAgLy8gQ3JlYXRlIHZhbGlkIGNvZGVcbiAgICAgIGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0RW1haWxDb2RlKHtcbiAgICAgICAgdXNlcklkOiB1c2VyLmlkLFxuICAgICAgICBjb2RlOiAnMjIyMjIyJyxcbiAgICAgICAgZXhwaXJlc0F0OiBuZXcgRGF0ZShEYXRlLm5vdygpICsgNjAwMDAwKSwgLy8gVmFsaWQgZm9yIDEwIG1pbnV0ZXNcbiAgICAgICAgYXR0ZW1wdHNVc2VkOiAwLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFRyaWdnZXIgY2xlYW51cCBieSBjYWxsaW5nIHRoZSBzZXJ2aWNlIG1ldGhvZFxuICAgICAgYXdhaXQgZW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS5jbGVhbnVwRXhwaXJlZENvZGVzKCk7XG5cbiAgICAgIC8vIFZlcmlmeSBleHBpcmVkIGNvZGUgd2FzIGNsZWFuZWQgdXBcbiAgICAgIGNvbnN0IHJlbWFpbmluZ0NvZGVzID0gYXdhaXQgZGJNYW5hZ2VyLmdldEVtYWlsQ29kZXNCeVVzZXJJZCh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdChyZW1haW5pbmdDb2RlcykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KHJlbWFpbmluZ0NvZGVzWzBdLmNvZGUpLnRvQmUoJzIyMjIyMicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY2xlYW51cCB3aGVuIHVzZXIgaXMgZGVsZXRlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSB1c2VyIHdpdGggdmVyaWZpY2F0aW9uIGNvZGVzXG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RVc2VyKHtcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgICAgIHBhc3N3b3JkSGFzaDogJ2hhc2hlZF9wYXNzd29yZCcsXG4gICAgICAgIGlzRW1haWxWZXJpZmllZDogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RFbWFpbENvZGUoe1xuICAgICAgICB1c2VySWQ6IHVzZXIuaWQsXG4gICAgICAgIGNvZGU6ICcxMjM0NTYnLFxuICAgICAgICBleHBpcmVzQXQ6IG5ldyBEYXRlKERhdGUubm93KCkgKyA2MDAwMDApLFxuICAgICAgICBhdHRlbXB0c1VzZWQ6IDAsXG4gICAgICB9KTtcblxuICAgICAgLy8gVmVyaWZ5IGNvZGUgZXhpc3RzXG4gICAgICBsZXQgZW1haWxDb2RlcyA9IGF3YWl0IGRiTWFuYWdlci5nZXRFbWFpbENvZGVzQnlVc2VySWQodXNlci5pZCk7XG4gICAgICBleHBlY3QoZW1haWxDb2RlcykudG9IYXZlTGVuZ3RoKDEpO1xuXG4gICAgICAvLyBEZWxldGUgdXNlciAoc2hvdWxkIGNhc2NhZGUgZGVsZXRlIGNvZGVzIGR1ZSB0byBmb3JlaWduIGtleSBjb25zdHJhaW50KVxuICAgICAgYXdhaXQgZGJNYW5hZ2VyLmRlbGV0ZVVzZXIodXNlci5pZCk7XG5cbiAgICAgIC8vIFZlcmlmeSBjb2RlcyB3ZXJlIGNsZWFuZWQgdXBcbiAgICAgIGVtYWlsQ29kZXMgPSBhd2FpdCBkYk1hbmFnZXIuZ2V0RW1haWxDb2Rlc0J5VXNlcklkKHVzZXIuaWQpO1xuICAgICAgZXhwZWN0KGVtYWlsQ29kZXMpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIG11bHRpcGxlIGV4cGlyZWQgY29kZXMgZm9yIHNhbWUgdXNlcicsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSB1c2VyIHdpdGggbXVsdGlwbGUgZXhwaXJlZCBjb2Rlc1xuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0VXNlcih7XG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgICBwYXNzd29yZEhhc2g6ICdoYXNoZWRfcGFzc3dvcmQnLFxuICAgICAgICBpc0VtYWlsVmVyaWZpZWQ6IGZhbHNlLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIENyZWF0ZSBtdWx0aXBsZSBleHBpcmVkIGNvZGVzXG4gICAgICBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdEVtYWlsQ29kZSh7XG4gICAgICAgIHVzZXJJZDogdXNlci5pZCxcbiAgICAgICAgY29kZTogJzExMTExMScsXG4gICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDEyMDAwMCksIC8vIEV4cGlyZWQgMiBtaW51dGVzIGFnb1xuICAgICAgICBhdHRlbXB0c1VzZWQ6IDAsXG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RFbWFpbENvZGUoe1xuICAgICAgICB1c2VySWQ6IHVzZXIuaWQsXG4gICAgICAgIGNvZGU6ICcyMjIyMjInLFxuICAgICAgICBleHBpcmVzQXQ6IG5ldyBEYXRlKERhdGUubm93KCkgLSA2MDAwMCksIC8vIEV4cGlyZWQgMSBtaW51dGUgYWdvXG4gICAgICAgIGF0dGVtcHRzVXNlZDogMCxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBUcnkgdG8gdmVyaWZ5IHdpdGggb25lIG9mIHRoZSBleHBpcmVkIGNvZGVzXG4gICAgICBjb25zdCB2ZXJpZnlSZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0L2FwaS9hdXRoL3ZlcmlmeS1lbWFpbCcsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIGNvZGU6ICcxMTExMTEnLFxuICAgICAgICB9KSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdmVyaWZ5UmVzcG9uc2UgPSBhd2FpdCB2ZXJpZnlFbWFpbEhhbmRsZXIodmVyaWZ5UmVxdWVzdCk7XG4gICAgICBjb25zdCB2ZXJpZnlEYXRhID0gYXdhaXQgdmVyaWZ5UmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAvLyBBc3NlcnQgZXhwaXJlZCBjb2RlIGVycm9yXG4gICAgICBleHBlY3QodmVyaWZ5UmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMCk7XG4gICAgICBleHBlY3QodmVyaWZ5RGF0YS5lcnJvcikudG9Db250YWluKCdWZXJpZmljYXRpb24gY29kZSBoYXMgZXhwaXJlZCcpO1xuXG4gICAgICAvLyBDbGVhbnVwIGV4cGlyZWQgY29kZXNcbiAgICAgIGF3YWl0IGVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UuY2xlYW51cEV4cGlyZWRDb2RlcygpO1xuXG4gICAgICAvLyBWZXJpZnkgYWxsIGV4cGlyZWQgY29kZXMgd2VyZSBjbGVhbmVkIHVwXG4gICAgICBjb25zdCByZW1haW5pbmdDb2RlcyA9IGF3YWl0IGRiTWFuYWdlci5nZXRFbWFpbENvZGVzQnlVc2VySWQodXNlci5pZCk7XG4gICAgICBleHBlY3QocmVtYWluaW5nQ29kZXMpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NvbmN1cnJlbnQgVmVyaWZpY2F0aW9uIEF0dGVtcHRzIGFuZCBSYWNlIENvbmRpdGlvbnMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY29uY3VycmVudCB2ZXJpZmljYXRpb24gYXR0ZW1wdHMgc2FmZWx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIHVzZXIgd2l0aCB2ZXJpZmljYXRpb24gY29kZVxuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0VXNlcih7XG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgICBwYXNzd29yZEhhc2g6ICdoYXNoZWRfcGFzc3dvcmQnLFxuICAgICAgICBpc0VtYWlsVmVyaWZpZWQ6IGZhbHNlLFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0RW1haWxDb2RlKHtcbiAgICAgICAgdXNlcklkOiB1c2VyLmlkLFxuICAgICAgICBjb2RlOiAnMTIzNDU2JyxcbiAgICAgICAgZXhwaXJlc0F0OiBuZXcgRGF0ZShEYXRlLm5vdygpICsgNjAwMDAwKSxcbiAgICAgICAgYXR0ZW1wdHNVc2VkOiAwLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIENyZWF0ZSBtdWx0aXBsZSBjb25jdXJyZW50IHZlcmlmaWNhdGlvbiByZXF1ZXN0c1xuICAgICAgY29uc3QgdmVyaWZ5UmVxdWVzdDEgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvYXBpL2F1dGgvdmVyaWZ5LWVtYWlsJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgY29kZTogJzEyMzQ1NicsXG4gICAgICAgIH0pLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB2ZXJpZnlSZXF1ZXN0MiA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdC9hcGkvYXV0aC92ZXJpZnktZW1haWwnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBjb2RlOiAnMTIzNDU2JyxcbiAgICAgICAgfSksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIC8vIEV4ZWN1dGUgY29uY3VycmVudCByZXF1ZXN0c1xuICAgICAgY29uc3QgW3Jlc3BvbnNlMSwgcmVzcG9uc2UyXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgdmVyaWZ5RW1haWxIYW5kbGVyKHZlcmlmeVJlcXVlc3QxKSxcbiAgICAgICAgdmVyaWZ5RW1haWxIYW5kbGVyKHZlcmlmeVJlcXVlc3QyKSxcbiAgICAgIF0pO1xuXG4gICAgICBjb25zdCBkYXRhMSA9IGF3YWl0IHJlc3BvbnNlMS5qc29uKCk7XG4gICAgICBjb25zdCBkYXRhMiA9IGF3YWl0IHJlc3BvbnNlMi5qc29uKCk7XG5cbiAgICAgIC8vIE9uZSBzaG91bGQgc3VjY2VlZCwgb25lIHNob3VsZCBmYWlsIChjb2RlIGFscmVhZHkgdXNlZClcbiAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IFtcbiAgICAgICAgeyBzdGF0dXM6IHJlc3BvbnNlMS5zdGF0dXMsIGRhdGE6IGRhdGExIH0sXG4gICAgICAgIHsgc3RhdHVzOiByZXNwb25zZTIuc3RhdHVzLCBkYXRhOiBkYXRhMiB9LFxuICAgICAgXTtcblxuICAgICAgY29uc3Qgc3VjY2Vzc1Jlc3BvbnNlcyA9IHJlc3BvbnNlcy5maWx0ZXIociA9PiByLnN0YXR1cyA9PT0gMjAwKTtcbiAgICAgIGNvbnN0IGZhaWx1cmVSZXNwb25zZXMgPSByZXNwb25zZXMuZmlsdGVyKHIgPT4gci5zdGF0dXMgIT09IDIwMCk7XG5cbiAgICAgIGV4cGVjdChzdWNjZXNzUmVzcG9uc2VzKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QoZmFpbHVyZVJlc3BvbnNlcykudG9IYXZlTGVuZ3RoKDEpO1xuXG4gICAgICAvLyBWZXJpZnkgdXNlciBpcyB2ZXJpZmllZCBvbmx5IG9uY2VcbiAgICAgIGNvbnN0IHZlcmlmaWVkVXNlciA9IGF3YWl0IGRiTWFuYWdlci5nZXRVc2VyQnlJZCh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdCh2ZXJpZmllZFVzZXIuaXNFbWFpbFZlcmlmaWVkKS50b0JlKHRydWUpO1xuXG4gICAgICAvLyBWZXJpZnkgY29kZSB3YXMgZGVsZXRlZFxuICAgICAgY29uc3QgcmVtYWluaW5nQ29kZXMgPSBhd2FpdCBkYk1hbmFnZXIuZ2V0RW1haWxDb2Rlc0J5VXNlcklkKHVzZXIuaWQpO1xuICAgICAgZXhwZWN0KHJlbWFpbmluZ0NvZGVzKS50b0hhdmVMZW5ndGgoMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjb25jdXJyZW50IHJlc2VuZCByZXF1ZXN0cyBzYWZlbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBDcmVhdGUgdXNlclxuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0VXNlcih7XG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgICBwYXNzd29yZEhhc2g6ICdoYXNoZWRfcGFzc3dvcmQnLFxuICAgICAgICBpc0VtYWlsVmVyaWZpZWQ6IGZhbHNlLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIENyZWF0ZSBtdWx0aXBsZSBjb25jdXJyZW50IHJlc2VuZCByZXF1ZXN0c1xuICAgICAgY29uc3QgcmVzZW5kUmVxdWVzdDEgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvYXBpL2F1dGgvcmVzZW5kLXZlcmlmaWNhdGlvbicsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICB9KSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzZW5kUmVxdWVzdDIgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvYXBpL2F1dGgvcmVzZW5kLXZlcmlmaWNhdGlvbicsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICB9KSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgLy8gRXhlY3V0ZSBjb25jdXJyZW50IHJlcXVlc3RzXG4gICAgICBjb25zdCBbcmVzcG9uc2UxLCByZXNwb25zZTJdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICByZXNlbmRWZXJpZmljYXRpb25IYW5kbGVyKHJlc2VuZFJlcXVlc3QxKSxcbiAgICAgICAgcmVzZW5kVmVyaWZpY2F0aW9uSGFuZGxlcihyZXNlbmRSZXF1ZXN0MiksXG4gICAgICBdKTtcblxuICAgICAgLy8gQm90aCBzaG91bGQgc3VjY2VlZCAocmF0ZSBsaW1pdGluZyBpcyBoYW5kbGVkIGJ5IG1pZGRsZXdhcmUpXG4gICAgICBleHBlY3QocmVzcG9uc2UxLnN0YXR1cykudG9CZSgyMDApO1xuICAgICAgZXhwZWN0KHJlc3BvbnNlMi5zdGF0dXMpLnRvQmUoMjAwKTtcblxuICAgICAgLy8gVmVyaWZ5IG9ubHkgb25lIGNvZGUgZXhpc3RzIChsYXRlc3Qgb25lKVxuICAgICAgY29uc3QgZW1haWxDb2RlcyA9IGF3YWl0IGRiTWFuYWdlci5nZXRFbWFpbENvZGVzQnlVc2VySWQodXNlci5pZCk7XG4gICAgICBleHBlY3QoZW1haWxDb2RlcykudG9IYXZlTGVuZ3RoKDEpO1xuXG4gICAgICAvLyBWZXJpZnkgZW1haWwgc2VydmljZSB3YXMgY2FsbGVkIChwb3NzaWJseSBtdWx0aXBsZSB0aW1lcyBkdWUgdG8gY29uY3VycmVuY3kpXG4gICAgICBleHBlY3QobW9ja1NlbmRFbWFpbFdpdGhSZXRyeSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgcmFjZSBjb25kaXRpb24gYmV0d2VlbiB2ZXJpZmljYXRpb24gYW5kIGNvZGUgZXhwaXJhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSB1c2VyIHdpdGggY29kZSB0aGF0IGV4cGlyZXMgdmVyeSBzb29uXG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RVc2VyKHtcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgICAgIHBhc3N3b3JkSGFzaDogJ2hhc2hlZF9wYXNzd29yZCcsXG4gICAgICAgIGlzRW1haWxWZXJpZmllZDogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RFbWFpbENvZGUoe1xuICAgICAgICB1c2VySWQ6IHVzZXIuaWQsXG4gICAgICAgIGNvZGU6ICcxMjM0NTYnLFxuICAgICAgICBleHBpcmVzQXQ6IG5ldyBEYXRlKERhdGUubm93KCkgKyAxMDApLCAvLyBFeHBpcmVzIGluIDEwMG1zXG4gICAgICAgIGF0dGVtcHRzVXNlZDogMCxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBXYWl0IGZvciBjb2RlIHRvIGV4cGlyZVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDE1MCkpO1xuXG4gICAgICAvLyBUcnkgdG8gdmVyaWZ5IHdpdGggZXhwaXJlZCBjb2RlXG4gICAgICBjb25zdCB2ZXJpZnlSZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0L2FwaS9hdXRoL3ZlcmlmeS1lbWFpbCcsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIGNvZGU6ICcxMjM0NTYnLFxuICAgICAgICB9KSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdmVyaWZ5UmVzcG9uc2UgPSBhd2FpdCB2ZXJpZnlFbWFpbEhhbmRsZXIodmVyaWZ5UmVxdWVzdCk7XG4gICAgICBjb25zdCB2ZXJpZnlEYXRhID0gYXdhaXQgdmVyaWZ5UmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAvLyBTaG91bGQgaGFuZGxlIGV4cGlyZWQgY29kZSBncmFjZWZ1bGx5XG4gICAgICBleHBlY3QodmVyaWZ5UmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMCk7XG4gICAgICBleHBlY3QodmVyaWZ5RGF0YS5lcnJvcikudG9Db250YWluKCdleHBpcmVkJyk7XG5cbiAgICAgIC8vIFVzZXIgc2hvdWxkIHJlbWFpbiB1bnZlcmlmaWVkXG4gICAgICBjb25zdCB1bnZlcmlmaWVkVXNlciA9IGF3YWl0IGRiTWFuYWdlci5nZXRVc2VyQnlJZCh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdCh1bnZlcmlmaWVkVXNlci5pc0VtYWlsVmVyaWZpZWQpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY29uY3VycmVudCBzaWdudXAgYXR0ZW1wdHMgd2l0aCBzYW1lIGVtYWlsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIGNvbmN1cnJlbnQgc2lnbnVwIHJlcXVlc3RzIHdpdGggc2FtZSBlbWFpbFxuICAgICAgY29uc3Qgc2lnbnVwUmVxdWVzdDEgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvYXBpL2F1dGgvc2lnbnVwJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgcGFzc3dvcmQ6ICdTZWN1cmVQYXNzMTIzIScsXG4gICAgICAgICAgbmFtZTogJ1Rlc3QgVXNlciAxJyxcbiAgICAgICAgfSksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHNpZ251cFJlcXVlc3QyID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0L2FwaS9hdXRoL3NpZ251cCcsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIHBhc3N3b3JkOiAnQW5vdGhlclBhc3MxMjMhJyxcbiAgICAgICAgICBuYW1lOiAnVGVzdCBVc2VyIDInLFxuICAgICAgICB9KSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgLy8gRXhlY3V0ZSBjb25jdXJyZW50IHJlcXVlc3RzXG4gICAgICBjb25zdCBbcmVzcG9uc2UxLCByZXNwb25zZTJdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBzaWdudXBIYW5kbGVyKHNpZ251cFJlcXVlc3QxKSxcbiAgICAgICAgc2lnbnVwSGFuZGxlcihzaWdudXBSZXF1ZXN0MiksXG4gICAgICBdKTtcblxuICAgICAgY29uc3QgZGF0YTEgPSBhd2FpdCByZXNwb25zZTEuanNvbigpO1xuICAgICAgY29uc3QgZGF0YTIgPSBhd2FpdCByZXNwb25zZTIuanNvbigpO1xuXG4gICAgICAvLyBPbmUgc2hvdWxkIHN1Y2NlZWQsIG9uZSBzaG91bGQgZmFpbCB3aXRoIGR1cGxpY2F0ZSBlbWFpbCBlcnJvclxuICAgICAgY29uc3QgcmVzcG9uc2VzID0gW1xuICAgICAgICB7IHN0YXR1czogcmVzcG9uc2UxLnN0YXR1cywgZGF0YTogZGF0YTEgfSxcbiAgICAgICAgeyBzdGF0dXM6IHJlc3BvbnNlMi5zdGF0dXMsIGRhdGE6IGRhdGEyIH0sXG4gICAgICBdO1xuXG4gICAgICBjb25zdCBzdWNjZXNzUmVzcG9uc2VzID0gcmVzcG9uc2VzLmZpbHRlcihyID0+IHIuc3RhdHVzID09PSAyMDApO1xuICAgICAgY29uc3QgY29uZmxpY3RSZXNwb25zZXMgPSByZXNwb25zZXMuZmlsdGVyKHIgPT4gci5zdGF0dXMgPT09IDQwOSk7XG5cbiAgICAgIGV4cGVjdChzdWNjZXNzUmVzcG9uc2VzKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QoY29uZmxpY3RSZXNwb25zZXMpLnRvSGF2ZUxlbmd0aCgxKTtcblxuICAgICAgLy8gVmVyaWZ5IG9ubHkgb25lIHVzZXIgd2FzIGNyZWF0ZWRcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBkYk1hbmFnZXIuZ2V0VXNlckJ5RW1haWwoJ3Rlc3RAZXhhbXBsZS5jb20nKTtcbiAgICAgIGV4cGVjdCh1c2VyKS50b0JlVHJ1dGh5KCk7XG5cbiAgICAgIC8vIFZlcmlmeSBvbmx5IG9uZSBzZXQgb2YgdmVyaWZpY2F0aW9uIGNvZGVzIGV4aXN0c1xuICAgICAgY29uc3QgZW1haWxDb2RlcyA9IGF3YWl0IGRiTWFuYWdlci5nZXRFbWFpbENvZGVzQnlVc2VySWQodXNlci5pZCk7XG4gICAgICBleHBlY3QoZW1haWxDb2RlcykudG9IYXZlTGVuZ3RoKDEpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRGF0YWJhc2UgRXJyb3IgU2NlbmFyaW9zJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIGRhdGFiYXNlIGNvbm5lY3Rpb24gZmFpbHVyZXMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgZGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsdXJlXG4gICAgICBjb25zdCBvcmlnaW5hbERiID0gcmVxdWlyZSgnQC9saWIvZGInKS5kYjtcbiAgICAgIFxuICAgICAgLy8gTW9jayBkYXRhYmFzZSB0byB0aHJvdyBjb25uZWN0aW9uIGVycm9yXG4gICAgICBqZXN0LmRvTW9jaygnQC9saWIvZGInLCAoKSA9PiAoe1xuICAgICAgICBkYjoge1xuICAgICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnKSksXG4gICAgICAgICAgaW5zZXJ0OiBqZXN0LmZuKCkubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZCcpKSxcbiAgICAgICAgICB1cGRhdGU6IGplc3QuZm4oKS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZmFpbGVkJykpLFxuICAgICAgICAgIGRlbGV0ZTogamVzdC5mbigpLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnKSksXG4gICAgICAgIH0sXG4gICAgICB9KSk7XG5cbiAgICAgIGNvbnN0IHZlcmlmeVJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvYXBpL2F1dGgvdmVyaWZ5LWVtYWlsJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgY29kZTogJzEyMzQ1NicsXG4gICAgICAgIH0pLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB2ZXJpZnlSZXNwb25zZSA9IGF3YWl0IHZlcmlmeUVtYWlsSGFuZGxlcih2ZXJpZnlSZXF1ZXN0KTtcbiAgICAgIGNvbnN0IHZlcmlmeURhdGEgPSBhd2FpdCB2ZXJpZnlSZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIC8vIFNob3VsZCBoYW5kbGUgZGF0YWJhc2UgZXJyb3IgZ3JhY2VmdWxseVxuICAgICAgZXhwZWN0KHZlcmlmeVJlc3BvbnNlLnN0YXR1cykudG9CZSg1MDApO1xuICAgICAgZXhwZWN0KHZlcmlmeURhdGEuZXJyb3IpLnRvQmUoJ0ludGVybmFsIHNlcnZlciBlcnJvcicpO1xuXG4gICAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIGRhdGFiYXNlXG4gICAgICBqZXN0LmRvTW9jaygnQC9saWIvZGInLCAoKSA9PiAoeyBkYjogb3JpZ2luYWxEYiB9KSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSB0cmFuc2FjdGlvbiByb2xsYmFjayBzY2VuYXJpb3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBUaGlzIHRlc3Qgd291bGQgcmVxdWlyZSBtb3JlIGNvbXBsZXggZGF0YWJhc2UgdHJhbnNhY3Rpb24gbW9ja2luZ1xuICAgICAgLy8gRm9yIG5vdywgd2UnbGwgdGVzdCB0aGF0IHRoZSBzZXJ2aWNlIGhhbmRsZXMgZXJyb3JzIGR1cmluZyBjb2RlIHZhbGlkYXRpb25cbiAgICAgIFxuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0VXNlcih7XG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgICBwYXNzd29yZEhhc2g6ICdoYXNoZWRfcGFzc3dvcmQnLFxuICAgICAgICBpc0VtYWlsVmVyaWZpZWQ6IGZhbHNlLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIENyZWF0ZSBjb2RlIHdpdGggbWF4aW11bSBhdHRlbXB0cyByZWFjaGVkXG4gICAgICBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdEVtYWlsQ29kZSh7XG4gICAgICAgIHVzZXJJZDogdXNlci5pZCxcbiAgICAgICAgY29kZTogJzEyMzQ1NicsXG4gICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIDYwMDAwMCksXG4gICAgICAgIGF0dGVtcHRzVXNlZDogNSwgLy8gTWF4aW11bSBhdHRlbXB0cyByZWFjaGVkXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdmVyaWZ5UmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdC9hcGkvYXV0aC92ZXJpZnktZW1haWwnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBjb2RlOiAnMTIzNDU2JyxcbiAgICAgICAgfSksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHZlcmlmeVJlc3BvbnNlID0gYXdhaXQgdmVyaWZ5RW1haWxIYW5kbGVyKHZlcmlmeVJlcXVlc3QpO1xuICAgICAgY29uc3QgdmVyaWZ5RGF0YSA9IGF3YWl0IHZlcmlmeVJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgLy8gU2hvdWxkIGhhbmRsZSB0b28gbWFueSBhdHRlbXB0cyBlcnJvclxuICAgICAgZXhwZWN0KHZlcmlmeVJlc3BvbnNlLnN0YXR1cykudG9CZSg0MjkpO1xuICAgICAgZXhwZWN0KHZlcmlmeURhdGEuZXJyb3IpLnRvQ29udGFpbignVG9vIG1hbnkgdmVyaWZpY2F0aW9uIGF0dGVtcHRzJyk7XG5cbiAgICAgIC8vIFVzZXIgc2hvdWxkIHJlbWFpbiB1bnZlcmlmaWVkXG4gICAgICBjb25zdCB1bnZlcmlmaWVkVXNlciA9IGF3YWl0IGRiTWFuYWdlci5nZXRVc2VyQnlJZCh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdCh1bnZlcmlmaWVkVXNlci5pc0VtYWlsVmVyaWZpZWQpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsIm1vY2tFbWFpbFNlcnZpY2UiLCJzZW5kVmVyaWZpY2F0aW9uRW1haWwiLCJmbiIsIm1vY2tDcmVhdGVFbWFpbFNlcnZpY2UiLCJjcmVhdGVFbWFpbFNlcnZpY2UiLCJtb2NrU2VuZEVtYWlsV2l0aFJldHJ5IiwicmVxdWlyZSIsInNlbmRFbWFpbFdpdGhSZXRyeSIsIm9yaWdpbmFsRW52IiwicHJvY2VzcyIsImVudiIsImJlZm9yZUFsbCIsIlJFU0VORF9BUElfS0VZIiwiRlJPTV9FTUFJTCIsIkZST01fTkFNRSIsIlZFUklGSUNBVElPTl9DT0RFX0VYUElSWV9NSU5VVEVTIiwiTUFYX1ZFUklGSUNBVElPTl9BVFRFTVBUUyIsIlJFU0VORF9DT09MRE9XTl9TRUNPTkRTIiwiTUFYX1JFU0VORF9QRVJfSE9VUiIsIk5PREVfRU5WIiwiYWZ0ZXJBbGwiLCJkZXNjcmliZSIsImRiTWFuYWdlciIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwiY3JlYXRlRGF0YWJhc2VUZXN0TWFuYWdlciIsIm1vY2tSZXR1cm5WYWx1ZSIsIm1vY2tSZXNvbHZlZFZhbHVlIiwiYWZ0ZXJFYWNoIiwiY2xlYW51cCIsIml0IiwicXVvdGFFcnJvciIsIkVtYWlsU2VydmljZUVycm9yIiwibW9ja1JlamVjdGVkVmFsdWUiLCJzaWdudXBSZXF1ZXN0IiwiTmV4dFJlcXVlc3QiLCJtZXRob2QiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImVtYWlsIiwicGFzc3dvcmQiLCJuYW1lIiwiaGVhZGVycyIsInNpZ251cFJlc3BvbnNlIiwic2lnbnVwSGFuZGxlciIsInNpZ251cERhdGEiLCJqc29uIiwiZXhwZWN0Iiwic3RhdHVzIiwidG9CZSIsInN1Y2Nlc3MiLCJyZXF1aXJlc1ZlcmlmaWNhdGlvbiIsImVtYWlsRXJyb3IiLCJ0b0NvbnRhaW4iLCJ1c2VyIiwiZ2V0VXNlckJ5RW1haWwiLCJ0b0JlVHJ1dGh5IiwiaXNFbWFpbFZlcmlmaWVkIiwiZW1haWxDb2RlcyIsImdldEVtYWlsQ29kZXNCeVVzZXJJZCIsImlkIiwidG9IYXZlTGVuZ3RoIiwiYXBpRXJyb3IiLCJjcmVhdGVUZXN0VXNlciIsInBhc3N3b3JkSGFzaCIsInJlc2VuZFJlcXVlc3QiLCJyZXNlbmRSZXNwb25zZSIsInJlc2VuZFZlcmlmaWNhdGlvbkhhbmRsZXIiLCJyZXNlbmREYXRhIiwiZXJyb3IiLCJ0b0hhdmVCZWVuQ2FsbGVkVGltZXMiLCJuZXR3b3JrRXJyb3IiLCJpbnZhbGlkRW1haWxFcnJvciIsIkVycm9yIiwiZXhwaXJlZENvZGUiLCJjcmVhdGVUZXN0RW1haWxDb2RlIiwidXNlcklkIiwiY29kZSIsImV4cGlyZXNBdCIsIkRhdGUiLCJub3ciLCJhdHRlbXB0c1VzZWQiLCJ2ZXJpZnlSZXF1ZXN0IiwidmVyaWZ5UmVzcG9uc2UiLCJ2ZXJpZnlFbWFpbEhhbmRsZXIiLCJ2ZXJpZnlEYXRhIiwidW52ZXJpZmllZFVzZXIiLCJnZXRVc2VyQnlJZCIsImVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UiLCJjbGVhbnVwRXhwaXJlZENvZGVzIiwicmVtYWluaW5nQ29kZXMiLCJkZWxldGVVc2VyIiwidmVyaWZ5UmVxdWVzdDEiLCJ2ZXJpZnlSZXF1ZXN0MiIsInJlc3BvbnNlMSIsInJlc3BvbnNlMiIsIlByb21pc2UiLCJhbGwiLCJkYXRhMSIsImRhdGEyIiwicmVzcG9uc2VzIiwiZGF0YSIsInN1Y2Nlc3NSZXNwb25zZXMiLCJmaWx0ZXIiLCJyIiwiZmFpbHVyZVJlc3BvbnNlcyIsInZlcmlmaWVkVXNlciIsInJlc2VuZFJlcXVlc3QxIiwicmVzZW5kUmVxdWVzdDIiLCJ0b0hhdmVCZWVuQ2FsbGVkIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJzaWdudXBSZXF1ZXN0MSIsInNpZ251cFJlcXVlc3QyIiwiY29uZmxpY3RSZXNwb25zZXMiLCJvcmlnaW5hbERiIiwiZGIiLCJkb01vY2siLCJzZWxl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