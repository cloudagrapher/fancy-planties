6b6f5056940371fd46ccff7cea289d15
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _emailverificationcodeservice = require("../email-verification-code-service");
// Mock the database
const mockDb = {
    insert: _globals.jest.fn(),
    select: _globals.jest.fn(),
    update: _globals.jest.fn(),
    delete: _globals.jest.fn(),
    transaction: _globals.jest.fn()
};
_globals.jest.mock('@/lib/db', ()=>({
        db: mockDb
    }));
(0, _globals.describe)('EmailVerificationCodeService', ()=>{
    let service;
    const mockUserId = 1;
    const mockEmail = 'test@example.com';
    const mockCode = '123456';
    (0, _globals.beforeEach)(()=>{
        service = new _emailverificationcodeservice.EmailVerificationCodeService();
        _globals.jest.clearAllMocks();
    });
    (0, _globals.afterEach)(()=>{
        _globals.jest.restoreAllMocks();
    });
    (0, _globals.describe)('generateCode', ()=>{
        (0, _globals.it)('should generate a 6-digit code', async ()=>{
            // Mock deleteUserCodes to resolve
            const deleteUserCodesSpy = _globals.jest.spyOn(service, 'deleteUserCodes').mockResolvedValue();
            // Mock insert chain
            const mockValues = _globals.jest.fn().mockResolvedValue(undefined);
            mockDb.insert.mockReturnValue({
                values: mockValues
            });
            const code = await service.generateCode(mockUserId);
            (0, _globals.expect)(code).toMatch(/^\d{6}$/);
            (0, _globals.expect)(deleteUserCodesSpy).toHaveBeenCalledWith(mockUserId);
            (0, _globals.expect)(mockDb.insert).toHaveBeenCalled();
            (0, _globals.expect)(mockValues).toHaveBeenCalledWith(_globals.expect.objectContaining({
                userId: mockUserId,
                code: _globals.expect.stringMatching(/^\d{6}$/),
                expiresAt: _globals.expect.any(Date),
                attemptsUsed: 0
            }));
        });
        (0, _globals.it)('should delete existing codes before generating new one', async ()=>{
            const deleteUserCodesSpy = _globals.jest.spyOn(service, 'deleteUserCodes').mockResolvedValue();
            const mockValues = _globals.jest.fn().mockResolvedValue(undefined);
            mockDb.insert.mockReturnValue({
                values: mockValues
            });
            await service.generateCode(mockUserId);
            (0, _globals.expect)(deleteUserCodesSpy).toHaveBeenCalledWith(mockUserId);
        });
        (0, _globals.it)('should store code with correct expiration time', async ()=>{
            _globals.jest.spyOn(service, 'deleteUserCodes').mockResolvedValue();
            const mockValues = _globals.jest.fn().mockResolvedValue(undefined);
            mockDb.insert.mockReturnValue({
                values: mockValues
            });
            const beforeTime = Date.now();
            await service.generateCode(mockUserId);
            const afterTime = Date.now();
            (0, _globals.expect)(mockValues).toHaveBeenCalledWith(_globals.expect.objectContaining({
                userId: mockUserId,
                code: _globals.expect.stringMatching(/^\d{6}$/),
                expiresAt: _globals.expect.any(Date),
                attemptsUsed: 0
            }));
            // Check that expiration is approximately 10 minutes from now
            const callArgs = mockValues.mock.calls[0][0];
            const expirationTime = callArgs.expiresAt.getTime();
            const expectedMin = beforeTime + 9.5 * 60 * 1000; // 9.5 minutes
            const expectedMax = afterTime + 10.5 * 60 * 1000; // 10.5 minutes
            (0, _globals.expect)(expirationTime).toBeGreaterThan(expectedMin);
            (0, _globals.expect)(expirationTime).toBeLessThan(expectedMax);
        });
    });
    (0, _globals.describe)('validateCode', ()=>{
        const mockUser = {
            id: mockUserId,
            isEmailVerified: false
        };
        const mockVerificationCode = {
            id: 1,
            userId: mockUserId,
            code: mockCode,
            expiresAt: new Date(Date.now() + 5 * 60 * 1000),
            createdAt: new Date(),
            attemptsUsed: 0
        };
        (0, _globals.it)('should validate correct code successfully', async ()=>{
            // Mock user lookup
            const mockUserLimit = _globals.jest.fn().mockResolvedValue([
                mockUser
            ]);
            const mockUserWhere = _globals.jest.fn().mockReturnValue({
                limit: mockUserLimit
            });
            const mockUserFrom = _globals.jest.fn().mockReturnValue({
                where: mockUserWhere
            });
            mockDb.select.mockReturnValueOnce({
                from: mockUserFrom
            });
            // Mock verification code lookup
            const mockCodeLimit = _globals.jest.fn().mockResolvedValue([
                mockVerificationCode
            ]);
            const mockCodeWhere = _globals.jest.fn().mockReturnValue({
                limit: mockCodeLimit
            });
            const mockCodeFrom = _globals.jest.fn().mockReturnValue({
                where: mockCodeWhere
            });
            mockDb.select.mockReturnValueOnce({
                from: mockCodeFrom
            });
            // Mock transaction
            const mockTx = {
                update: _globals.jest.fn().mockReturnValue({
                    set: _globals.jest.fn().mockReturnValue({
                        where: _globals.jest.fn().mockResolvedValue(undefined)
                    })
                }),
                delete: _globals.jest.fn().mockReturnValue({
                    where: _globals.jest.fn().mockResolvedValue(undefined)
                })
            };
            mockDb.transaction.mockImplementation(async (callback)=>callback(mockTx));
            const result = await service.validateCode(mockEmail, mockCode);
            (0, _globals.expect)(result).toBe(true);
            (0, _globals.expect)(mockDb.transaction).toHaveBeenCalled();
        });
        (0, _globals.it)('should throw USER_NOT_FOUND when user does not exist', async ()=>{
            // Mock user lookup to return empty array
            const mockUserLimit = _globals.jest.fn().mockResolvedValue([]);
            const mockUserWhere = _globals.jest.fn().mockReturnValue({
                limit: mockUserLimit
            });
            const mockUserFrom = _globals.jest.fn().mockReturnValue({
                where: mockUserWhere
            });
            mockDb.select.mockReturnValueOnce({
                from: mockUserFrom
            });
            await (0, _globals.expect)(service.validateCode(mockEmail, mockCode)).rejects.toThrow(new _emailverificationcodeservice.VerificationCodeError('User not found', _emailverificationcodeservice.VerificationError.USER_NOT_FOUND));
        });
        (0, _globals.it)('should throw ALREADY_VERIFIED when user is already verified', async ()=>{
            // Mock user lookup to return verified user
            const mockUserLimit = _globals.jest.fn().mockResolvedValue([
                {
                    ...mockUser,
                    isEmailVerified: true
                }
            ]);
            const mockUserWhere = _globals.jest.fn().mockReturnValue({
                limit: mockUserLimit
            });
            const mockUserFrom = _globals.jest.fn().mockReturnValue({
                where: mockUserWhere
            });
            mockDb.select.mockReturnValueOnce({
                from: mockUserFrom
            });
            await (0, _globals.expect)(service.validateCode(mockEmail, mockCode)).rejects.toThrow(new _emailverificationcodeservice.VerificationCodeError('Email already verified', _emailverificationcodeservice.VerificationError.ALREADY_VERIFIED));
        });
        (0, _globals.it)('should throw CODE_INVALID when code does not exist', async ()=>{
            // Mock user lookup
            const mockUserLimit = _globals.jest.fn().mockResolvedValue([
                mockUser
            ]);
            const mockUserWhere = _globals.jest.fn().mockReturnValue({
                limit: mockUserLimit
            });
            const mockUserFrom = _globals.jest.fn().mockReturnValue({
                where: mockUserWhere
            });
            mockDb.select.mockReturnValueOnce({
                from: mockUserFrom
            });
            // Mock verification code lookup to return empty array
            const mockCodeLimit = _globals.jest.fn().mockResolvedValue([]);
            const mockCodeWhere = _globals.jest.fn().mockReturnValue({
                limit: mockCodeLimit
            });
            const mockCodeFrom = _globals.jest.fn().mockReturnValue({
                where: mockCodeWhere
            });
            mockDb.select.mockReturnValueOnce({
                from: mockCodeFrom
            });
            await (0, _globals.expect)(service.validateCode(mockEmail, mockCode)).rejects.toThrow(new _emailverificationcodeservice.VerificationCodeError('Invalid verification code', _emailverificationcodeservice.VerificationError.CODE_INVALID));
        });
        (0, _globals.it)('should throw CODE_EXPIRED when code has expired', async ()=>{
            const expiredCode = {
                ...mockVerificationCode,
                expiresAt: new Date(Date.now() - 5 * 60 * 1000)
            };
            // Mock user lookup
            const mockUserLimit = _globals.jest.fn().mockResolvedValue([
                mockUser
            ]);
            const mockUserWhere = _globals.jest.fn().mockReturnValue({
                limit: mockUserLimit
            });
            const mockUserFrom = _globals.jest.fn().mockReturnValue({
                where: mockUserWhere
            });
            mockDb.select.mockReturnValueOnce({
                from: mockUserFrom
            });
            // Mock verification code lookup
            const mockCodeLimit = _globals.jest.fn().mockResolvedValue([
                expiredCode
            ]);
            const mockCodeWhere = _globals.jest.fn().mockReturnValue({
                limit: mockCodeLimit
            });
            const mockCodeFrom = _globals.jest.fn().mockReturnValue({
                where: mockCodeWhere
            });
            mockDb.select.mockReturnValueOnce({
                from: mockCodeFrom
            });
            // Mock delete for expired code cleanup
            const mockDeleteWhere = _globals.jest.fn().mockResolvedValue(undefined);
            mockDb.delete.mockReturnValue({
                where: mockDeleteWhere
            });
            await (0, _globals.expect)(service.validateCode(mockEmail, mockCode)).rejects.toThrow(new _emailverificationcodeservice.VerificationCodeError('Verification code has expired', _emailverificationcodeservice.VerificationError.CODE_EXPIRED));
            (0, _globals.expect)(mockDb.delete).toHaveBeenCalled();
        });
        (0, _globals.it)('should throw TOO_MANY_ATTEMPTS when max attempts exceeded', async ()=>{
            const maxAttemptsCode = {
                ...mockVerificationCode,
                attemptsUsed: 5
            };
            // Mock user lookup
            const mockUserLimit = _globals.jest.fn().mockResolvedValue([
                mockUser
            ]);
            const mockUserWhere = _globals.jest.fn().mockReturnValue({
                limit: mockUserLimit
            });
            const mockUserFrom = _globals.jest.fn().mockReturnValue({
                where: mockUserWhere
            });
            mockDb.select.mockReturnValueOnce({
                from: mockUserFrom
            });
            // Mock verification code lookup
            const mockCodeLimit = _globals.jest.fn().mockResolvedValue([
                maxAttemptsCode
            ]);
            const mockCodeWhere = _globals.jest.fn().mockReturnValue({
                limit: mockCodeLimit
            });
            const mockCodeFrom = _globals.jest.fn().mockReturnValue({
                where: mockCodeWhere
            });
            mockDb.select.mockReturnValueOnce({
                from: mockCodeFrom
            });
            // Mock delete for code invalidation
            const mockDeleteWhere = _globals.jest.fn().mockResolvedValue(undefined);
            mockDb.delete.mockReturnValue({
                where: mockDeleteWhere
            });
            await (0, _globals.expect)(service.validateCode(mockEmail, mockCode)).rejects.toThrow(new _emailverificationcodeservice.VerificationCodeError('Too many verification attempts', _emailverificationcodeservice.VerificationError.TOO_MANY_ATTEMPTS));
            (0, _globals.expect)(mockDb.delete).toHaveBeenCalled();
        });
    });
    (0, _globals.describe)('incrementAttempts', ()=>{
        const mockUser = {
            id: mockUserId
        };
        const mockVerificationCode = {
            id: 1,
            attemptsUsed: 2
        };
        (0, _globals.it)('should increment attempts for valid code', async ()=>{
            // Mock user lookup
            const mockUserLimit = _globals.jest.fn().mockResolvedValue([
                mockUser
            ]);
            const mockUserWhere = _globals.jest.fn().mockReturnValue({
                limit: mockUserLimit
            });
            const mockUserFrom = _globals.jest.fn().mockReturnValue({
                where: mockUserWhere
            });
            mockDb.select.mockReturnValueOnce({
                from: mockUserFrom
            });
            // Mock verification code lookup
            const mockCodeLimit = _globals.jest.fn().mockResolvedValue([
                mockVerificationCode
            ]);
            const mockCodeWhere = _globals.jest.fn().mockReturnValue({
                limit: mockCodeLimit
            });
            const mockCodeFrom = _globals.jest.fn().mockReturnValue({
                where: mockCodeWhere
            });
            mockDb.select.mockReturnValueOnce({
                from: mockCodeFrom
            });
            // Mock update
            const mockUpdateWhere = _globals.jest.fn().mockResolvedValue(undefined);
            const mockUpdateSet = _globals.jest.fn().mockReturnValue({
                where: mockUpdateWhere
            });
            mockDb.update.mockReturnValue({
                set: mockUpdateSet
            });
            await service.incrementAttempts(mockEmail, mockCode);
            (0, _globals.expect)(mockDb.update).toHaveBeenCalled();
            (0, _globals.expect)(mockUpdateSet).toHaveBeenCalledWith({
                attemptsUsed: 3
            });
        });
        (0, _globals.it)('should handle user not found gracefully', async ()=>{
            // Mock user lookup to return empty array
            const mockUserLimit = _globals.jest.fn().mockResolvedValue([]);
            const mockUserWhere = _globals.jest.fn().mockReturnValue({
                limit: mockUserLimit
            });
            const mockUserFrom = _globals.jest.fn().mockReturnValue({
                where: mockUserWhere
            });
            mockDb.select.mockReturnValueOnce({
                from: mockUserFrom
            });
            await (0, _globals.expect)(service.incrementAttempts(mockEmail, mockCode)).resolves.toBeUndefined();
            (0, _globals.expect)(mockDb.update).not.toHaveBeenCalled();
        });
        (0, _globals.it)('should handle code not found gracefully', async ()=>{
            // Mock user lookup
            const mockUserLimit = _globals.jest.fn().mockResolvedValue([
                mockUser
            ]);
            const mockUserWhere = _globals.jest.fn().mockReturnValue({
                limit: mockUserLimit
            });
            const mockUserFrom = _globals.jest.fn().mockReturnValue({
                where: mockUserWhere
            });
            mockDb.select.mockReturnValueOnce({
                from: mockUserFrom
            });
            // Mock verification code lookup to return empty array
            const mockCodeLimit = _globals.jest.fn().mockResolvedValue([]);
            const mockCodeWhere = _globals.jest.fn().mockReturnValue({
                limit: mockCodeLimit
            });
            const mockCodeFrom = _globals.jest.fn().mockReturnValue({
                where: mockCodeWhere
            });
            mockDb.select.mockReturnValueOnce({
                from: mockCodeFrom
            });
            await (0, _globals.expect)(service.incrementAttempts(mockEmail, mockCode)).resolves.toBeUndefined();
            (0, _globals.expect)(mockDb.update).not.toHaveBeenCalled();
        });
    });
    (0, _globals.describe)('cleanupExpiredCodes', ()=>{
        (0, _globals.it)('should delete expired codes and return count', async ()=>{
            const mockDeleteResult = {
                rowCount: 5
            };
            const mockDeleteWhere = _globals.jest.fn().mockResolvedValue(mockDeleteResult);
            mockDb.delete.mockReturnValue({
                where: mockDeleteWhere
            });
            const result = await service.cleanupExpiredCodes();
            (0, _globals.expect)(result).toBe(5);
            (0, _globals.expect)(mockDb.delete).toHaveBeenCalled();
        });
        (0, _globals.it)('should handle missing rowCount gracefully', async ()=>{
            const mockDeleteResult = {}; // No rowCount property
            const mockDeleteWhere = _globals.jest.fn().mockResolvedValue(mockDeleteResult);
            mockDb.delete.mockReturnValue({
                where: mockDeleteWhere
            });
            const result = await service.cleanupExpiredCodes();
            (0, _globals.expect)(result).toBe(0);
        });
    });
    (0, _globals.describe)('deleteUserCodes', ()=>{
        (0, _globals.it)('should delete all codes for a user', async ()=>{
            const mockDeleteWhere = _globals.jest.fn().mockResolvedValue(undefined);
            mockDb.delete.mockReturnValue({
                where: mockDeleteWhere
            });
            await service.deleteUserCodes(mockUserId);
            (0, _globals.expect)(mockDb.delete).toHaveBeenCalled();
        });
    });
    (0, _globals.describe)('getUserActiveCode', ()=>{
        (0, _globals.it)('should return active code for user', async ()=>{
            const mockActiveCode = {
                id: 1,
                userId: mockUserId,
                code: mockCode,
                expiresAt: new Date(Date.now() + 5 * 60 * 1000),
                createdAt: new Date(),
                attemptsUsed: 0
            };
            const mockLimit = _globals.jest.fn().mockResolvedValue([
                mockActiveCode
            ]);
            const mockWhere = _globals.jest.fn().mockReturnValue({
                limit: mockLimit
            });
            const mockFrom = _globals.jest.fn().mockReturnValue({
                where: mockWhere
            });
            mockDb.select.mockReturnValue({
                from: mockFrom
            });
            const result = await service.getUserActiveCode(mockUserId);
            (0, _globals.expect)(result).toEqual(mockActiveCode);
        });
        (0, _globals.it)('should return null when no active code exists', async ()=>{
            const mockLimit = _globals.jest.fn().mockResolvedValue([]);
            const mockWhere = _globals.jest.fn().mockReturnValue({
                limit: mockLimit
            });
            const mockFrom = _globals.jest.fn().mockReturnValue({
                where: mockWhere
            });
            mockDb.select.mockReturnValue({
                from: mockFrom
            });
            const result = await service.getUserActiveCode(mockUserId);
            (0, _globals.expect)(result).toBeNull();
        });
    });
    (0, _globals.describe)('hasActiveCode', ()=>{
        (0, _globals.it)('should return true when user has active code', async ()=>{
            _globals.jest.spyOn(service, 'getUserActiveCode').mockResolvedValue({
                id: 1,
                userId: mockUserId,
                code: mockCode,
                expiresAt: new Date(),
                createdAt: new Date(),
                attemptsUsed: 0
            });
            const result = await service.hasActiveCode(mockUserId);
            (0, _globals.expect)(result).toBe(true);
        });
        (0, _globals.it)('should return false when user has no active code', async ()=>{
            _globals.jest.spyOn(service, 'getUserActiveCode').mockResolvedValue(null);
            const result = await service.hasActiveCode(mockUserId);
            (0, _globals.expect)(result).toBe(false);
        });
    });
    (0, _globals.describe)('getCodeStats', ()=>{
        (0, _globals.it)('should return code statistics', async ()=>{
            // Mock the three select queries for stats
            const mockFrom1 = _globals.jest.fn().mockReturnValue({
                where: _globals.jest.fn().mockResolvedValue([
                    1,
                    2,
                    3
                ])
            });
            const mockFrom2 = _globals.jest.fn().mockReturnValue({
                where: _globals.jest.fn().mockResolvedValue([
                    1,
                    2
                ])
            });
            const mockFrom3 = _globals.jest.fn().mockReturnValue({
                where: _globals.jest.fn().mockResolvedValue([
                    1
                ])
            });
            mockDb.select.mockReturnValueOnce({
                from: mockFrom1
            }).mockReturnValueOnce({
                from: mockFrom2
            }).mockReturnValueOnce({
                from: mockFrom3
            });
            const result = await service.getCodeStats();
            (0, _globals.expect)(result).toEqual({
                totalActive: 3,
                expiredCount: 2,
                highAttemptCount: 1
            });
        });
    });
    (0, _globals.describe)('code generation security', ()=>{
        (0, _globals.it)('should generate unique codes', async ()=>{
            _globals.jest.spyOn(service, 'deleteUserCodes').mockResolvedValue();
            const mockValues = _globals.jest.fn().mockResolvedValue(undefined);
            mockDb.insert.mockReturnValue({
                values: mockValues
            });
            const codes = new Set();
            for(let i = 0; i < 100; i++){
                const code = await service.generateCode(mockUserId);
                codes.add(code);
            }
            // Should have generated 100 unique codes (very high probability)
            (0, _globals.expect)(codes.size).toBeGreaterThan(95);
        });
        (0, _globals.it)('should always generate 6-digit codes', async ()=>{
            _globals.jest.spyOn(service, 'deleteUserCodes').mockResolvedValue();
            const mockValues = _globals.jest.fn().mockResolvedValue(undefined);
            mockDb.insert.mockReturnValue({
                values: mockValues
            });
            for(let i = 0; i < 50; i++){
                const code = await service.generateCode(mockUserId);
                (0, _globals.expect)(code).toMatch(/^\d{6}$/);
                (0, _globals.expect)(code.length).toBe(6);
            }
        });
        (0, _globals.it)('should pad codes with leading zeros', async ()=>{
            _globals.jest.spyOn(service, 'deleteUserCodes').mockResolvedValue();
            const mockValues = _globals.jest.fn().mockResolvedValue(undefined);
            mockDb.insert.mockReturnValue({
                values: mockValues
            });
            // Mock crypto.randomBytes to return a small number
            const originalRandomBytes = require('crypto').randomBytes;
            const mockRandomBytes = _globals.jest.fn().mockReturnValue(Buffer.from([
                0,
                0,
                0,
                1
            ])); // Very small number
            require('crypto').randomBytes = mockRandomBytes;
            const code = await service.generateCode(mockUserId);
            (0, _globals.expect)(code).toMatch(/^\d{6}$/);
            (0, _globals.expect)(code.length).toBe(6);
            // Restore original function
            require('crypto').randomBytes = originalRandomBytes;
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdGVmYW5iZWtrZXIvcHJvamVjdHMvZmFuY3ktcGxhbnRpZXMvc3JjL2xpYi9zZXJ2aWNlcy9fX3Rlc3RzX18vZW1haWwtdmVyaWZpY2F0aW9uLWNvZGUtc2VydmljZS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlc2NyaWJlLCBpdCwgZXhwZWN0LCBiZWZvcmVFYWNoLCBhZnRlckVhY2gsIGplc3QgfSBmcm9tICdAamVzdC9nbG9iYWxzJztcbmltcG9ydCB7IEVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UsIFZlcmlmaWNhdGlvbkVycm9yLCBWZXJpZmljYXRpb25Db2RlRXJyb3IgfSBmcm9tICcuLi9lbWFpbC12ZXJpZmljYXRpb24tY29kZS1zZXJ2aWNlJztcblxuLy8gTW9jayB0aGUgZGF0YWJhc2VcbmNvbnN0IG1vY2tEYiA9IHtcbiAgaW5zZXJ0OiBqZXN0LmZuKCksXG4gIHNlbGVjdDogamVzdC5mbigpLFxuICB1cGRhdGU6IGplc3QuZm4oKSxcbiAgZGVsZXRlOiBqZXN0LmZuKCksXG4gIHRyYW5zYWN0aW9uOiBqZXN0LmZuKCksXG59O1xuXG5qZXN0Lm1vY2soJ0AvbGliL2RiJywgKCkgPT4gKHtcbiAgZGI6IG1vY2tEYixcbn0pKTtcblxuZGVzY3JpYmUoJ0VtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UnLCAoKSA9PiB7XG4gIGxldCBzZXJ2aWNlOiBFbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlO1xuICBjb25zdCBtb2NrVXNlcklkID0gMTtcbiAgY29uc3QgbW9ja0VtYWlsID0gJ3Rlc3RAZXhhbXBsZS5jb20nO1xuICBjb25zdCBtb2NrQ29kZSA9ICcxMjM0NTYnO1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIHNlcnZpY2UgPSBuZXcgRW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZSgpO1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICB9KTtcblxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIGplc3QucmVzdG9yZUFsbE1vY2tzKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdnZW5lcmF0ZUNvZGUnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBnZW5lcmF0ZSBhIDYtZGlnaXQgY29kZScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgZGVsZXRlVXNlckNvZGVzIHRvIHJlc29sdmVcbiAgICAgIGNvbnN0IGRlbGV0ZVVzZXJDb2Rlc1NweSA9IGplc3Quc3B5T24oc2VydmljZSwgJ2RlbGV0ZVVzZXJDb2RlcycpLm1vY2tSZXNvbHZlZFZhbHVlKCk7XG4gICAgICBcbiAgICAgIC8vIE1vY2sgaW5zZXJ0IGNoYWluXG4gICAgICBjb25zdCBtb2NrVmFsdWVzID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XG4gICAgICBtb2NrRGIuaW5zZXJ0Lm1vY2tSZXR1cm5WYWx1ZSh7IHZhbHVlczogbW9ja1ZhbHVlcyB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgY29kZSA9IGF3YWl0IHNlcnZpY2UuZ2VuZXJhdGVDb2RlKG1vY2tVc2VySWQpO1xuICAgICAgXG4gICAgICBleHBlY3QoY29kZSkudG9NYXRjaCgvXlxcZHs2fSQvKTtcbiAgICAgIGV4cGVjdChkZWxldGVVc2VyQ29kZXNTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKG1vY2tVc2VySWQpO1xuICAgICAgZXhwZWN0KG1vY2tEYi5pbnNlcnQpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIGV4cGVjdChtb2NrVmFsdWVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIHVzZXJJZDogbW9ja1VzZXJJZCxcbiAgICAgICAgICBjb2RlOiBleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL15cXGR7Nn0kLyksXG4gICAgICAgICAgZXhwaXJlc0F0OiBleHBlY3QuYW55KERhdGUpLFxuICAgICAgICAgIGF0dGVtcHRzVXNlZDogMCxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGRlbGV0ZSBleGlzdGluZyBjb2RlcyBiZWZvcmUgZ2VuZXJhdGluZyBuZXcgb25lJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZGVsZXRlVXNlckNvZGVzU3B5ID0gamVzdC5zcHlPbihzZXJ2aWNlLCAnZGVsZXRlVXNlckNvZGVzJykubW9ja1Jlc29sdmVkVmFsdWUoKTtcbiAgICAgIGNvbnN0IG1vY2tWYWx1ZXMgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcbiAgICAgIG1vY2tEYi5pbnNlcnQubW9ja1JldHVyblZhbHVlKHsgdmFsdWVzOiBtb2NrVmFsdWVzIH0pO1xuICAgICAgXG4gICAgICBhd2FpdCBzZXJ2aWNlLmdlbmVyYXRlQ29kZShtb2NrVXNlcklkKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGRlbGV0ZVVzZXJDb2Rlc1NweSkudG9IYXZlQmVlbkNhbGxlZFdpdGgobW9ja1VzZXJJZCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHN0b3JlIGNvZGUgd2l0aCBjb3JyZWN0IGV4cGlyYXRpb24gdGltZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGplc3Quc3B5T24oc2VydmljZSwgJ2RlbGV0ZVVzZXJDb2RlcycpLm1vY2tSZXNvbHZlZFZhbHVlKCk7XG4gICAgICBjb25zdCBtb2NrVmFsdWVzID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XG4gICAgICBtb2NrRGIuaW5zZXJ0Lm1vY2tSZXR1cm5WYWx1ZSh7IHZhbHVlczogbW9ja1ZhbHVlcyB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgYmVmb3JlVGltZSA9IERhdGUubm93KCk7XG4gICAgICBhd2FpdCBzZXJ2aWNlLmdlbmVyYXRlQ29kZShtb2NrVXNlcklkKTtcbiAgICAgIGNvbnN0IGFmdGVyVGltZSA9IERhdGUubm93KCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChtb2NrVmFsdWVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIHVzZXJJZDogbW9ja1VzZXJJZCxcbiAgICAgICAgICBjb2RlOiBleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL15cXGR7Nn0kLyksXG4gICAgICAgICAgZXhwaXJlc0F0OiBleHBlY3QuYW55KERhdGUpLFxuICAgICAgICAgIGF0dGVtcHRzVXNlZDogMCxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIHRoYXQgZXhwaXJhdGlvbiBpcyBhcHByb3hpbWF0ZWx5IDEwIG1pbnV0ZXMgZnJvbSBub3dcbiAgICAgIGNvbnN0IGNhbGxBcmdzID0gbW9ja1ZhbHVlcy5tb2NrLmNhbGxzWzBdWzBdO1xuICAgICAgY29uc3QgZXhwaXJhdGlvblRpbWUgPSBjYWxsQXJncy5leHBpcmVzQXQuZ2V0VGltZSgpO1xuICAgICAgY29uc3QgZXhwZWN0ZWRNaW4gPSBiZWZvcmVUaW1lICsgOS41ICogNjAgKiAxMDAwOyAvLyA5LjUgbWludXRlc1xuICAgICAgY29uc3QgZXhwZWN0ZWRNYXggPSBhZnRlclRpbWUgKyAxMC41ICogNjAgKiAxMDAwOyAvLyAxMC41IG1pbnV0ZXNcbiAgICAgIFxuICAgICAgZXhwZWN0KGV4cGlyYXRpb25UaW1lKS50b0JlR3JlYXRlclRoYW4oZXhwZWN0ZWRNaW4pO1xuICAgICAgZXhwZWN0KGV4cGlyYXRpb25UaW1lKS50b0JlTGVzc1RoYW4oZXhwZWN0ZWRNYXgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgndmFsaWRhdGVDb2RlJywgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tVc2VyID0geyBpZDogbW9ja1VzZXJJZCwgaXNFbWFpbFZlcmlmaWVkOiBmYWxzZSB9O1xuICAgIGNvbnN0IG1vY2tWZXJpZmljYXRpb25Db2RlID0ge1xuICAgICAgaWQ6IDEsXG4gICAgICB1c2VySWQ6IG1vY2tVc2VySWQsXG4gICAgICBjb2RlOiBtb2NrQ29kZSxcbiAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIDUgKiA2MCAqIDEwMDApLCAvLyA1IG1pbnV0ZXMgZnJvbSBub3dcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgIGF0dGVtcHRzVXNlZDogMCxcbiAgICB9O1xuXG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSBjb3JyZWN0IGNvZGUgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayB1c2VyIGxvb2t1cFxuICAgICAgY29uc3QgbW9ja1VzZXJMaW1pdCA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShbbW9ja1VzZXJdKTtcbiAgICAgIGNvbnN0IG1vY2tVc2VyV2hlcmUgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgbGltaXQ6IG1vY2tVc2VyTGltaXQgfSk7XG4gICAgICBjb25zdCBtb2NrVXNlckZyb20gPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgd2hlcmU6IG1vY2tVc2VyV2hlcmUgfSk7XG4gICAgICBtb2NrRGIuc2VsZWN0Lm1vY2tSZXR1cm5WYWx1ZU9uY2UoeyBmcm9tOiBtb2NrVXNlckZyb20gfSk7XG5cbiAgICAgIC8vIE1vY2sgdmVyaWZpY2F0aW9uIGNvZGUgbG9va3VwXG4gICAgICBjb25zdCBtb2NrQ29kZUxpbWl0ID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKFttb2NrVmVyaWZpY2F0aW9uQ29kZV0pO1xuICAgICAgY29uc3QgbW9ja0NvZGVXaGVyZSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBsaW1pdDogbW9ja0NvZGVMaW1pdCB9KTtcbiAgICAgIGNvbnN0IG1vY2tDb2RlRnJvbSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyB3aGVyZTogbW9ja0NvZGVXaGVyZSB9KTtcbiAgICAgIG1vY2tEYi5zZWxlY3QubW9ja1JldHVyblZhbHVlT25jZSh7IGZyb206IG1vY2tDb2RlRnJvbSB9KTtcblxuICAgICAgLy8gTW9jayB0cmFuc2FjdGlvblxuICAgICAgY29uc3QgbW9ja1R4ID0ge1xuICAgICAgICB1cGRhdGU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIHNldDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICB3aGVyZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCksXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pLFxuICAgICAgICBkZWxldGU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIHdoZXJlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKSxcbiAgICAgICAgfSksXG4gICAgICB9O1xuICAgICAgbW9ja0RiLnRyYW5zYWN0aW9uLm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAoY2FsbGJhY2spID0+IGNhbGxiYWNrKG1vY2tUeCkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXJ2aWNlLnZhbGlkYXRlQ29kZShtb2NrRW1haWwsIG1vY2tDb2RlKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChtb2NrRGIudHJhbnNhY3Rpb24pLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgVVNFUl9OT1RfRk9VTkQgd2hlbiB1c2VyIGRvZXMgbm90IGV4aXN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayB1c2VyIGxvb2t1cCB0byByZXR1cm4gZW1wdHkgYXJyYXlcbiAgICAgIGNvbnN0IG1vY2tVc2VyTGltaXQgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoW10pO1xuICAgICAgY29uc3QgbW9ja1VzZXJXaGVyZSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBsaW1pdDogbW9ja1VzZXJMaW1pdCB9KTtcbiAgICAgIGNvbnN0IG1vY2tVc2VyRnJvbSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyB3aGVyZTogbW9ja1VzZXJXaGVyZSB9KTtcbiAgICAgIG1vY2tEYi5zZWxlY3QubW9ja1JldHVyblZhbHVlT25jZSh7IGZyb206IG1vY2tVc2VyRnJvbSB9KTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHNlcnZpY2UudmFsaWRhdGVDb2RlKG1vY2tFbWFpbCwgbW9ja0NvZGUpKVxuICAgICAgICAucmVqZWN0c1xuICAgICAgICAudG9UaHJvdyhuZXcgVmVyaWZpY2F0aW9uQ29kZUVycm9yKCdVc2VyIG5vdCBmb3VuZCcsIFZlcmlmaWNhdGlvbkVycm9yLlVTRVJfTk9UX0ZPVU5EKSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHRocm93IEFMUkVBRFlfVkVSSUZJRUQgd2hlbiB1c2VyIGlzIGFscmVhZHkgdmVyaWZpZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIHVzZXIgbG9va3VwIHRvIHJldHVybiB2ZXJpZmllZCB1c2VyXG4gICAgICBjb25zdCBtb2NrVXNlckxpbWl0ID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKFt7IC4uLm1vY2tVc2VyLCBpc0VtYWlsVmVyaWZpZWQ6IHRydWUgfV0pO1xuICAgICAgY29uc3QgbW9ja1VzZXJXaGVyZSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBsaW1pdDogbW9ja1VzZXJMaW1pdCB9KTtcbiAgICAgIGNvbnN0IG1vY2tVc2VyRnJvbSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyB3aGVyZTogbW9ja1VzZXJXaGVyZSB9KTtcbiAgICAgIG1vY2tEYi5zZWxlY3QubW9ja1JldHVyblZhbHVlT25jZSh7IGZyb206IG1vY2tVc2VyRnJvbSB9KTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHNlcnZpY2UudmFsaWRhdGVDb2RlKG1vY2tFbWFpbCwgbW9ja0NvZGUpKVxuICAgICAgICAucmVqZWN0c1xuICAgICAgICAudG9UaHJvdyhuZXcgVmVyaWZpY2F0aW9uQ29kZUVycm9yKCdFbWFpbCBhbHJlYWR5IHZlcmlmaWVkJywgVmVyaWZpY2F0aW9uRXJyb3IuQUxSRUFEWV9WRVJJRklFRCkpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBDT0RFX0lOVkFMSUQgd2hlbiBjb2RlIGRvZXMgbm90IGV4aXN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayB1c2VyIGxvb2t1cFxuICAgICAgY29uc3QgbW9ja1VzZXJMaW1pdCA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShbbW9ja1VzZXJdKTtcbiAgICAgIGNvbnN0IG1vY2tVc2VyV2hlcmUgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgbGltaXQ6IG1vY2tVc2VyTGltaXQgfSk7XG4gICAgICBjb25zdCBtb2NrVXNlckZyb20gPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgd2hlcmU6IG1vY2tVc2VyV2hlcmUgfSk7XG4gICAgICBtb2NrRGIuc2VsZWN0Lm1vY2tSZXR1cm5WYWx1ZU9uY2UoeyBmcm9tOiBtb2NrVXNlckZyb20gfSk7XG5cbiAgICAgIC8vIE1vY2sgdmVyaWZpY2F0aW9uIGNvZGUgbG9va3VwIHRvIHJldHVybiBlbXB0eSBhcnJheVxuICAgICAgY29uc3QgbW9ja0NvZGVMaW1pdCA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShbXSk7XG4gICAgICBjb25zdCBtb2NrQ29kZVdoZXJlID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGxpbWl0OiBtb2NrQ29kZUxpbWl0IH0pO1xuICAgICAgY29uc3QgbW9ja0NvZGVGcm9tID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHdoZXJlOiBtb2NrQ29kZVdoZXJlIH0pO1xuICAgICAgbW9ja0RiLnNlbGVjdC5tb2NrUmV0dXJuVmFsdWVPbmNlKHsgZnJvbTogbW9ja0NvZGVGcm9tIH0pO1xuXG4gICAgICBhd2FpdCBleHBlY3Qoc2VydmljZS52YWxpZGF0ZUNvZGUobW9ja0VtYWlsLCBtb2NrQ29kZSkpXG4gICAgICAgIC5yZWplY3RzXG4gICAgICAgIC50b1Rocm93KG5ldyBWZXJpZmljYXRpb25Db2RlRXJyb3IoJ0ludmFsaWQgdmVyaWZpY2F0aW9uIGNvZGUnLCBWZXJpZmljYXRpb25FcnJvci5DT0RFX0lOVkFMSUQpKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgQ09ERV9FWFBJUkVEIHdoZW4gY29kZSBoYXMgZXhwaXJlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGV4cGlyZWRDb2RlID0ge1xuICAgICAgICAuLi5tb2NrVmVyaWZpY2F0aW9uQ29kZSxcbiAgICAgICAgZXhwaXJlc0F0OiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gNSAqIDYwICogMTAwMCksIC8vIDUgbWludXRlcyBhZ29cbiAgICAgIH07XG5cbiAgICAgIC8vIE1vY2sgdXNlciBsb29rdXBcbiAgICAgIGNvbnN0IG1vY2tVc2VyTGltaXQgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoW21vY2tVc2VyXSk7XG4gICAgICBjb25zdCBtb2NrVXNlcldoZXJlID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGxpbWl0OiBtb2NrVXNlckxpbWl0IH0pO1xuICAgICAgY29uc3QgbW9ja1VzZXJGcm9tID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHdoZXJlOiBtb2NrVXNlcldoZXJlIH0pO1xuICAgICAgbW9ja0RiLnNlbGVjdC5tb2NrUmV0dXJuVmFsdWVPbmNlKHsgZnJvbTogbW9ja1VzZXJGcm9tIH0pO1xuXG4gICAgICAvLyBNb2NrIHZlcmlmaWNhdGlvbiBjb2RlIGxvb2t1cFxuICAgICAgY29uc3QgbW9ja0NvZGVMaW1pdCA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShbZXhwaXJlZENvZGVdKTtcbiAgICAgIGNvbnN0IG1vY2tDb2RlV2hlcmUgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgbGltaXQ6IG1vY2tDb2RlTGltaXQgfSk7XG4gICAgICBjb25zdCBtb2NrQ29kZUZyb20gPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgd2hlcmU6IG1vY2tDb2RlV2hlcmUgfSk7XG4gICAgICBtb2NrRGIuc2VsZWN0Lm1vY2tSZXR1cm5WYWx1ZU9uY2UoeyBmcm9tOiBtb2NrQ29kZUZyb20gfSk7XG5cbiAgICAgIC8vIE1vY2sgZGVsZXRlIGZvciBleHBpcmVkIGNvZGUgY2xlYW51cFxuICAgICAgY29uc3QgbW9ja0RlbGV0ZVdoZXJlID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XG4gICAgICBtb2NrRGIuZGVsZXRlLm1vY2tSZXR1cm5WYWx1ZSh7IHdoZXJlOiBtb2NrRGVsZXRlV2hlcmUgfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChzZXJ2aWNlLnZhbGlkYXRlQ29kZShtb2NrRW1haWwsIG1vY2tDb2RlKSlcbiAgICAgICAgLnJlamVjdHNcbiAgICAgICAgLnRvVGhyb3cobmV3IFZlcmlmaWNhdGlvbkNvZGVFcnJvcignVmVyaWZpY2F0aW9uIGNvZGUgaGFzIGV4cGlyZWQnLCBWZXJpZmljYXRpb25FcnJvci5DT0RFX0VYUElSRUQpKTtcblxuICAgICAgZXhwZWN0KG1vY2tEYi5kZWxldGUpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgVE9PX01BTllfQVRURU1QVFMgd2hlbiBtYXggYXR0ZW1wdHMgZXhjZWVkZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtYXhBdHRlbXB0c0NvZGUgPSB7XG4gICAgICAgIC4uLm1vY2tWZXJpZmljYXRpb25Db2RlLFxuICAgICAgICBhdHRlbXB0c1VzZWQ6IDUsIC8vIE1heCBhdHRlbXB0c1xuICAgICAgfTtcblxuICAgICAgLy8gTW9jayB1c2VyIGxvb2t1cFxuICAgICAgY29uc3QgbW9ja1VzZXJMaW1pdCA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShbbW9ja1VzZXJdKTtcbiAgICAgIGNvbnN0IG1vY2tVc2VyV2hlcmUgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgbGltaXQ6IG1vY2tVc2VyTGltaXQgfSk7XG4gICAgICBjb25zdCBtb2NrVXNlckZyb20gPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgd2hlcmU6IG1vY2tVc2VyV2hlcmUgfSk7XG4gICAgICBtb2NrRGIuc2VsZWN0Lm1vY2tSZXR1cm5WYWx1ZU9uY2UoeyBmcm9tOiBtb2NrVXNlckZyb20gfSk7XG5cbiAgICAgIC8vIE1vY2sgdmVyaWZpY2F0aW9uIGNvZGUgbG9va3VwXG4gICAgICBjb25zdCBtb2NrQ29kZUxpbWl0ID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKFttYXhBdHRlbXB0c0NvZGVdKTtcbiAgICAgIGNvbnN0IG1vY2tDb2RlV2hlcmUgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgbGltaXQ6IG1vY2tDb2RlTGltaXQgfSk7XG4gICAgICBjb25zdCBtb2NrQ29kZUZyb20gPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgd2hlcmU6IG1vY2tDb2RlV2hlcmUgfSk7XG4gICAgICBtb2NrRGIuc2VsZWN0Lm1vY2tSZXR1cm5WYWx1ZU9uY2UoeyBmcm9tOiBtb2NrQ29kZUZyb20gfSk7XG5cbiAgICAgIC8vIE1vY2sgZGVsZXRlIGZvciBjb2RlIGludmFsaWRhdGlvblxuICAgICAgY29uc3QgbW9ja0RlbGV0ZVdoZXJlID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XG4gICAgICBtb2NrRGIuZGVsZXRlLm1vY2tSZXR1cm5WYWx1ZSh7IHdoZXJlOiBtb2NrRGVsZXRlV2hlcmUgfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChzZXJ2aWNlLnZhbGlkYXRlQ29kZShtb2NrRW1haWwsIG1vY2tDb2RlKSlcbiAgICAgICAgLnJlamVjdHNcbiAgICAgICAgLnRvVGhyb3cobmV3IFZlcmlmaWNhdGlvbkNvZGVFcnJvcignVG9vIG1hbnkgdmVyaWZpY2F0aW9uIGF0dGVtcHRzJywgVmVyaWZpY2F0aW9uRXJyb3IuVE9PX01BTllfQVRURU1QVFMpKTtcblxuICAgICAgZXhwZWN0KG1vY2tEYi5kZWxldGUpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2luY3JlbWVudEF0dGVtcHRzJywgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tVc2VyID0geyBpZDogbW9ja1VzZXJJZCB9O1xuICAgIGNvbnN0IG1vY2tWZXJpZmljYXRpb25Db2RlID0geyBpZDogMSwgYXR0ZW1wdHNVc2VkOiAyIH07XG5cbiAgICBpdCgnc2hvdWxkIGluY3JlbWVudCBhdHRlbXB0cyBmb3IgdmFsaWQgY29kZScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgdXNlciBsb29rdXBcbiAgICAgIGNvbnN0IG1vY2tVc2VyTGltaXQgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoW21vY2tVc2VyXSk7XG4gICAgICBjb25zdCBtb2NrVXNlcldoZXJlID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGxpbWl0OiBtb2NrVXNlckxpbWl0IH0pO1xuICAgICAgY29uc3QgbW9ja1VzZXJGcm9tID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHdoZXJlOiBtb2NrVXNlcldoZXJlIH0pO1xuICAgICAgbW9ja0RiLnNlbGVjdC5tb2NrUmV0dXJuVmFsdWVPbmNlKHsgZnJvbTogbW9ja1VzZXJGcm9tIH0pO1xuXG4gICAgICAvLyBNb2NrIHZlcmlmaWNhdGlvbiBjb2RlIGxvb2t1cFxuICAgICAgY29uc3QgbW9ja0NvZGVMaW1pdCA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShbbW9ja1ZlcmlmaWNhdGlvbkNvZGVdKTtcbiAgICAgIGNvbnN0IG1vY2tDb2RlV2hlcmUgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgbGltaXQ6IG1vY2tDb2RlTGltaXQgfSk7XG4gICAgICBjb25zdCBtb2NrQ29kZUZyb20gPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgd2hlcmU6IG1vY2tDb2RlV2hlcmUgfSk7XG4gICAgICBtb2NrRGIuc2VsZWN0Lm1vY2tSZXR1cm5WYWx1ZU9uY2UoeyBmcm9tOiBtb2NrQ29kZUZyb20gfSk7XG5cbiAgICAgIC8vIE1vY2sgdXBkYXRlXG4gICAgICBjb25zdCBtb2NrVXBkYXRlV2hlcmUgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcbiAgICAgIGNvbnN0IG1vY2tVcGRhdGVTZXQgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgd2hlcmU6IG1vY2tVcGRhdGVXaGVyZSB9KTtcbiAgICAgIG1vY2tEYi51cGRhdGUubW9ja1JldHVyblZhbHVlKHsgc2V0OiBtb2NrVXBkYXRlU2V0IH0pO1xuXG4gICAgICBhd2FpdCBzZXJ2aWNlLmluY3JlbWVudEF0dGVtcHRzKG1vY2tFbWFpbCwgbW9ja0NvZGUpO1xuXG4gICAgICBleHBlY3QobW9ja0RiLnVwZGF0ZSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgZXhwZWN0KG1vY2tVcGRhdGVTZXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHsgYXR0ZW1wdHNVc2VkOiAzIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgdXNlciBub3QgZm91bmQgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgdXNlciBsb29rdXAgdG8gcmV0dXJuIGVtcHR5IGFycmF5XG4gICAgICBjb25zdCBtb2NrVXNlckxpbWl0ID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKFtdKTtcbiAgICAgIGNvbnN0IG1vY2tVc2VyV2hlcmUgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgbGltaXQ6IG1vY2tVc2VyTGltaXQgfSk7XG4gICAgICBjb25zdCBtb2NrVXNlckZyb20gPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgd2hlcmU6IG1vY2tVc2VyV2hlcmUgfSk7XG4gICAgICBtb2NrRGIuc2VsZWN0Lm1vY2tSZXR1cm5WYWx1ZU9uY2UoeyBmcm9tOiBtb2NrVXNlckZyb20gfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChzZXJ2aWNlLmluY3JlbWVudEF0dGVtcHRzKG1vY2tFbWFpbCwgbW9ja0NvZGUpKS5yZXNvbHZlcy50b0JlVW5kZWZpbmVkKCk7XG4gICAgICBleHBlY3QobW9ja0RiLnVwZGF0ZSkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNvZGUgbm90IGZvdW5kIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIHVzZXIgbG9va3VwXG4gICAgICBjb25zdCBtb2NrVXNlckxpbWl0ID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKFttb2NrVXNlcl0pO1xuICAgICAgY29uc3QgbW9ja1VzZXJXaGVyZSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBsaW1pdDogbW9ja1VzZXJMaW1pdCB9KTtcbiAgICAgIGNvbnN0IG1vY2tVc2VyRnJvbSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyB3aGVyZTogbW9ja1VzZXJXaGVyZSB9KTtcbiAgICAgIG1vY2tEYi5zZWxlY3QubW9ja1JldHVyblZhbHVlT25jZSh7IGZyb206IG1vY2tVc2VyRnJvbSB9KTtcblxuICAgICAgLy8gTW9jayB2ZXJpZmljYXRpb24gY29kZSBsb29rdXAgdG8gcmV0dXJuIGVtcHR5IGFycmF5XG4gICAgICBjb25zdCBtb2NrQ29kZUxpbWl0ID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKFtdKTtcbiAgICAgIGNvbnN0IG1vY2tDb2RlV2hlcmUgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgbGltaXQ6IG1vY2tDb2RlTGltaXQgfSk7XG4gICAgICBjb25zdCBtb2NrQ29kZUZyb20gPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgd2hlcmU6IG1vY2tDb2RlV2hlcmUgfSk7XG4gICAgICBtb2NrRGIuc2VsZWN0Lm1vY2tSZXR1cm5WYWx1ZU9uY2UoeyBmcm9tOiBtb2NrQ29kZUZyb20gfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChzZXJ2aWNlLmluY3JlbWVudEF0dGVtcHRzKG1vY2tFbWFpbCwgbW9ja0NvZGUpKS5yZXNvbHZlcy50b0JlVW5kZWZpbmVkKCk7XG4gICAgICBleHBlY3QobW9ja0RiLnVwZGF0ZSkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2NsZWFudXBFeHBpcmVkQ29kZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBkZWxldGUgZXhwaXJlZCBjb2RlcyBhbmQgcmV0dXJuIGNvdW50JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0RlbGV0ZVJlc3VsdCA9IHsgcm93Q291bnQ6IDUgfTtcbiAgICAgIGNvbnN0IG1vY2tEZWxldGVXaGVyZSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrRGVsZXRlUmVzdWx0KTtcbiAgICAgIG1vY2tEYi5kZWxldGUubW9ja1JldHVyblZhbHVlKHsgd2hlcmU6IG1vY2tEZWxldGVXaGVyZSB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2VydmljZS5jbGVhbnVwRXhwaXJlZENvZGVzKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoNSk7XG4gICAgICBleHBlY3QobW9ja0RiLmRlbGV0ZSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbWlzc2luZyByb3dDb3VudCBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0RlbGV0ZVJlc3VsdCA9IHt9OyAvLyBObyByb3dDb3VudCBwcm9wZXJ0eVxuICAgICAgY29uc3QgbW9ja0RlbGV0ZVdoZXJlID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tEZWxldGVSZXN1bHQpO1xuICAgICAgbW9ja0RiLmRlbGV0ZS5tb2NrUmV0dXJuVmFsdWUoeyB3aGVyZTogbW9ja0RlbGV0ZVdoZXJlIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXJ2aWNlLmNsZWFudXBFeHBpcmVkQ29kZXMoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSgwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2RlbGV0ZVVzZXJDb2RlcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGRlbGV0ZSBhbGwgY29kZXMgZm9yIGEgdXNlcicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tEZWxldGVXaGVyZSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xuICAgICAgbW9ja0RiLmRlbGV0ZS5tb2NrUmV0dXJuVmFsdWUoeyB3aGVyZTogbW9ja0RlbGV0ZVdoZXJlIH0pO1xuXG4gICAgICBhd2FpdCBzZXJ2aWNlLmRlbGV0ZVVzZXJDb2Rlcyhtb2NrVXNlcklkKTtcblxuICAgICAgZXhwZWN0KG1vY2tEYi5kZWxldGUpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dldFVzZXJBY3RpdmVDb2RlJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIGFjdGl2ZSBjb2RlIGZvciB1c2VyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0FjdGl2ZUNvZGUgPSB7XG4gICAgICAgIGlkOiAxLFxuICAgICAgICB1c2VySWQ6IG1vY2tVc2VySWQsXG4gICAgICAgIGNvZGU6IG1vY2tDb2RlLFxuICAgICAgICBleHBpcmVzQXQ6IG5ldyBEYXRlKERhdGUubm93KCkgKyA1ICogNjAgKiAxMDAwKSxcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICBhdHRlbXB0c1VzZWQ6IDAsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb2NrTGltaXQgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoW21vY2tBY3RpdmVDb2RlXSk7XG4gICAgICBjb25zdCBtb2NrV2hlcmUgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgbGltaXQ6IG1vY2tMaW1pdCB9KTtcbiAgICAgIGNvbnN0IG1vY2tGcm9tID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHdoZXJlOiBtb2NrV2hlcmUgfSk7XG4gICAgICBtb2NrRGIuc2VsZWN0Lm1vY2tSZXR1cm5WYWx1ZSh7IGZyb206IG1vY2tGcm9tIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXJ2aWNlLmdldFVzZXJBY3RpdmVDb2RlKG1vY2tVc2VySWQpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKG1vY2tBY3RpdmVDb2RlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIG51bGwgd2hlbiBubyBhY3RpdmUgY29kZSBleGlzdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrTGltaXQgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoW10pO1xuICAgICAgY29uc3QgbW9ja1doZXJlID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGxpbWl0OiBtb2NrTGltaXQgfSk7XG4gICAgICBjb25zdCBtb2NrRnJvbSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyB3aGVyZTogbW9ja1doZXJlIH0pO1xuICAgICAgbW9ja0RiLnNlbGVjdC5tb2NrUmV0dXJuVmFsdWUoeyBmcm9tOiBtb2NrRnJvbSB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2VydmljZS5nZXRVc2VyQWN0aXZlQ29kZShtb2NrVXNlcklkKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2hhc0FjdGl2ZUNvZGUnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gdHJ1ZSB3aGVuIHVzZXIgaGFzIGFjdGl2ZSBjb2RlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgamVzdC5zcHlPbihzZXJ2aWNlLCAnZ2V0VXNlckFjdGl2ZUNvZGUnKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGlkOiAxLFxuICAgICAgICB1c2VySWQ6IG1vY2tVc2VySWQsXG4gICAgICAgIGNvZGU6IG1vY2tDb2RlLFxuICAgICAgICBleHBpcmVzQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgYXR0ZW1wdHNVc2VkOiAwLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlcnZpY2UuaGFzQWN0aXZlQ29kZShtb2NrVXNlcklkKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhbHNlIHdoZW4gdXNlciBoYXMgbm8gYWN0aXZlIGNvZGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBqZXN0LnNweU9uKHNlcnZpY2UsICdnZXRVc2VyQWN0aXZlQ29kZScpLm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXJ2aWNlLmhhc0FjdGl2ZUNvZGUobW9ja1VzZXJJZCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0Q29kZVN0YXRzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIGNvZGUgc3RhdGlzdGljcycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgdGhlIHRocmVlIHNlbGVjdCBxdWVyaWVzIGZvciBzdGF0c1xuICAgICAgY29uc3QgbW9ja0Zyb20xID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHdoZXJlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoWzEsIDIsIDNdKSwgLy8gMyBhY3RpdmUgY29kZXNcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbW9ja0Zyb20yID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHdoZXJlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoWzEsIDJdKSwgLy8gMiBleHBpcmVkIGNvZGVzXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG1vY2tGcm9tMyA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICB3aGVyZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKFsxXSksIC8vIDEgaGlnaCBhdHRlbXB0IGNvZGVcbiAgICAgIH0pO1xuXG4gICAgICBtb2NrRGIuc2VsZWN0XG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKHsgZnJvbTogbW9ja0Zyb20xIH0pXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKHsgZnJvbTogbW9ja0Zyb20yIH0pXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKHsgZnJvbTogbW9ja0Zyb20zIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXJ2aWNlLmdldENvZGVTdGF0cygpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHtcbiAgICAgICAgdG90YWxBY3RpdmU6IDMsXG4gICAgICAgIGV4cGlyZWRDb3VudDogMixcbiAgICAgICAgaGlnaEF0dGVtcHRDb3VudDogMSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnY29kZSBnZW5lcmF0aW9uIHNlY3VyaXR5JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZ2VuZXJhdGUgdW5pcXVlIGNvZGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgamVzdC5zcHlPbihzZXJ2aWNlLCAnZGVsZXRlVXNlckNvZGVzJykubW9ja1Jlc29sdmVkVmFsdWUoKTtcbiAgICAgIGNvbnN0IG1vY2tWYWx1ZXMgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcbiAgICAgIG1vY2tEYi5pbnNlcnQubW9ja1JldHVyblZhbHVlKHsgdmFsdWVzOiBtb2NrVmFsdWVzIH0pO1xuICAgICAgXG4gICAgICBjb25zdCBjb2RlcyA9IG5ldyBTZXQoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwOyBpKyspIHtcbiAgICAgICAgY29uc3QgY29kZSA9IGF3YWl0IHNlcnZpY2UuZ2VuZXJhdGVDb2RlKG1vY2tVc2VySWQpO1xuICAgICAgICBjb2Rlcy5hZGQoY29kZSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBoYXZlIGdlbmVyYXRlZCAxMDAgdW5pcXVlIGNvZGVzICh2ZXJ5IGhpZ2ggcHJvYmFiaWxpdHkpXG4gICAgICBleHBlY3QoY29kZXMuc2l6ZSkudG9CZUdyZWF0ZXJUaGFuKDk1KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYWx3YXlzIGdlbmVyYXRlIDYtZGlnaXQgY29kZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBqZXN0LnNweU9uKHNlcnZpY2UsICdkZWxldGVVc2VyQ29kZXMnKS5tb2NrUmVzb2x2ZWRWYWx1ZSgpO1xuICAgICAgY29uc3QgbW9ja1ZhbHVlcyA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xuICAgICAgbW9ja0RiLmluc2VydC5tb2NrUmV0dXJuVmFsdWUoeyB2YWx1ZXM6IG1vY2tWYWx1ZXMgfSk7XG4gICAgICBcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTA7IGkrKykge1xuICAgICAgICBjb25zdCBjb2RlID0gYXdhaXQgc2VydmljZS5nZW5lcmF0ZUNvZGUobW9ja1VzZXJJZCk7XG4gICAgICAgIGV4cGVjdChjb2RlKS50b01hdGNoKC9eXFxkezZ9JC8pO1xuICAgICAgICBleHBlY3QoY29kZS5sZW5ndGgpLnRvQmUoNik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHBhZCBjb2RlcyB3aXRoIGxlYWRpbmcgemVyb3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICBqZXN0LnNweU9uKHNlcnZpY2UsICdkZWxldGVVc2VyQ29kZXMnKS5tb2NrUmVzb2x2ZWRWYWx1ZSgpO1xuICAgICAgY29uc3QgbW9ja1ZhbHVlcyA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xuICAgICAgbW9ja0RiLmluc2VydC5tb2NrUmV0dXJuVmFsdWUoeyB2YWx1ZXM6IG1vY2tWYWx1ZXMgfSk7XG4gICAgICBcbiAgICAgIC8vIE1vY2sgY3J5cHRvLnJhbmRvbUJ5dGVzIHRvIHJldHVybiBhIHNtYWxsIG51bWJlclxuICAgICAgY29uc3Qgb3JpZ2luYWxSYW5kb21CeXRlcyA9IHJlcXVpcmUoJ2NyeXB0bycpLnJhbmRvbUJ5dGVzO1xuICAgICAgY29uc3QgbW9ja1JhbmRvbUJ5dGVzID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShCdWZmZXIuZnJvbShbMCwgMCwgMCwgMV0pKTsgLy8gVmVyeSBzbWFsbCBudW1iZXJcbiAgICAgIHJlcXVpcmUoJ2NyeXB0bycpLnJhbmRvbUJ5dGVzID0gbW9ja1JhbmRvbUJ5dGVzO1xuICAgICAgXG4gICAgICBjb25zdCBjb2RlID0gYXdhaXQgc2VydmljZS5nZW5lcmF0ZUNvZGUobW9ja1VzZXJJZCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChjb2RlKS50b01hdGNoKC9eXFxkezZ9JC8pO1xuICAgICAgZXhwZWN0KGNvZGUubGVuZ3RoKS50b0JlKDYpO1xuICAgICAgXG4gICAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIGZ1bmN0aW9uXG4gICAgICByZXF1aXJlKCdjcnlwdG8nKS5yYW5kb21CeXRlcyA9IG9yaWdpbmFsUmFuZG9tQnl0ZXM7XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sIm5hbWVzIjpbIm1vY2tEYiIsImluc2VydCIsImplc3QiLCJmbiIsInNlbGVjdCIsInVwZGF0ZSIsImRlbGV0ZSIsInRyYW5zYWN0aW9uIiwibW9jayIsImRiIiwiZGVzY3JpYmUiLCJzZXJ2aWNlIiwibW9ja1VzZXJJZCIsIm1vY2tFbWFpbCIsIm1vY2tDb2RlIiwiYmVmb3JlRWFjaCIsIkVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UiLCJjbGVhckFsbE1vY2tzIiwiYWZ0ZXJFYWNoIiwicmVzdG9yZUFsbE1vY2tzIiwiaXQiLCJkZWxldGVVc2VyQ29kZXNTcHkiLCJzcHlPbiIsIm1vY2tSZXNvbHZlZFZhbHVlIiwibW9ja1ZhbHVlcyIsInVuZGVmaW5lZCIsIm1vY2tSZXR1cm5WYWx1ZSIsInZhbHVlcyIsImNvZGUiLCJnZW5lcmF0ZUNvZGUiLCJleHBlY3QiLCJ0b01hdGNoIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJ0b0hhdmVCZWVuQ2FsbGVkIiwib2JqZWN0Q29udGFpbmluZyIsInVzZXJJZCIsInN0cmluZ01hdGNoaW5nIiwiZXhwaXJlc0F0IiwiYW55IiwiRGF0ZSIsImF0dGVtcHRzVXNlZCIsImJlZm9yZVRpbWUiLCJub3ciLCJhZnRlclRpbWUiLCJjYWxsQXJncyIsImNhbGxzIiwiZXhwaXJhdGlvblRpbWUiLCJnZXRUaW1lIiwiZXhwZWN0ZWRNaW4iLCJleHBlY3RlZE1heCIsInRvQmVHcmVhdGVyVGhhbiIsInRvQmVMZXNzVGhhbiIsIm1vY2tVc2VyIiwiaWQiLCJpc0VtYWlsVmVyaWZpZWQiLCJtb2NrVmVyaWZpY2F0aW9uQ29kZSIsImNyZWF0ZWRBdCIsIm1vY2tVc2VyTGltaXQiLCJtb2NrVXNlcldoZXJlIiwibGltaXQiLCJtb2NrVXNlckZyb20iLCJ3aGVyZSIsIm1vY2tSZXR1cm5WYWx1ZU9uY2UiLCJmcm9tIiwibW9ja0NvZGVMaW1pdCIsIm1vY2tDb2RlV2hlcmUiLCJtb2NrQ29kZUZyb20iLCJtb2NrVHgiLCJzZXQiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJjYWxsYmFjayIsInJlc3VsdCIsInZhbGlkYXRlQ29kZSIsInRvQmUiLCJyZWplY3RzIiwidG9UaHJvdyIsIlZlcmlmaWNhdGlvbkNvZGVFcnJvciIsIlZlcmlmaWNhdGlvbkVycm9yIiwiVVNFUl9OT1RfRk9VTkQiLCJBTFJFQURZX1ZFUklGSUVEIiwiQ09ERV9JTlZBTElEIiwiZXhwaXJlZENvZGUiLCJtb2NrRGVsZXRlV2hlcmUiLCJDT0RFX0VYUElSRUQiLCJtYXhBdHRlbXB0c0NvZGUiLCJUT09fTUFOWV9BVFRFTVBUUyIsIm1vY2tVcGRhdGVXaGVyZSIsIm1vY2tVcGRhdGVTZXQiLCJpbmNyZW1lbnRBdHRlbXB0cyIsInJlc29sdmVzIiwidG9CZVVuZGVmaW5lZCIsIm5vdCIsIm1vY2tEZWxldGVSZXN1bHQiLCJyb3dDb3VudCIsImNsZWFudXBFeHBpcmVkQ29kZXMiLCJkZWxldGVVc2VyQ29kZXMiLCJtb2NrQWN0aXZlQ29kZSIsIm1vY2tMaW1pdCIsIm1vY2tXaGVyZSIsIm1vY2tGcm9tIiwiZ2V0VXNlckFjdGl2ZUNvZGUiLCJ0b0VxdWFsIiwidG9CZU51bGwiLCJoYXNBY3RpdmVDb2RlIiwibW9ja0Zyb20xIiwibW9ja0Zyb20yIiwibW9ja0Zyb20zIiwiZ2V0Q29kZVN0YXRzIiwidG90YWxBY3RpdmUiLCJleHBpcmVkQ291bnQiLCJoaWdoQXR0ZW1wdENvdW50IiwiY29kZXMiLCJTZXQiLCJpIiwiYWRkIiwic2l6ZSIsImxlbmd0aCIsIm9yaWdpbmFsUmFuZG9tQnl0ZXMiLCJyZXF1aXJlIiwicmFuZG9tQnl0ZXMiLCJtb2NrUmFuZG9tQnl0ZXMiLCJCdWZmZXIiXSwibWFwcGluZ3MiOiI7Ozs7eUJBQWtFOzhDQUNxQjtBQUV2RixvQkFBb0I7QUFDcEIsTUFBTUEsU0FBUztJQUNiQyxRQUFRQyxhQUFJLENBQUNDLEVBQUU7SUFDZkMsUUFBUUYsYUFBSSxDQUFDQyxFQUFFO0lBQ2ZFLFFBQVFILGFBQUksQ0FBQ0MsRUFBRTtJQUNmRyxRQUFRSixhQUFJLENBQUNDLEVBQUU7SUFDZkksYUFBYUwsYUFBSSxDQUFDQyxFQUFFO0FBQ3RCO0FBRUFELGFBQUksQ0FBQ00sSUFBSSxDQUFDLFlBQVksSUFBTyxDQUFBO1FBQzNCQyxJQUFJVDtJQUNOLENBQUE7QUFFQVUsSUFBQUEsaUJBQVEsRUFBQyxnQ0FBZ0M7SUFDdkMsSUFBSUM7SUFDSixNQUFNQyxhQUFhO0lBQ25CLE1BQU1DLFlBQVk7SUFDbEIsTUFBTUMsV0FBVztJQUVqQkMsSUFBQUEsbUJBQVUsRUFBQztRQUNUSixVQUFVLElBQUlLLDBEQUE0QjtRQUMxQ2QsYUFBSSxDQUFDZSxhQUFhO0lBQ3BCO0lBRUFDLElBQUFBLGtCQUFTLEVBQUM7UUFDUmhCLGFBQUksQ0FBQ2lCLGVBQWU7SUFDdEI7SUFFQVQsSUFBQUEsaUJBQVEsRUFBQyxnQkFBZ0I7UUFDdkJVLElBQUFBLFdBQUUsRUFBQyxrQ0FBa0M7WUFDbkMsa0NBQWtDO1lBQ2xDLE1BQU1DLHFCQUFxQm5CLGFBQUksQ0FBQ29CLEtBQUssQ0FBQ1gsU0FBUyxtQkFBbUJZLGlCQUFpQjtZQUVuRixvQkFBb0I7WUFDcEIsTUFBTUMsYUFBYXRCLGFBQUksQ0FBQ0MsRUFBRSxHQUFHb0IsaUJBQWlCLENBQUNFO1lBQy9DekIsT0FBT0MsTUFBTSxDQUFDeUIsZUFBZSxDQUFDO2dCQUFFQyxRQUFRSDtZQUFXO1lBRW5ELE1BQU1JLE9BQU8sTUFBTWpCLFFBQVFrQixZQUFZLENBQUNqQjtZQUV4Q2tCLElBQUFBLGVBQU0sRUFBQ0YsTUFBTUcsT0FBTyxDQUFDO1lBQ3JCRCxJQUFBQSxlQUFNLEVBQUNULG9CQUFvQlcsb0JBQW9CLENBQUNwQjtZQUNoRGtCLElBQUFBLGVBQU0sRUFBQzlCLE9BQU9DLE1BQU0sRUFBRWdDLGdCQUFnQjtZQUN0Q0gsSUFBQUEsZUFBTSxFQUFDTixZQUFZUSxvQkFBb0IsQ0FDckNGLGVBQU0sQ0FBQ0ksZ0JBQWdCLENBQUM7Z0JBQ3RCQyxRQUFRdkI7Z0JBQ1JnQixNQUFNRSxlQUFNLENBQUNNLGNBQWMsQ0FBQztnQkFDNUJDLFdBQVdQLGVBQU0sQ0FBQ1EsR0FBRyxDQUFDQztnQkFDdEJDLGNBQWM7WUFDaEI7UUFFSjtRQUVBcEIsSUFBQUEsV0FBRSxFQUFDLDBEQUEwRDtZQUMzRCxNQUFNQyxxQkFBcUJuQixhQUFJLENBQUNvQixLQUFLLENBQUNYLFNBQVMsbUJBQW1CWSxpQkFBaUI7WUFDbkYsTUFBTUMsYUFBYXRCLGFBQUksQ0FBQ0MsRUFBRSxHQUFHb0IsaUJBQWlCLENBQUNFO1lBQy9DekIsT0FBT0MsTUFBTSxDQUFDeUIsZUFBZSxDQUFDO2dCQUFFQyxRQUFRSDtZQUFXO1lBRW5ELE1BQU1iLFFBQVFrQixZQUFZLENBQUNqQjtZQUUzQmtCLElBQUFBLGVBQU0sRUFBQ1Qsb0JBQW9CVyxvQkFBb0IsQ0FBQ3BCO1FBQ2xEO1FBRUFRLElBQUFBLFdBQUUsRUFBQyxrREFBa0Q7WUFDbkRsQixhQUFJLENBQUNvQixLQUFLLENBQUNYLFNBQVMsbUJBQW1CWSxpQkFBaUI7WUFDeEQsTUFBTUMsYUFBYXRCLGFBQUksQ0FBQ0MsRUFBRSxHQUFHb0IsaUJBQWlCLENBQUNFO1lBQy9DekIsT0FBT0MsTUFBTSxDQUFDeUIsZUFBZSxDQUFDO2dCQUFFQyxRQUFRSDtZQUFXO1lBRW5ELE1BQU1pQixhQUFhRixLQUFLRyxHQUFHO1lBQzNCLE1BQU0vQixRQUFRa0IsWUFBWSxDQUFDakI7WUFDM0IsTUFBTStCLFlBQVlKLEtBQUtHLEdBQUc7WUFFMUJaLElBQUFBLGVBQU0sRUFBQ04sWUFBWVEsb0JBQW9CLENBQ3JDRixlQUFNLENBQUNJLGdCQUFnQixDQUFDO2dCQUN0QkMsUUFBUXZCO2dCQUNSZ0IsTUFBTUUsZUFBTSxDQUFDTSxjQUFjLENBQUM7Z0JBQzVCQyxXQUFXUCxlQUFNLENBQUNRLEdBQUcsQ0FBQ0M7Z0JBQ3RCQyxjQUFjO1lBQ2hCO1lBR0YsNkRBQTZEO1lBQzdELE1BQU1JLFdBQVdwQixXQUFXaEIsSUFBSSxDQUFDcUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1lBQzVDLE1BQU1DLGlCQUFpQkYsU0FBU1AsU0FBUyxDQUFDVSxPQUFPO1lBQ2pELE1BQU1DLGNBQWNQLGFBQWEsTUFBTSxLQUFLLE1BQU0sY0FBYztZQUNoRSxNQUFNUSxjQUFjTixZQUFZLE9BQU8sS0FBSyxNQUFNLGVBQWU7WUFFakViLElBQUFBLGVBQU0sRUFBQ2dCLGdCQUFnQkksZUFBZSxDQUFDRjtZQUN2Q2xCLElBQUFBLGVBQU0sRUFBQ2dCLGdCQUFnQkssWUFBWSxDQUFDRjtRQUN0QztJQUNGO0lBRUF2QyxJQUFBQSxpQkFBUSxFQUFDLGdCQUFnQjtRQUN2QixNQUFNMEMsV0FBVztZQUFFQyxJQUFJekM7WUFBWTBDLGlCQUFpQjtRQUFNO1FBQzFELE1BQU1DLHVCQUF1QjtZQUMzQkYsSUFBSTtZQUNKbEIsUUFBUXZCO1lBQ1JnQixNQUFNZDtZQUNOdUIsV0FBVyxJQUFJRSxLQUFLQSxLQUFLRyxHQUFHLEtBQUssSUFBSSxLQUFLO1lBQzFDYyxXQUFXLElBQUlqQjtZQUNmQyxjQUFjO1FBQ2hCO1FBRUFwQixJQUFBQSxXQUFFLEVBQUMsNkNBQTZDO1lBQzlDLG1CQUFtQjtZQUNuQixNQUFNcUMsZ0JBQWdCdkQsYUFBSSxDQUFDQyxFQUFFLEdBQUdvQixpQkFBaUIsQ0FBQztnQkFBQzZCO2FBQVM7WUFDNUQsTUFBTU0sZ0JBQWdCeEQsYUFBSSxDQUFDQyxFQUFFLEdBQUd1QixlQUFlLENBQUM7Z0JBQUVpQyxPQUFPRjtZQUFjO1lBQ3ZFLE1BQU1HLGVBQWUxRCxhQUFJLENBQUNDLEVBQUUsR0FBR3VCLGVBQWUsQ0FBQztnQkFBRW1DLE9BQU9IO1lBQWM7WUFDdEUxRCxPQUFPSSxNQUFNLENBQUMwRCxtQkFBbUIsQ0FBQztnQkFBRUMsTUFBTUg7WUFBYTtZQUV2RCxnQ0FBZ0M7WUFDaEMsTUFBTUksZ0JBQWdCOUQsYUFBSSxDQUFDQyxFQUFFLEdBQUdvQixpQkFBaUIsQ0FBQztnQkFBQ2dDO2FBQXFCO1lBQ3hFLE1BQU1VLGdCQUFnQi9ELGFBQUksQ0FBQ0MsRUFBRSxHQUFHdUIsZUFBZSxDQUFDO2dCQUFFaUMsT0FBT0s7WUFBYztZQUN2RSxNQUFNRSxlQUFlaEUsYUFBSSxDQUFDQyxFQUFFLEdBQUd1QixlQUFlLENBQUM7Z0JBQUVtQyxPQUFPSTtZQUFjO1lBQ3RFakUsT0FBT0ksTUFBTSxDQUFDMEQsbUJBQW1CLENBQUM7Z0JBQUVDLE1BQU1HO1lBQWE7WUFFdkQsbUJBQW1CO1lBQ25CLE1BQU1DLFNBQVM7Z0JBQ2I5RCxRQUFRSCxhQUFJLENBQUNDLEVBQUUsR0FBR3VCLGVBQWUsQ0FBQztvQkFDaEMwQyxLQUFLbEUsYUFBSSxDQUFDQyxFQUFFLEdBQUd1QixlQUFlLENBQUM7d0JBQzdCbUMsT0FBTzNELGFBQUksQ0FBQ0MsRUFBRSxHQUFHb0IsaUJBQWlCLENBQUNFO29CQUNyQztnQkFDRjtnQkFDQW5CLFFBQVFKLGFBQUksQ0FBQ0MsRUFBRSxHQUFHdUIsZUFBZSxDQUFDO29CQUNoQ21DLE9BQU8zRCxhQUFJLENBQUNDLEVBQUUsR0FBR29CLGlCQUFpQixDQUFDRTtnQkFDckM7WUFDRjtZQUNBekIsT0FBT08sV0FBVyxDQUFDOEQsa0JBQWtCLENBQUMsT0FBT0MsV0FBYUEsU0FBU0g7WUFFbkUsTUFBTUksU0FBUyxNQUFNNUQsUUFBUTZELFlBQVksQ0FBQzNELFdBQVdDO1lBRXJEZ0IsSUFBQUEsZUFBTSxFQUFDeUMsUUFBUUUsSUFBSSxDQUFDO1lBQ3BCM0MsSUFBQUEsZUFBTSxFQUFDOUIsT0FBT08sV0FBVyxFQUFFMEIsZ0JBQWdCO1FBQzdDO1FBRUFiLElBQUFBLFdBQUUsRUFBQyx3REFBd0Q7WUFDekQseUNBQXlDO1lBQ3pDLE1BQU1xQyxnQkFBZ0J2RCxhQUFJLENBQUNDLEVBQUUsR0FBR29CLGlCQUFpQixDQUFDLEVBQUU7WUFDcEQsTUFBTW1DLGdCQUFnQnhELGFBQUksQ0FBQ0MsRUFBRSxHQUFHdUIsZUFBZSxDQUFDO2dCQUFFaUMsT0FBT0Y7WUFBYztZQUN2RSxNQUFNRyxlQUFlMUQsYUFBSSxDQUFDQyxFQUFFLEdBQUd1QixlQUFlLENBQUM7Z0JBQUVtQyxPQUFPSDtZQUFjO1lBQ3RFMUQsT0FBT0ksTUFBTSxDQUFDMEQsbUJBQW1CLENBQUM7Z0JBQUVDLE1BQU1IO1lBQWE7WUFFdkQsTUFBTTlCLElBQUFBLGVBQU0sRUFBQ25CLFFBQVE2RCxZQUFZLENBQUMzRCxXQUFXQyxXQUMxQzRELE9BQU8sQ0FDUEMsT0FBTyxDQUFDLElBQUlDLG1EQUFxQixDQUFDLGtCQUFrQkMsK0NBQWlCLENBQUNDLGNBQWM7UUFDekY7UUFFQTFELElBQUFBLFdBQUUsRUFBQywrREFBK0Q7WUFDaEUsMkNBQTJDO1lBQzNDLE1BQU1xQyxnQkFBZ0J2RCxhQUFJLENBQUNDLEVBQUUsR0FBR29CLGlCQUFpQixDQUFDO2dCQUFDO29CQUFFLEdBQUc2QixRQUFRO29CQUFFRSxpQkFBaUI7Z0JBQUs7YUFBRTtZQUMxRixNQUFNSSxnQkFBZ0J4RCxhQUFJLENBQUNDLEVBQUUsR0FBR3VCLGVBQWUsQ0FBQztnQkFBRWlDLE9BQU9GO1lBQWM7WUFDdkUsTUFBTUcsZUFBZTFELGFBQUksQ0FBQ0MsRUFBRSxHQUFHdUIsZUFBZSxDQUFDO2dCQUFFbUMsT0FBT0g7WUFBYztZQUN0RTFELE9BQU9JLE1BQU0sQ0FBQzBELG1CQUFtQixDQUFDO2dCQUFFQyxNQUFNSDtZQUFhO1lBRXZELE1BQU05QixJQUFBQSxlQUFNLEVBQUNuQixRQUFRNkQsWUFBWSxDQUFDM0QsV0FBV0MsV0FDMUM0RCxPQUFPLENBQ1BDLE9BQU8sQ0FBQyxJQUFJQyxtREFBcUIsQ0FBQywwQkFBMEJDLCtDQUFpQixDQUFDRSxnQkFBZ0I7UUFDbkc7UUFFQTNELElBQUFBLFdBQUUsRUFBQyxzREFBc0Q7WUFDdkQsbUJBQW1CO1lBQ25CLE1BQU1xQyxnQkFBZ0J2RCxhQUFJLENBQUNDLEVBQUUsR0FBR29CLGlCQUFpQixDQUFDO2dCQUFDNkI7YUFBUztZQUM1RCxNQUFNTSxnQkFBZ0J4RCxhQUFJLENBQUNDLEVBQUUsR0FBR3VCLGVBQWUsQ0FBQztnQkFBRWlDLE9BQU9GO1lBQWM7WUFDdkUsTUFBTUcsZUFBZTFELGFBQUksQ0FBQ0MsRUFBRSxHQUFHdUIsZUFBZSxDQUFDO2dCQUFFbUMsT0FBT0g7WUFBYztZQUN0RTFELE9BQU9JLE1BQU0sQ0FBQzBELG1CQUFtQixDQUFDO2dCQUFFQyxNQUFNSDtZQUFhO1lBRXZELHNEQUFzRDtZQUN0RCxNQUFNSSxnQkFBZ0I5RCxhQUFJLENBQUNDLEVBQUUsR0FBR29CLGlCQUFpQixDQUFDLEVBQUU7WUFDcEQsTUFBTTBDLGdCQUFnQi9ELGFBQUksQ0FBQ0MsRUFBRSxHQUFHdUIsZUFBZSxDQUFDO2dCQUFFaUMsT0FBT0s7WUFBYztZQUN2RSxNQUFNRSxlQUFlaEUsYUFBSSxDQUFDQyxFQUFFLEdBQUd1QixlQUFlLENBQUM7Z0JBQUVtQyxPQUFPSTtZQUFjO1lBQ3RFakUsT0FBT0ksTUFBTSxDQUFDMEQsbUJBQW1CLENBQUM7Z0JBQUVDLE1BQU1HO1lBQWE7WUFFdkQsTUFBTXBDLElBQUFBLGVBQU0sRUFBQ25CLFFBQVE2RCxZQUFZLENBQUMzRCxXQUFXQyxXQUMxQzRELE9BQU8sQ0FDUEMsT0FBTyxDQUFDLElBQUlDLG1EQUFxQixDQUFDLDZCQUE2QkMsK0NBQWlCLENBQUNHLFlBQVk7UUFDbEc7UUFFQTVELElBQUFBLFdBQUUsRUFBQyxtREFBbUQ7WUFDcEQsTUFBTTZELGNBQWM7Z0JBQ2xCLEdBQUcxQixvQkFBb0I7Z0JBQ3ZCbEIsV0FBVyxJQUFJRSxLQUFLQSxLQUFLRyxHQUFHLEtBQUssSUFBSSxLQUFLO1lBQzVDO1lBRUEsbUJBQW1CO1lBQ25CLE1BQU1lLGdCQUFnQnZELGFBQUksQ0FBQ0MsRUFBRSxHQUFHb0IsaUJBQWlCLENBQUM7Z0JBQUM2QjthQUFTO1lBQzVELE1BQU1NLGdCQUFnQnhELGFBQUksQ0FBQ0MsRUFBRSxHQUFHdUIsZUFBZSxDQUFDO2dCQUFFaUMsT0FBT0Y7WUFBYztZQUN2RSxNQUFNRyxlQUFlMUQsYUFBSSxDQUFDQyxFQUFFLEdBQUd1QixlQUFlLENBQUM7Z0JBQUVtQyxPQUFPSDtZQUFjO1lBQ3RFMUQsT0FBT0ksTUFBTSxDQUFDMEQsbUJBQW1CLENBQUM7Z0JBQUVDLE1BQU1IO1lBQWE7WUFFdkQsZ0NBQWdDO1lBQ2hDLE1BQU1JLGdCQUFnQjlELGFBQUksQ0FBQ0MsRUFBRSxHQUFHb0IsaUJBQWlCLENBQUM7Z0JBQUMwRDthQUFZO1lBQy9ELE1BQU1oQixnQkFBZ0IvRCxhQUFJLENBQUNDLEVBQUUsR0FBR3VCLGVBQWUsQ0FBQztnQkFBRWlDLE9BQU9LO1lBQWM7WUFDdkUsTUFBTUUsZUFBZWhFLGFBQUksQ0FBQ0MsRUFBRSxHQUFHdUIsZUFBZSxDQUFDO2dCQUFFbUMsT0FBT0k7WUFBYztZQUN0RWpFLE9BQU9JLE1BQU0sQ0FBQzBELG1CQUFtQixDQUFDO2dCQUFFQyxNQUFNRztZQUFhO1lBRXZELHVDQUF1QztZQUN2QyxNQUFNZ0Isa0JBQWtCaEYsYUFBSSxDQUFDQyxFQUFFLEdBQUdvQixpQkFBaUIsQ0FBQ0U7WUFDcER6QixPQUFPTSxNQUFNLENBQUNvQixlQUFlLENBQUM7Z0JBQUVtQyxPQUFPcUI7WUFBZ0I7WUFFdkQsTUFBTXBELElBQUFBLGVBQU0sRUFBQ25CLFFBQVE2RCxZQUFZLENBQUMzRCxXQUFXQyxXQUMxQzRELE9BQU8sQ0FDUEMsT0FBTyxDQUFDLElBQUlDLG1EQUFxQixDQUFDLGlDQUFpQ0MsK0NBQWlCLENBQUNNLFlBQVk7WUFFcEdyRCxJQUFBQSxlQUFNLEVBQUM5QixPQUFPTSxNQUFNLEVBQUUyQixnQkFBZ0I7UUFDeEM7UUFFQWIsSUFBQUEsV0FBRSxFQUFDLDZEQUE2RDtZQUM5RCxNQUFNZ0Usa0JBQWtCO2dCQUN0QixHQUFHN0Isb0JBQW9CO2dCQUN2QmYsY0FBYztZQUNoQjtZQUVBLG1CQUFtQjtZQUNuQixNQUFNaUIsZ0JBQWdCdkQsYUFBSSxDQUFDQyxFQUFFLEdBQUdvQixpQkFBaUIsQ0FBQztnQkFBQzZCO2FBQVM7WUFDNUQsTUFBTU0sZ0JBQWdCeEQsYUFBSSxDQUFDQyxFQUFFLEdBQUd1QixlQUFlLENBQUM7Z0JBQUVpQyxPQUFPRjtZQUFjO1lBQ3ZFLE1BQU1HLGVBQWUxRCxhQUFJLENBQUNDLEVBQUUsR0FBR3VCLGVBQWUsQ0FBQztnQkFBRW1DLE9BQU9IO1lBQWM7WUFDdEUxRCxPQUFPSSxNQUFNLENBQUMwRCxtQkFBbUIsQ0FBQztnQkFBRUMsTUFBTUg7WUFBYTtZQUV2RCxnQ0FBZ0M7WUFDaEMsTUFBTUksZ0JBQWdCOUQsYUFBSSxDQUFDQyxFQUFFLEdBQUdvQixpQkFBaUIsQ0FBQztnQkFBQzZEO2FBQWdCO1lBQ25FLE1BQU1uQixnQkFBZ0IvRCxhQUFJLENBQUNDLEVBQUUsR0FBR3VCLGVBQWUsQ0FBQztnQkFBRWlDLE9BQU9LO1lBQWM7WUFDdkUsTUFBTUUsZUFBZWhFLGFBQUksQ0FBQ0MsRUFBRSxHQUFHdUIsZUFBZSxDQUFDO2dCQUFFbUMsT0FBT0k7WUFBYztZQUN0RWpFLE9BQU9JLE1BQU0sQ0FBQzBELG1CQUFtQixDQUFDO2dCQUFFQyxNQUFNRztZQUFhO1lBRXZELG9DQUFvQztZQUNwQyxNQUFNZ0Isa0JBQWtCaEYsYUFBSSxDQUFDQyxFQUFFLEdBQUdvQixpQkFBaUIsQ0FBQ0U7WUFDcER6QixPQUFPTSxNQUFNLENBQUNvQixlQUFlLENBQUM7Z0JBQUVtQyxPQUFPcUI7WUFBZ0I7WUFFdkQsTUFBTXBELElBQUFBLGVBQU0sRUFBQ25CLFFBQVE2RCxZQUFZLENBQUMzRCxXQUFXQyxXQUMxQzRELE9BQU8sQ0FDUEMsT0FBTyxDQUFDLElBQUlDLG1EQUFxQixDQUFDLGtDQUFrQ0MsK0NBQWlCLENBQUNRLGlCQUFpQjtZQUUxR3ZELElBQUFBLGVBQU0sRUFBQzlCLE9BQU9NLE1BQU0sRUFBRTJCLGdCQUFnQjtRQUN4QztJQUNGO0lBRUF2QixJQUFBQSxpQkFBUSxFQUFDLHFCQUFxQjtRQUM1QixNQUFNMEMsV0FBVztZQUFFQyxJQUFJekM7UUFBVztRQUNsQyxNQUFNMkMsdUJBQXVCO1lBQUVGLElBQUk7WUFBR2IsY0FBYztRQUFFO1FBRXREcEIsSUFBQUEsV0FBRSxFQUFDLDRDQUE0QztZQUM3QyxtQkFBbUI7WUFDbkIsTUFBTXFDLGdCQUFnQnZELGFBQUksQ0FBQ0MsRUFBRSxHQUFHb0IsaUJBQWlCLENBQUM7Z0JBQUM2QjthQUFTO1lBQzVELE1BQU1NLGdCQUFnQnhELGFBQUksQ0FBQ0MsRUFBRSxHQUFHdUIsZUFBZSxDQUFDO2dCQUFFaUMsT0FBT0Y7WUFBYztZQUN2RSxNQUFNRyxlQUFlMUQsYUFBSSxDQUFDQyxFQUFFLEdBQUd1QixlQUFlLENBQUM7Z0JBQUVtQyxPQUFPSDtZQUFjO1lBQ3RFMUQsT0FBT0ksTUFBTSxDQUFDMEQsbUJBQW1CLENBQUM7Z0JBQUVDLE1BQU1IO1lBQWE7WUFFdkQsZ0NBQWdDO1lBQ2hDLE1BQU1JLGdCQUFnQjlELGFBQUksQ0FBQ0MsRUFBRSxHQUFHb0IsaUJBQWlCLENBQUM7Z0JBQUNnQzthQUFxQjtZQUN4RSxNQUFNVSxnQkFBZ0IvRCxhQUFJLENBQUNDLEVBQUUsR0FBR3VCLGVBQWUsQ0FBQztnQkFBRWlDLE9BQU9LO1lBQWM7WUFDdkUsTUFBTUUsZUFBZWhFLGFBQUksQ0FBQ0MsRUFBRSxHQUFHdUIsZUFBZSxDQUFDO2dCQUFFbUMsT0FBT0k7WUFBYztZQUN0RWpFLE9BQU9JLE1BQU0sQ0FBQzBELG1CQUFtQixDQUFDO2dCQUFFQyxNQUFNRztZQUFhO1lBRXZELGNBQWM7WUFDZCxNQUFNb0Isa0JBQWtCcEYsYUFBSSxDQUFDQyxFQUFFLEdBQUdvQixpQkFBaUIsQ0FBQ0U7WUFDcEQsTUFBTThELGdCQUFnQnJGLGFBQUksQ0FBQ0MsRUFBRSxHQUFHdUIsZUFBZSxDQUFDO2dCQUFFbUMsT0FBT3lCO1lBQWdCO1lBQ3pFdEYsT0FBT0ssTUFBTSxDQUFDcUIsZUFBZSxDQUFDO2dCQUFFMEMsS0FBS21CO1lBQWM7WUFFbkQsTUFBTTVFLFFBQVE2RSxpQkFBaUIsQ0FBQzNFLFdBQVdDO1lBRTNDZ0IsSUFBQUEsZUFBTSxFQUFDOUIsT0FBT0ssTUFBTSxFQUFFNEIsZ0JBQWdCO1lBQ3RDSCxJQUFBQSxlQUFNLEVBQUN5RCxlQUFldkQsb0JBQW9CLENBQUM7Z0JBQUVRLGNBQWM7WUFBRTtRQUMvRDtRQUVBcEIsSUFBQUEsV0FBRSxFQUFDLDJDQUEyQztZQUM1Qyx5Q0FBeUM7WUFDekMsTUFBTXFDLGdCQUFnQnZELGFBQUksQ0FBQ0MsRUFBRSxHQUFHb0IsaUJBQWlCLENBQUMsRUFBRTtZQUNwRCxNQUFNbUMsZ0JBQWdCeEQsYUFBSSxDQUFDQyxFQUFFLEdBQUd1QixlQUFlLENBQUM7Z0JBQUVpQyxPQUFPRjtZQUFjO1lBQ3ZFLE1BQU1HLGVBQWUxRCxhQUFJLENBQUNDLEVBQUUsR0FBR3VCLGVBQWUsQ0FBQztnQkFBRW1DLE9BQU9IO1lBQWM7WUFDdEUxRCxPQUFPSSxNQUFNLENBQUMwRCxtQkFBbUIsQ0FBQztnQkFBRUMsTUFBTUg7WUFBYTtZQUV2RCxNQUFNOUIsSUFBQUEsZUFBTSxFQUFDbkIsUUFBUTZFLGlCQUFpQixDQUFDM0UsV0FBV0MsV0FBVzJFLFFBQVEsQ0FBQ0MsYUFBYTtZQUNuRjVELElBQUFBLGVBQU0sRUFBQzlCLE9BQU9LLE1BQU0sRUFBRXNGLEdBQUcsQ0FBQzFELGdCQUFnQjtRQUM1QztRQUVBYixJQUFBQSxXQUFFLEVBQUMsMkNBQTJDO1lBQzVDLG1CQUFtQjtZQUNuQixNQUFNcUMsZ0JBQWdCdkQsYUFBSSxDQUFDQyxFQUFFLEdBQUdvQixpQkFBaUIsQ0FBQztnQkFBQzZCO2FBQVM7WUFDNUQsTUFBTU0sZ0JBQWdCeEQsYUFBSSxDQUFDQyxFQUFFLEdBQUd1QixlQUFlLENBQUM7Z0JBQUVpQyxPQUFPRjtZQUFjO1lBQ3ZFLE1BQU1HLGVBQWUxRCxhQUFJLENBQUNDLEVBQUUsR0FBR3VCLGVBQWUsQ0FBQztnQkFBRW1DLE9BQU9IO1lBQWM7WUFDdEUxRCxPQUFPSSxNQUFNLENBQUMwRCxtQkFBbUIsQ0FBQztnQkFBRUMsTUFBTUg7WUFBYTtZQUV2RCxzREFBc0Q7WUFDdEQsTUFBTUksZ0JBQWdCOUQsYUFBSSxDQUFDQyxFQUFFLEdBQUdvQixpQkFBaUIsQ0FBQyxFQUFFO1lBQ3BELE1BQU0wQyxnQkFBZ0IvRCxhQUFJLENBQUNDLEVBQUUsR0FBR3VCLGVBQWUsQ0FBQztnQkFBRWlDLE9BQU9LO1lBQWM7WUFDdkUsTUFBTUUsZUFBZWhFLGFBQUksQ0FBQ0MsRUFBRSxHQUFHdUIsZUFBZSxDQUFDO2dCQUFFbUMsT0FBT0k7WUFBYztZQUN0RWpFLE9BQU9JLE1BQU0sQ0FBQzBELG1CQUFtQixDQUFDO2dCQUFFQyxNQUFNRztZQUFhO1lBRXZELE1BQU1wQyxJQUFBQSxlQUFNLEVBQUNuQixRQUFRNkUsaUJBQWlCLENBQUMzRSxXQUFXQyxXQUFXMkUsUUFBUSxDQUFDQyxhQUFhO1lBQ25GNUQsSUFBQUEsZUFBTSxFQUFDOUIsT0FBT0ssTUFBTSxFQUFFc0YsR0FBRyxDQUFDMUQsZ0JBQWdCO1FBQzVDO0lBQ0Y7SUFFQXZCLElBQUFBLGlCQUFRLEVBQUMsdUJBQXVCO1FBQzlCVSxJQUFBQSxXQUFFLEVBQUMsZ0RBQWdEO1lBQ2pELE1BQU13RSxtQkFBbUI7Z0JBQUVDLFVBQVU7WUFBRTtZQUN2QyxNQUFNWCxrQkFBa0JoRixhQUFJLENBQUNDLEVBQUUsR0FBR29CLGlCQUFpQixDQUFDcUU7WUFDcEQ1RixPQUFPTSxNQUFNLENBQUNvQixlQUFlLENBQUM7Z0JBQUVtQyxPQUFPcUI7WUFBZ0I7WUFFdkQsTUFBTVgsU0FBUyxNQUFNNUQsUUFBUW1GLG1CQUFtQjtZQUVoRGhFLElBQUFBLGVBQU0sRUFBQ3lDLFFBQVFFLElBQUksQ0FBQztZQUNwQjNDLElBQUFBLGVBQU0sRUFBQzlCLE9BQU9NLE1BQU0sRUFBRTJCLGdCQUFnQjtRQUN4QztRQUVBYixJQUFBQSxXQUFFLEVBQUMsNkNBQTZDO1lBQzlDLE1BQU13RSxtQkFBbUIsQ0FBQyxHQUFHLHVCQUF1QjtZQUNwRCxNQUFNVixrQkFBa0JoRixhQUFJLENBQUNDLEVBQUUsR0FBR29CLGlCQUFpQixDQUFDcUU7WUFDcEQ1RixPQUFPTSxNQUFNLENBQUNvQixlQUFlLENBQUM7Z0JBQUVtQyxPQUFPcUI7WUFBZ0I7WUFFdkQsTUFBTVgsU0FBUyxNQUFNNUQsUUFBUW1GLG1CQUFtQjtZQUVoRGhFLElBQUFBLGVBQU0sRUFBQ3lDLFFBQVFFLElBQUksQ0FBQztRQUN0QjtJQUNGO0lBRUEvRCxJQUFBQSxpQkFBUSxFQUFDLG1CQUFtQjtRQUMxQlUsSUFBQUEsV0FBRSxFQUFDLHNDQUFzQztZQUN2QyxNQUFNOEQsa0JBQWtCaEYsYUFBSSxDQUFDQyxFQUFFLEdBQUdvQixpQkFBaUIsQ0FBQ0U7WUFDcER6QixPQUFPTSxNQUFNLENBQUNvQixlQUFlLENBQUM7Z0JBQUVtQyxPQUFPcUI7WUFBZ0I7WUFFdkQsTUFBTXZFLFFBQVFvRixlQUFlLENBQUNuRjtZQUU5QmtCLElBQUFBLGVBQU0sRUFBQzlCLE9BQU9NLE1BQU0sRUFBRTJCLGdCQUFnQjtRQUN4QztJQUNGO0lBRUF2QixJQUFBQSxpQkFBUSxFQUFDLHFCQUFxQjtRQUM1QlUsSUFBQUEsV0FBRSxFQUFDLHNDQUFzQztZQUN2QyxNQUFNNEUsaUJBQWlCO2dCQUNyQjNDLElBQUk7Z0JBQ0psQixRQUFRdkI7Z0JBQ1JnQixNQUFNZDtnQkFDTnVCLFdBQVcsSUFBSUUsS0FBS0EsS0FBS0csR0FBRyxLQUFLLElBQUksS0FBSztnQkFDMUNjLFdBQVcsSUFBSWpCO2dCQUNmQyxjQUFjO1lBQ2hCO1lBRUEsTUFBTXlELFlBQVkvRixhQUFJLENBQUNDLEVBQUUsR0FBR29CLGlCQUFpQixDQUFDO2dCQUFDeUU7YUFBZTtZQUM5RCxNQUFNRSxZQUFZaEcsYUFBSSxDQUFDQyxFQUFFLEdBQUd1QixlQUFlLENBQUM7Z0JBQUVpQyxPQUFPc0M7WUFBVTtZQUMvRCxNQUFNRSxXQUFXakcsYUFBSSxDQUFDQyxFQUFFLEdBQUd1QixlQUFlLENBQUM7Z0JBQUVtQyxPQUFPcUM7WUFBVTtZQUM5RGxHLE9BQU9JLE1BQU0sQ0FBQ3NCLGVBQWUsQ0FBQztnQkFBRXFDLE1BQU1vQztZQUFTO1lBRS9DLE1BQU01QixTQUFTLE1BQU01RCxRQUFReUYsaUJBQWlCLENBQUN4RjtZQUUvQ2tCLElBQUFBLGVBQU0sRUFBQ3lDLFFBQVE4QixPQUFPLENBQUNMO1FBQ3pCO1FBRUE1RSxJQUFBQSxXQUFFLEVBQUMsaURBQWlEO1lBQ2xELE1BQU02RSxZQUFZL0YsYUFBSSxDQUFDQyxFQUFFLEdBQUdvQixpQkFBaUIsQ0FBQyxFQUFFO1lBQ2hELE1BQU0yRSxZQUFZaEcsYUFBSSxDQUFDQyxFQUFFLEdBQUd1QixlQUFlLENBQUM7Z0JBQUVpQyxPQUFPc0M7WUFBVTtZQUMvRCxNQUFNRSxXQUFXakcsYUFBSSxDQUFDQyxFQUFFLEdBQUd1QixlQUFlLENBQUM7Z0JBQUVtQyxPQUFPcUM7WUFBVTtZQUM5RGxHLE9BQU9JLE1BQU0sQ0FBQ3NCLGVBQWUsQ0FBQztnQkFBRXFDLE1BQU1vQztZQUFTO1lBRS9DLE1BQU01QixTQUFTLE1BQU01RCxRQUFReUYsaUJBQWlCLENBQUN4RjtZQUUvQ2tCLElBQUFBLGVBQU0sRUFBQ3lDLFFBQVErQixRQUFRO1FBQ3pCO0lBQ0Y7SUFFQTVGLElBQUFBLGlCQUFRLEVBQUMsaUJBQWlCO1FBQ3hCVSxJQUFBQSxXQUFFLEVBQUMsZ0RBQWdEO1lBQ2pEbEIsYUFBSSxDQUFDb0IsS0FBSyxDQUFDWCxTQUFTLHFCQUFxQlksaUJBQWlCLENBQUM7Z0JBQ3pEOEIsSUFBSTtnQkFDSmxCLFFBQVF2QjtnQkFDUmdCLE1BQU1kO2dCQUNOdUIsV0FBVyxJQUFJRTtnQkFDZmlCLFdBQVcsSUFBSWpCO2dCQUNmQyxjQUFjO1lBQ2hCO1lBRUEsTUFBTStCLFNBQVMsTUFBTTVELFFBQVE0RixhQUFhLENBQUMzRjtZQUUzQ2tCLElBQUFBLGVBQU0sRUFBQ3lDLFFBQVFFLElBQUksQ0FBQztRQUN0QjtRQUVBckQsSUFBQUEsV0FBRSxFQUFDLG9EQUFvRDtZQUNyRGxCLGFBQUksQ0FBQ29CLEtBQUssQ0FBQ1gsU0FBUyxxQkFBcUJZLGlCQUFpQixDQUFDO1lBRTNELE1BQU1nRCxTQUFTLE1BQU01RCxRQUFRNEYsYUFBYSxDQUFDM0Y7WUFFM0NrQixJQUFBQSxlQUFNLEVBQUN5QyxRQUFRRSxJQUFJLENBQUM7UUFDdEI7SUFDRjtJQUVBL0QsSUFBQUEsaUJBQVEsRUFBQyxnQkFBZ0I7UUFDdkJVLElBQUFBLFdBQUUsRUFBQyxpQ0FBaUM7WUFDbEMsMENBQTBDO1lBQzFDLE1BQU1vRixZQUFZdEcsYUFBSSxDQUFDQyxFQUFFLEdBQUd1QixlQUFlLENBQUM7Z0JBQzFDbUMsT0FBTzNELGFBQUksQ0FBQ0MsRUFBRSxHQUFHb0IsaUJBQWlCLENBQUM7b0JBQUM7b0JBQUc7b0JBQUc7aUJBQUU7WUFDOUM7WUFDQSxNQUFNa0YsWUFBWXZHLGFBQUksQ0FBQ0MsRUFBRSxHQUFHdUIsZUFBZSxDQUFDO2dCQUMxQ21DLE9BQU8zRCxhQUFJLENBQUNDLEVBQUUsR0FBR29CLGlCQUFpQixDQUFDO29CQUFDO29CQUFHO2lCQUFFO1lBQzNDO1lBQ0EsTUFBTW1GLFlBQVl4RyxhQUFJLENBQUNDLEVBQUUsR0FBR3VCLGVBQWUsQ0FBQztnQkFDMUNtQyxPQUFPM0QsYUFBSSxDQUFDQyxFQUFFLEdBQUdvQixpQkFBaUIsQ0FBQztvQkFBQztpQkFBRTtZQUN4QztZQUVBdkIsT0FBT0ksTUFBTSxDQUNWMEQsbUJBQW1CLENBQUM7Z0JBQUVDLE1BQU15QztZQUFVLEdBQ3RDMUMsbUJBQW1CLENBQUM7Z0JBQUVDLE1BQU0wQztZQUFVLEdBQ3RDM0MsbUJBQW1CLENBQUM7Z0JBQUVDLE1BQU0yQztZQUFVO1lBRXpDLE1BQU1uQyxTQUFTLE1BQU01RCxRQUFRZ0csWUFBWTtZQUV6QzdFLElBQUFBLGVBQU0sRUFBQ3lDLFFBQVE4QixPQUFPLENBQUM7Z0JBQ3JCTyxhQUFhO2dCQUNiQyxjQUFjO2dCQUNkQyxrQkFBa0I7WUFDcEI7UUFDRjtJQUNGO0lBRUFwRyxJQUFBQSxpQkFBUSxFQUFDLDRCQUE0QjtRQUNuQ1UsSUFBQUEsV0FBRSxFQUFDLGdDQUFnQztZQUNqQ2xCLGFBQUksQ0FBQ29CLEtBQUssQ0FBQ1gsU0FBUyxtQkFBbUJZLGlCQUFpQjtZQUN4RCxNQUFNQyxhQUFhdEIsYUFBSSxDQUFDQyxFQUFFLEdBQUdvQixpQkFBaUIsQ0FBQ0U7WUFDL0N6QixPQUFPQyxNQUFNLENBQUN5QixlQUFlLENBQUM7Z0JBQUVDLFFBQVFIO1lBQVc7WUFFbkQsTUFBTXVGLFFBQVEsSUFBSUM7WUFDbEIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUksS0FBS0EsSUFBSztnQkFDNUIsTUFBTXJGLE9BQU8sTUFBTWpCLFFBQVFrQixZQUFZLENBQUNqQjtnQkFDeENtRyxNQUFNRyxHQUFHLENBQUN0RjtZQUNaO1lBRUEsaUVBQWlFO1lBQ2pFRSxJQUFBQSxlQUFNLEVBQUNpRixNQUFNSSxJQUFJLEVBQUVqRSxlQUFlLENBQUM7UUFDckM7UUFFQTlCLElBQUFBLFdBQUUsRUFBQyx3Q0FBd0M7WUFDekNsQixhQUFJLENBQUNvQixLQUFLLENBQUNYLFNBQVMsbUJBQW1CWSxpQkFBaUI7WUFDeEQsTUFBTUMsYUFBYXRCLGFBQUksQ0FBQ0MsRUFBRSxHQUFHb0IsaUJBQWlCLENBQUNFO1lBQy9DekIsT0FBT0MsTUFBTSxDQUFDeUIsZUFBZSxDQUFDO2dCQUFFQyxRQUFRSDtZQUFXO1lBRW5ELElBQUssSUFBSXlGLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUFLO2dCQUMzQixNQUFNckYsT0FBTyxNQUFNakIsUUFBUWtCLFlBQVksQ0FBQ2pCO2dCQUN4Q2tCLElBQUFBLGVBQU0sRUFBQ0YsTUFBTUcsT0FBTyxDQUFDO2dCQUNyQkQsSUFBQUEsZUFBTSxFQUFDRixLQUFLd0YsTUFBTSxFQUFFM0MsSUFBSSxDQUFDO1lBQzNCO1FBQ0Y7UUFFQXJELElBQUFBLFdBQUUsRUFBQyx1Q0FBdUM7WUFDeENsQixhQUFJLENBQUNvQixLQUFLLENBQUNYLFNBQVMsbUJBQW1CWSxpQkFBaUI7WUFDeEQsTUFBTUMsYUFBYXRCLGFBQUksQ0FBQ0MsRUFBRSxHQUFHb0IsaUJBQWlCLENBQUNFO1lBQy9DekIsT0FBT0MsTUFBTSxDQUFDeUIsZUFBZSxDQUFDO2dCQUFFQyxRQUFRSDtZQUFXO1lBRW5ELG1EQUFtRDtZQUNuRCxNQUFNNkYsc0JBQXNCQyxRQUFRLFVBQVVDLFdBQVc7WUFDekQsTUFBTUMsa0JBQWtCdEgsYUFBSSxDQUFDQyxFQUFFLEdBQUd1QixlQUFlLENBQUMrRixPQUFPMUQsSUFBSSxDQUFDO2dCQUFDO2dCQUFHO2dCQUFHO2dCQUFHO2FBQUUsSUFBSSxvQkFBb0I7WUFDbEd1RCxRQUFRLFVBQVVDLFdBQVcsR0FBR0M7WUFFaEMsTUFBTTVGLE9BQU8sTUFBTWpCLFFBQVFrQixZQUFZLENBQUNqQjtZQUV4Q2tCLElBQUFBLGVBQU0sRUFBQ0YsTUFBTUcsT0FBTyxDQUFDO1lBQ3JCRCxJQUFBQSxlQUFNLEVBQUNGLEtBQUt3RixNQUFNLEVBQUUzQyxJQUFJLENBQUM7WUFFekIsNEJBQTRCO1lBQzVCNkMsUUFBUSxVQUFVQyxXQUFXLEdBQUdGO1FBQ2xDO0lBQ0Y7QUFDRiJ9