{"version":3,"sources":["/Users/stefanbekker/projects/fancy-planties/src/__tests__/integration/email-verification-flow.test.ts"],"sourcesContent":["/**\n * Email Verification Flow Integration Tests\n * Tests complete signup and verification process, resend functionality, and rate limiting\n * Requirements: 1.1, 1.4, 2.1, 2.2\n */\n\nimport { emailVerificationCodeService } from '@/lib/services/email-verification-code-service';\nimport { createEmailService } from '@/lib/services/resend-email-service';\n\n// Mock email service\njest.mock('@/lib/services/resend-email-service');\njest.mock('@/lib/services/email-service');\n\n// Mock database\njest.mock('@/lib/db', () => ({\n  db: {\n    select: jest.fn().mockReturnThis(),\n    from: jest.fn().mockReturnThis(),\n    where: jest.fn().mockReturnThis(),\n    insert: jest.fn().mockReturnThis(),\n    values: jest.fn().mockReturnThis(),\n    update: jest.fn().mockReturnThis(),\n    set: jest.fn().mockReturnThis(),\n    delete: jest.fn().mockReturnThis(),\n    returning: jest.fn(),\n    execute: jest.fn(),\n  },\n}));\n\n// Mock auth functions\njest.mock('@/lib/auth', () => ({\n  getUserByEmail: jest.fn(),\n  getUserById: jest.fn(),\n}));\n\nconst mockEmailService = {\n  sendVerificationEmail: jest.fn(),\n};\n\nconst mockCreateEmailService = createEmailService as jest.MockedFunction<typeof createEmailService>;\nconst mockSendEmailWithRetry = require('@/lib/services/email-service').sendEmailWithRetry as jest.MockedFunction<any>;\nconst mockDb = require('@/lib/db').db;\nconst mockGetUserByEmail = require('@/lib/auth').getUserByEmail as jest.MockedFunction<any>;\nconst mockGetUserById = require('@/lib/auth').getUserById as jest.MockedFunction<any>;\n\n// Mock environment variables\nconst originalEnv = process.env;\n\nbeforeAll(() => {\n  process.env = {\n    ...originalEnv,\n    RESEND_API_KEY: 'test-api-key',\n    FROM_EMAIL: 'test@example.com',\n    FROM_NAME: 'Test App',\n    VERIFICATION_CODE_EXPIRY_MINUTES: '10',\n    MAX_VERIFICATION_ATTEMPTS: '5',\n    RESEND_COOLDOWN_SECONDS: '60',\n    MAX_RESEND_PER_HOUR: '5',\n    NODE_ENV: 'test',\n  };\n});\n\nafterAll(() => {\n  process.env = originalEnv;\n});\n\ndescribe('Email Verification Flow Integration Tests', () => {\n  beforeEach(async () => {\n    jest.clearAllMocks();\n    \n    // Mock email service to always succeed\n    mockCreateEmailService.mockReturnValue(mockEmailService);\n    mockSendEmailWithRetry.mockResolvedValue(true);\n    mockEmailService.sendVerificationEmail.mockResolvedValue(true);\n\n    // Setup default database mocks\n    mockDb.returning.mockResolvedValue([]);\n    mockDb.execute.mockResolvedValue([]);\n  });\n\n  describe('Complete Signup and Verification Process', () => {\n    it('should complete full signup and verification workflow', async () => {\n      // Mock user data\n      const mockUser = {\n        id: 1,\n        email: 'test@example.com',\n        name: 'Test User',\n        isEmailVerified: false,\n      };\n\n      // Mock database responses for user lookup\n      mockGetUserByEmail.mockResolvedValue(mockUser);\n      mockGetUserById.mockResolvedValue(mockUser);\n\n      // Mock code insertion\n      mockDb.returning.mockResolvedValueOnce([{ id: 1, code: '123456', userId: 1 }]);\n\n      // Step 1: Generate verification code\n      const verificationCode = await emailVerificationCodeService.generateCode(mockUser.id);\n      expect(verificationCode).toMatch(/^\\d{6}$/);\n\n      // Step 2: Mock successful validation\n      mockDb.returning.mockResolvedValueOnce([{ \n        id: 1, \n        code: verificationCode, \n        userId: 1, \n        expiresAt: new Date(Date.now() + 600000),\n        attemptsUsed: 0 \n      }]);\n      \n      // Mock user update to verified\n      mockGetUserById.mockResolvedValueOnce({ ...mockUser, isEmailVerified: true });\n\n      // Step 3: Validate the verification code\n      const isValid = await emailVerificationCodeService.validateCode('test@example.com', verificationCode);\n      expect(isValid).toBe(true);\n\n      // Verify database operations were called\n      expect(mockDb.insert).toHaveBeenCalled();\n      expect(mockDb.update).toHaveBeenCalled();\n      expect(mockDb.delete).toHaveBeenCalled();\n    });\n\n    it('should handle email service failure gracefully during code generation', async () => {\n      // Mock user data\n      const mockUser = {\n        id: 1,\n        email: 'test@example.com',\n        name: 'Test User',\n        isEmailVerified: false,\n      };\n\n      // Mock user lookup\n      mockGetUserById.mockResolvedValue(mockUser);\n\n      // Mock code insertion\n      mockDb.returning.mockResolvedValueOnce([{ id: 1, code: '123456', userId: 1 }]);\n\n      // Generate verification code (this should work even if email fails)\n      const verificationCode = await emailVerificationCodeService.generateCode(mockUser.id);\n      expect(verificationCode).toMatch(/^\\d{6}$/);\n\n      // Verify database insert was called\n      expect(mockDb.insert).toHaveBeenCalled();\n      expect(mockDb.values).toHaveBeenCalled();\n    });\n\n    it('should reject verification with invalid code', async () => {\n      // Create user and verification code\n      const user = await dbManager.createTestUser({\n        email: 'test@example.com',\n        name: 'Test User',\n        passwordHash: 'hashed_password',\n        isEmailVerified: false,\n      });\n\n      await dbManager.createTestEmailCode({\n        userId: user.id,\n        code: '123456',\n        expiresAt: new Date(Date.now() + 10 * 60 * 1000), // 10 minutes from now\n        attemptsUsed: 0,\n      });\n\n      // Try to verify with wrong code using service directly\n      try {\n        await emailVerificationCodeService.validateCode('test@example.com', '654321');\n        fail('Should have thrown an error for invalid code');\n      } catch (error: any) {\n        expect(error.code).toBe('CODE_INVALID');\n      }\n\n      // Verify user is still not verified\n      const unverifiedUser = await dbManager.getUserById(user.id);\n      expect(unverifiedUser.isEmailVerified).toBe(false);\n    });\n\n    it('should reject verification with expired code', async () => {\n      // Create user and expired verification code\n      const user = await dbManager.createTestUser({\n        email: 'test@example.com',\n        name: 'Test User',\n        passwordHash: 'hashed_password',\n        isEmailVerified: false,\n      });\n\n      await dbManager.createTestEmailCode({\n        userId: user.id,\n        code: '123456',\n        expiresAt: new Date(Date.now() - 1000), // Expired 1 second ago\n        attemptsUsed: 0,\n      });\n\n      // Try to verify with expired code using service directly\n      try {\n        await emailVerificationCodeService.validateCode('test@example.com', '123456');\n        fail('Should have thrown an error for expired code');\n      } catch (error: any) {\n        expect(error.code).toBe('CODE_EXPIRED');\n      }\n\n      // Verify user is still not verified\n      const unverifiedUser = await dbManager.getUserById(user.id);\n      expect(unverifiedUser.isEmailVerified).toBe(false);\n    });\n  });\n\n  describe('Resend Verification Code Functionality', () => {\n    it('should resend verification code by generating new code', async () => {\n      // Create unverified user\n      const user = await dbManager.createTestUser({\n        email: 'test@example.com',\n        name: 'Test User',\n        passwordHash: 'hashed_password',\n        isEmailVerified: false,\n      });\n\n      // Create existing verification code\n      await dbManager.createTestEmailCode({\n        userId: user.id,\n        code: '123456',\n        expiresAt: new Date(Date.now() + 10 * 60 * 1000),\n        attemptsUsed: 0,\n      });\n\n      // Generate new verification code (simulating resend)\n      const newCode = await emailVerificationCodeService.generateCode(user.id);\n      expect(newCode).toMatch(/^\\d{6}$/);\n      expect(newCode).not.toBe('123456'); // Should be a new code\n\n      // Verify new code was generated (old one should be invalidated)\n      const emailCodes = await dbManager.getEmailCodesByUserId(user.id);\n      expect(emailCodes).toHaveLength(1);\n      expect(emailCodes[0].code).toBe(newCode);\n    });\n\n    it('should handle resend for already verified user', async () => {\n      // Create verified user\n      const user = await dbManager.createTestUser({\n        email: 'test@example.com',\n        name: 'Test User',\n        passwordHash: 'hashed_password',\n        isEmailVerified: true, // Already verified\n      });\n\n      // Try to generate code for already verified user\n      try {\n        await emailVerificationCodeService.generateCode(user.id);\n        fail('Should have thrown an error for already verified user');\n      } catch (error: any) {\n        expect(error.code).toBe('ALREADY_VERIFIED');\n      }\n    });\n\n    it('should handle resend for non-existent user', async () => {\n      // Try to validate code for non-existent user\n      try {\n        await emailVerificationCodeService.validateCode('nonexistent@example.com', '123456');\n        fail('Should have thrown an error for non-existent user');\n      } catch (error: any) {\n        expect(error.code).toBe('USER_NOT_FOUND');\n      }\n    });\n  });\n\n  describe('Rate Limiting Enforcement', () => {\n    it('should enforce verification attempt limits', async () => {\n      // Create user and verification code\n      const user = await dbManager.createTestUser({\n        email: 'test@example.com',\n        name: 'Test User',\n        passwordHash: 'hashed_password',\n        isEmailVerified: false,\n      });\n\n      const emailCode = await dbManager.createTestEmailCode({\n        userId: user.id,\n        code: '123456',\n        expiresAt: new Date(Date.now() + 10 * 60 * 1000),\n        attemptsUsed: 5, // Already at max attempts (limit is 5)\n      });\n\n      // Try to verify with max attempts reached\n      try {\n        await emailVerificationCodeService.validateCode('test@example.com', '123456');\n        fail('Should have thrown an error for too many attempts');\n      } catch (error: any) {\n        expect(error.code).toBe('TOO_MANY_ATTEMPTS');\n      }\n\n      // Verify user is still not verified\n      const unverifiedUser = await dbManager.getUserById(user.id);\n      expect(unverifiedUser.isEmailVerified).toBe(false);\n    });\n\n    it('should handle validation at service level', async () => {\n      // Create user for testing\n      const user = await dbManager.createTestUser({\n        email: 'test@example.com',\n        name: 'Test User',\n        passwordHash: 'hashed_password',\n        isEmailVerified: false,\n      });\n\n      // Generate valid code\n      const validCode = await emailVerificationCodeService.generateCode(user.id);\n      expect(validCode).toMatch(/^\\d{6}$/);\n\n      // Test that service validates codes properly\n      const isValid = await emailVerificationCodeService.validateCode('test@example.com', validCode);\n      expect(isValid).toBe(true);\n\n      // Verify user is now verified\n      const verifiedUser = await dbManager.getUserById(user.id);\n      expect(verifiedUser.isEmailVerified).toBe(true);\n    });\n  });\n\n  describe('Edge Cases and Error Scenarios', () => {\n    it('should handle duplicate verification code generation', async () => {\n      // Create user\n      const user = await dbManager.createTestUser({\n        email: 'test@example.com',\n        name: 'Test User',\n        passwordHash: 'hashed_password',\n        isEmailVerified: false,\n      });\n\n      // Generate first code\n      const firstCode = await emailVerificationCodeService.generateCode(user.id);\n      expect(firstCode).toMatch(/^\\d{6}$/);\n\n      // Generate second code (should invalidate first)\n      const secondCode = await emailVerificationCodeService.generateCode(user.id);\n      expect(secondCode).toMatch(/^\\d{6}$/);\n      expect(secondCode).not.toBe(firstCode);\n\n      // Verify only one code exists\n      const emailCodes = await dbManager.getEmailCodesByUserId(user.id);\n      expect(emailCodes).toHaveLength(1);\n      expect(emailCodes[0].code).toBe(secondCode);\n    });\n\n    it('should handle service errors gracefully', async () => {\n      // Test with non-existent user ID\n      try {\n        await emailVerificationCodeService.generateCode(99999); // Non-existent user ID\n        fail('Should have thrown an error for non-existent user');\n      } catch (error: any) {\n        expect(error.code).toBe('USER_NOT_FOUND');\n      }\n    });\n\n    it('should handle cleanup of expired codes', async () => {\n      // Create user with expired code\n      const user = await dbManager.createTestUser({\n        email: 'test@example.com',\n        name: 'Test User',\n        passwordHash: 'hashed_password',\n        isEmailVerified: false,\n      });\n\n      await dbManager.createTestEmailCode({\n        userId: user.id,\n        code: '123456',\n        expiresAt: new Date(Date.now() - 60000), // Expired 1 minute ago\n        attemptsUsed: 0,\n      });\n\n      // Run cleanup\n      await emailVerificationCodeService.cleanupExpiredCodes();\n\n      // Verify expired code was cleaned up\n      const remainingCodes = await dbManager.getEmailCodesByUserId(user.id);\n      expect(remainingCodes).toHaveLength(0);\n    });\n  });\n});"],"names":["jest","mock","db","select","fn","mockReturnThis","from","where","insert","values","update","set","delete","returning","execute","getUserByEmail","getUserById","mockEmailService","sendVerificationEmail","mockCreateEmailService","createEmailService","mockSendEmailWithRetry","require","sendEmailWithRetry","mockDb","mockGetUserByEmail","mockGetUserById","originalEnv","process","env","beforeAll","RESEND_API_KEY","FROM_EMAIL","FROM_NAME","VERIFICATION_CODE_EXPIRY_MINUTES","MAX_VERIFICATION_ATTEMPTS","RESEND_COOLDOWN_SECONDS","MAX_RESEND_PER_HOUR","NODE_ENV","afterAll","describe","beforeEach","clearAllMocks","mockReturnValue","mockResolvedValue","it","mockUser","id","email","name","isEmailVerified","mockResolvedValueOnce","code","userId","verificationCode","emailVerificationCodeService","generateCode","expect","toMatch","expiresAt","Date","now","attemptsUsed","isValid","validateCode","toBe","toHaveBeenCalled","user","dbManager","createTestUser","passwordHash","createTestEmailCode","fail","error","unverifiedUser","newCode","not","emailCodes","getEmailCodesByUserId","toHaveLength","emailCode","validCode","verifiedUser","firstCode","secondCode","cleanupExpiredCodes","remainingCodes"],"mappings":"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"}