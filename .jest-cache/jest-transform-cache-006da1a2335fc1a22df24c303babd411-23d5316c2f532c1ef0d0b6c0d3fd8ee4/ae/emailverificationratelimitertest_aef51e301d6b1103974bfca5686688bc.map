{"version":3,"sources":["/Users/stefanbekker/projects/fancy-planties/src/__tests__/services/email-verification-rate-limiter.test.ts"],"sourcesContent":["import { EmailVerificationRateLimiter, DEFAULT_EMAIL_VERIFICATION_RATE_LIMIT_CONFIG } from '@/lib/services/email-verification-rate-limiter';\n\ndescribe('EmailVerificationRateLimiter', () => {\n  let rateLimiter: EmailVerificationRateLimiter;\n  \n  beforeEach(() => {\n    // Create a new instance with shorter windows for testing\n    rateLimiter = new EmailVerificationRateLimiter({\n      maxVerificationAttempts: 3,\n      verificationWindowMs: 1000, // 1 second\n      maxResendRequests: 2,\n      resendWindowMs: 1000, // 1 second\n      resendCooldownMs: 500, // 0.5 seconds\n      maxEmailVerificationRequests: 5,\n      emailVerificationWindowMs: 1000, // 1 second\n    });\n  });\n  \n  afterEach(() => {\n    // Clean up after each test\n    rateLimiter.cleanup();\n  });\n  \n  describe('checkVerificationAttempts', () => {\n    it('should allow requests within limit', () => {\n      const identifier = '192.168.1.1';\n      \n      // First request should be allowed\n      const result1 = rateLimiter.checkVerificationAttempts(identifier);\n      expect(result1.allowed).toBe(true);\n      expect(result1.remaining).toBe(2);\n      \n      // Second request should be allowed\n      const result2 = rateLimiter.checkVerificationAttempts(identifier);\n      expect(result2.allowed).toBe(true);\n      expect(result2.remaining).toBe(1);\n      \n      // Third request should be allowed\n      const result3 = rateLimiter.checkVerificationAttempts(identifier);\n      expect(result3.allowed).toBe(true);\n      expect(result3.remaining).toBe(0);\n    });\n    \n    it('should block requests over limit', () => {\n      const identifier = '192.168.1.1';\n      \n      // Use up the limit\n      for (let i = 0; i < 3; i++) {\n        rateLimiter.checkVerificationAttempts(identifier);\n      }\n      \n      // Fourth request should be blocked\n      const result = rateLimiter.checkVerificationAttempts(identifier);\n      expect(result.allowed).toBe(false);\n      expect(result.remaining).toBe(0);\n      expect(result.retryAfter).toBeGreaterThan(0);\n    });\n    \n    it('should reset after window expires', async () => {\n      const identifier = '192.168.1.1';\n      \n      // Use up the limit\n      for (let i = 0; i < 3; i++) {\n        rateLimiter.checkVerificationAttempts(identifier);\n      }\n      \n      // Should be blocked\n      expect(rateLimiter.checkVerificationAttempts(identifier).allowed).toBe(false);\n      \n      // Wait for window to expire\n      await new Promise(resolve => setTimeout(resolve, 1100));\n      \n      // Should be allowed again\n      const result = rateLimiter.checkVerificationAttempts(identifier);\n      expect(result.allowed).toBe(true);\n      expect(result.remaining).toBe(2);\n    });\n  });\n  \n  describe('checkResendRequests', () => {\n    it('should allow requests within limit', () => {\n      const email = 'test@example.com';\n      const identifier = '192.168.1.1';\n      \n      // First request should be allowed\n      const result1 = rateLimiter.checkResendRequests(email, identifier);\n      expect(result1.allowed).toBe(true);\n      expect(result1.remaining).toBe(1);\n      \n      // Record success to update cooldown\n      rateLimiter.recordResendSuccess(email);\n      \n      // Wait for cooldown\n      return new Promise(resolve => {\n        setTimeout(() => {\n          // Second request should be allowed after cooldown\n          const result2 = rateLimiter.checkResendRequests(email, identifier);\n          expect(result2.allowed).toBe(true);\n          expect(result2.remaining).toBe(0);\n          resolve(undefined);\n        }, 600); // Wait for cooldown to expire\n      });\n    });\n    \n    it('should enforce cooldown period', () => {\n      const email = 'test@example.com';\n      const identifier = '192.168.1.1';\n      \n      // First request\n      rateLimiter.checkResendRequests(email, identifier);\n      rateLimiter.recordResendSuccess(email);\n      \n      // Immediate second request should be blocked by cooldown\n      const result = rateLimiter.checkResendRequests(email, identifier);\n      expect(result.allowed).toBe(false);\n      expect(result.cooldownRemaining).toBeGreaterThan(0);\n    });\n    \n    it('should block requests over hourly limit', () => {\n      const email = 'test@example.com';\n      const identifier = '192.168.1.1';\n      \n      // Use up the limit (with cooldown waits)\n      rateLimiter.checkResendRequests(email, identifier);\n      rateLimiter.recordResendSuccess(email);\n      \n      // Wait for cooldown\n      return new Promise(resolve => {\n        setTimeout(() => {\n          rateLimiter.checkResendRequests(email, identifier);\n          rateLimiter.recordResendSuccess(email);\n          \n          setTimeout(() => {\n            // Third request should be blocked by hourly limit\n            const result = rateLimiter.checkResendRequests(email, identifier);\n            expect(result.allowed).toBe(false);\n            expect(result.retryAfter).toBeGreaterThan(0);\n            resolve(undefined);\n          }, 600);\n        }, 600);\n      });\n    });\n  });\n  \n  describe('checkEmailVerificationActivity', () => {\n    it('should allow requests within limit', () => {\n      const identifier = '192.168.1.1';\n      \n      for (let i = 0; i < 5; i++) {\n        const result = rateLimiter.checkEmailVerificationActivity(identifier);\n        expect(result.allowed).toBe(true);\n        expect(result.remaining).toBe(4 - i);\n      }\n    });\n    \n    it('should block requests over limit', () => {\n      const identifier = '192.168.1.1';\n      \n      // Use up the limit\n      for (let i = 0; i < 5; i++) {\n        rateLimiter.checkEmailVerificationActivity(identifier);\n      }\n      \n      // Sixth request should be blocked\n      const result = rateLimiter.checkEmailVerificationActivity(identifier);\n      expect(result.allowed).toBe(false);\n      expect(result.remaining).toBe(0);\n    });\n  });\n  \n  describe('detectSuspiciousActivity', () => {\n    it('should detect rapid verification attempts', () => {\n      const identifier = '192.168.1.1';\n      const email = 'test@example.com';\n      \n      // Make rapid attempts\n      for (let i = 0; i < 8; i++) {\n        rateLimiter.checkVerificationAttempts(identifier, email);\n      }\n      \n      const isSuspicious = rateLimiter.detectSuspiciousActivity(identifier, email);\n      expect(isSuspicious).toBe(true);\n    });\n    \n    it('should not detect normal activity as suspicious', () => {\n      const identifier = '192.168.1.1';\n      const email = 'test@example.com';\n      \n      // Make normal attempts\n      for (let i = 0; i < 2; i++) {\n        rateLimiter.checkVerificationAttempts(identifier, email);\n      }\n      \n      const isSuspicious = rateLimiter.detectSuspiciousActivity(identifier, email);\n      expect(isSuspicious).toBe(false);\n    });\n  });\n  \n  describe('getSecurityEvents', () => {\n    it('should return security events', () => {\n      const identifier = '192.168.1.1';\n      \n      // Trigger rate limit to generate security event\n      for (let i = 0; i < 4; i++) {\n        rateLimiter.checkVerificationAttempts(identifier);\n      }\n      \n      const events = rateLimiter.getSecurityEvents();\n      expect(events.length).toBeGreaterThan(0);\n      expect(events[0].type).toBe('RATE_LIMIT_EXCEEDED');\n      expect(events[0].identifier).toBe(identifier);\n    });\n    \n    it('should filter events by timestamp', () => {\n      const identifier = '192.168.1.1';\n      const now = Date.now();\n      \n      // Trigger rate limit\n      for (let i = 0; i < 4; i++) {\n        rateLimiter.checkVerificationAttempts(identifier);\n      }\n      \n      // Get events since future timestamp (should be empty)\n      const futureEvents = rateLimiter.getSecurityEvents(now + 1000);\n      expect(futureEvents.length).toBe(0);\n      \n      // Get events since past timestamp (should include events)\n      const pastEvents = rateLimiter.getSecurityEvents(now - 1000);\n      expect(pastEvents.length).toBeGreaterThan(0);\n    });\n  });\n  \n  describe('cleanup', () => {\n    it('should clean up expired data', async () => {\n      const identifier = '192.168.1.1';\n      \n      // Generate some data\n      rateLimiter.checkVerificationAttempts(identifier);\n      rateLimiter.checkEmailVerificationActivity(identifier);\n      \n      // Check stats before cleanup\n      const statsBefore = rateLimiter.getStats();\n      expect(statsBefore.verificationAttempts).toBeGreaterThan(0);\n      expect(statsBefore.emailVerificationActivity).toBeGreaterThan(0);\n      \n      // Wait for data to expire\n      await new Promise(resolve => setTimeout(resolve, 1100));\n      \n      // Run cleanup\n      rateLimiter.cleanup();\n      \n      // Check stats after cleanup\n      const statsAfter = rateLimiter.getStats();\n      expect(statsAfter.verificationAttempts).toBe(0);\n      expect(statsAfter.emailVerificationActivity).toBe(0);\n    });\n  });\n  \n  describe('getStats', () => {\n    it('should return current statistics', () => {\n      const identifier = '192.168.1.1';\n      const email = 'test@example.com';\n      \n      // Generate some activity\n      rateLimiter.checkVerificationAttempts(identifier);\n      rateLimiter.checkResendRequests(email, identifier);\n      rateLimiter.checkEmailVerificationActivity(identifier);\n      \n      const stats = rateLimiter.getStats();\n      expect(stats.verificationAttempts).toBe(1);\n      expect(stats.resendRequests).toBe(1);\n      expect(stats.emailVerificationActivity).toBe(1);\n      expect(stats.resendCooldowns).toBe(0); // No successful resends yet\n      expect(stats.securityEvents).toBe(0); // No rate limits exceeded yet\n    });\n  });\n});"],"names":["describe","rateLimiter","beforeEach","EmailVerificationRateLimiter","maxVerificationAttempts","verificationWindowMs","maxResendRequests","resendWindowMs","resendCooldownMs","maxEmailVerificationRequests","emailVerificationWindowMs","afterEach","cleanup","it","identifier","result1","checkVerificationAttempts","expect","allowed","toBe","remaining","result2","result3","i","result","retryAfter","toBeGreaterThan","Promise","resolve","setTimeout","email","checkResendRequests","recordResendSuccess","undefined","cooldownRemaining","checkEmailVerificationActivity","isSuspicious","detectSuspiciousActivity","events","getSecurityEvents","length","type","now","Date","futureEvents","pastEvents","statsBefore","getStats","verificationAttempts","emailVerificationActivity","statsAfter","stats","resendRequests","resendCooldowns","securityEvents"],"mappings":"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"}