04603420b80590cc24670e7574b88fa1
/**
 * Email Verification Error Scenario Tests
 * Tests email service failure handling, retry logic, expired code scenarios, 
 * cleanup processes, and concurrent verification attempts
 * Requirements: 1.4, 3.1, 7.3, 7.4
 */ "use strict";
// Mock email service and related modules
jest.mock('@/lib/services/resend-email-service');
jest.mock('@/lib/services/email-service');
// Mock database
jest.mock('@/lib/db', ()=>({
        db: {
            select: jest.fn().mockReturnThis(),
            from: jest.fn().mockReturnThis(),
            where: jest.fn().mockReturnThis(),
            insert: jest.fn().mockReturnThis(),
            values: jest.fn().mockReturnThis(),
            update: jest.fn().mockReturnThis(),
            set: jest.fn().mockReturnThis(),
            delete: jest.fn().mockReturnThis(),
            returning: jest.fn(),
            execute: jest.fn()
        }
    }));
// Mock auth functions
jest.mock('@/lib/auth', ()=>({
        getUserByEmail: jest.fn(),
        getUserById: jest.fn()
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _emailverificationcodeservice = require("../../lib/services/email-verification-code-service");
const _resendemailservice = require("../../lib/services/resend-email-service");
const _emailservice = require("../../lib/services/email-service");
const mockEmailService = {
    sendVerificationEmail: jest.fn()
};
const mockCreateEmailService = _resendemailservice.createEmailService;
const mockSendEmailWithRetry = require('@/lib/services/email-service').sendEmailWithRetry;
const mockDb = require('@/lib/db').db;
const mockGetUserByEmail = require('@/lib/auth').getUserByEmail;
const mockGetUserById = require('@/lib/auth').getUserById;
// Mock environment variables
const originalEnv = process.env;
beforeAll(()=>{
    process.env = {
        ...originalEnv,
        RESEND_API_KEY: 'test-api-key',
        FROM_EMAIL: 'test@example.com',
        FROM_NAME: 'Test App',
        VERIFICATION_CODE_EXPIRY_MINUTES: '10',
        MAX_VERIFICATION_ATTEMPTS: '5',
        RESEND_COOLDOWN_SECONDS: '60',
        MAX_RESEND_PER_HOUR: '5',
        NODE_ENV: 'test'
    };
});
afterAll(()=>{
    process.env = originalEnv;
});
describe('Email Verification Error Scenario Tests', ()=>{
    let dbManager;
    beforeEach(async ()=>{
        jest.clearAllMocks();
        dbManager = createDatabaseTestManager();
        // Default to successful email service
        mockCreateEmailService.mockReturnValue(mockEmailService);
        mockSendEmailWithRetry.mockResolvedValue(true);
        mockEmailService.sendVerificationEmail.mockResolvedValue(true);
    });
    afterEach(async ()=>{
        await dbManager.cleanup();
    });
    describe('Email Service Failure Handling and Retry Logic', ()=>{
        it('should handle email service errors during code generation', async ()=>{
            // Mock email service to fail
            mockSendEmailWithRetry.mockRejectedValue(new _emailservice.EmailServiceError('Quota exceeded', 'QUOTA_EXCEEDED'));
            // Create user
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Generate verification code (should work even if email fails)
            const verificationCode = await _emailverificationcodeservice.emailVerificationCodeService.generateCode(user.id);
            expect(verificationCode).toMatch(/^\d{6}$/);
            // Verify code was stored in database
            const emailCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(emailCodes).toHaveLength(1);
            expect(emailCodes[0].code).toBe(verificationCode);
            // User should still be unverified
            const unverifiedUser = await dbManager.getUserById(user.id);
            expect(unverifiedUser.isEmailVerified).toBe(false);
        });
        it('should handle different types of email service errors', async ()=>{
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Test API error
            mockSendEmailWithRetry.mockRejectedValue(new _emailservice.EmailServiceError('API error', 'API_ERROR'));
            const code1 = await _emailverificationcodeservice.emailVerificationCodeService.generateCode(user.id);
            expect(code1).toMatch(/^\d{6}$/);
            // Test network error
            mockSendEmailWithRetry.mockRejectedValue(new _emailservice.EmailServiceError('Network timeout', 'NETWORK_ERROR'));
            const code2 = await _emailverificationcodeservice.emailVerificationCodeService.generateCode(user.id);
            expect(code2).toMatch(/^\d{6}$/);
            expect(code2).not.toBe(code1); // Should be different code
            // Verify only latest code exists
            const emailCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(emailCodes).toHaveLength(1);
            expect(emailCodes[0].code).toBe(code2);
        });
        it('should handle email service errors but still generate codes', async ()=>{
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Mock various email service errors
            mockSendEmailWithRetry.mockRejectedValue(new _emailservice.EmailServiceError('Invalid email', 'INVALID_EMAIL'));
            // Code generation should still work
            const code = await _emailverificationcodeservice.emailVerificationCodeService.generateCode(user.id);
            expect(code).toMatch(/^\d{6}$/);
            // Verify code was stored
            const emailCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(emailCodes).toHaveLength(1);
            expect(emailCodes[0].code).toBe(code);
        });
    });
    describe('Expired Code Scenarios and Cleanup Processes', ()=>{
        it('should handle expired verification codes properly', async ()=>{
            // Create user with expired verification code
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            const expiredCode = await dbManager.createTestEmailCode({
                userId: user.id,
                code: '123456',
                expiresAt: new Date(Date.now() - 60000),
                attemptsUsed: 0
            });
            // Try to verify with expired code using service
            try {
                await _emailverificationcodeservice.emailVerificationCodeService.validateCode('test@example.com', '123456');
                fail('Should have thrown an error for expired code');
            } catch (error) {
                expect(error.code).toBe('CODE_EXPIRED');
            }
            // Verify user is still not verified
            const unverifiedUser = await dbManager.getUserById(user.id);
            expect(unverifiedUser.isEmailVerified).toBe(false);
        });
        it('should clean up expired codes during verification service operations', async ()=>{
            // Create user with multiple codes, some expired
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Create expired code
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '111111',
                expiresAt: new Date(Date.now() - 60000),
                attemptsUsed: 0
            });
            // Create valid code
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '222222',
                expiresAt: new Date(Date.now() + 600000),
                attemptsUsed: 0
            });
            // Trigger cleanup by calling the service method
            await _emailverificationcodeservice.emailVerificationCodeService.cleanupExpiredCodes();
            // Verify expired code was cleaned up
            const remainingCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(remainingCodes).toHaveLength(1);
            expect(remainingCodes[0].code).toBe('222222');
        });
        it('should handle cleanup when user is deleted', async ()=>{
            // Create user with verification codes
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '123456',
                expiresAt: new Date(Date.now() + 600000),
                attemptsUsed: 0
            });
            // Verify code exists
            let emailCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(emailCodes).toHaveLength(1);
            // Delete user (should cascade delete codes due to foreign key constraint)
            await dbManager.deleteUser(user.id);
            // Verify codes were cleaned up
            emailCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(emailCodes).toHaveLength(0);
        });
        it('should handle multiple expired codes for same user', async ()=>{
            // Create user with multiple expired codes
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Create multiple expired codes
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '111111',
                expiresAt: new Date(Date.now() - 120000),
                attemptsUsed: 0
            });
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '222222',
                expiresAt: new Date(Date.now() - 60000),
                attemptsUsed: 0
            });
            // Try to verify with one of the expired codes
            const verifyRequest = new NextRequest('http://localhost/api/auth/verify-email', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com',
                    code: '111111'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            const verifyResponse = await verifyEmailHandler(verifyRequest);
            const verifyData = await verifyResponse.json();
            // Assert expired code error
            expect(verifyResponse.status).toBe(400);
            expect(verifyData.error).toContain('Verification code has expired');
            // Cleanup expired codes
            await _emailverificationcodeservice.emailVerificationCodeService.cleanupExpiredCodes();
            // Verify all expired codes were cleaned up
            const remainingCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(remainingCodes).toHaveLength(0);
        });
    });
    describe('Concurrent Verification Attempts and Race Conditions', ()=>{
        it('should handle concurrent verification attempts safely', async ()=>{
            // Create user with verification code
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '123456',
                expiresAt: new Date(Date.now() + 600000),
                attemptsUsed: 0
            });
            // Execute concurrent verification attempts
            const promises = [
                _emailverificationcodeservice.emailVerificationCodeService.validateCode('test@example.com', '123456'),
                _emailverificationcodeservice.emailVerificationCodeService.validateCode('test@example.com', '123456')
            ];
            // One should succeed, one should fail
            const results = await Promise.allSettled(promises);
            const successCount = results.filter((r)=>r.status === 'fulfilled' && r.value === true).length;
            const failureCount = results.filter((r)=>r.status === 'rejected').length;
            // At least one should succeed, and there might be failures due to race conditions
            expect(successCount).toBeGreaterThanOrEqual(1);
            // Verify user is verified
            const verifiedUser = await dbManager.getUserById(user.id);
            expect(verifiedUser.isEmailVerified).toBe(true);
            // Verify code was deleted
            const remainingCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(remainingCodes).toHaveLength(0);
        });
        it('should handle concurrent code generation requests safely', async ()=>{
            // Create user
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Execute concurrent code generation requests
            const promises = [
                _emailverificationcodeservice.emailVerificationCodeService.generateCode(user.id),
                _emailverificationcodeservice.emailVerificationCodeService.generateCode(user.id)
            ];
            const codes = await Promise.all(promises);
            // Both should succeed and return valid codes
            expect(codes[0]).toMatch(/^\d{6}$/);
            expect(codes[1]).toMatch(/^\d{6}$/);
            // Verify only one code exists (latest one)
            const emailCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(emailCodes).toHaveLength(1);
            // The remaining code should be one of the generated codes
            expect([
                codes[0],
                codes[1]
            ]).toContain(emailCodes[0].code);
        });
        it('should handle race condition between verification and code expiration', async ()=>{
            // Create user with code that expires very soon
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '123456',
                expiresAt: new Date(Date.now() + 100),
                attemptsUsed: 0
            });
            // Wait for code to expire
            await new Promise((resolve)=>setTimeout(resolve, 150));
            // Try to verify with expired code using service
            try {
                await _emailverificationcodeservice.emailVerificationCodeService.validateCode('test@example.com', '123456');
                fail('Should have thrown an error for expired code');
            } catch (error) {
                expect(error.code).toBe('CODE_EXPIRED');
            }
            // User should remain unverified
            const unverifiedUser = await dbManager.getUserById(user.id);
            expect(unverifiedUser.isEmailVerified).toBe(false);
        });
        it('should handle concurrent code generation for same user', async ()=>{
            // Create user
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Execute multiple concurrent code generation requests
            const promises = Array(5).fill(null).map(()=>_emailverificationcodeservice.emailVerificationCodeService.generateCode(user.id));
            const codes = await Promise.all(promises);
            // All should succeed and return valid codes
            codes.forEach((code)=>{
                expect(code).toMatch(/^\d{6}$/);
            });
            // Verify only one code exists (latest one)
            const emailCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(emailCodes).toHaveLength(1);
            // The remaining code should be one of the generated codes
            expect(codes).toContain(emailCodes[0].code);
        });
    });
    describe('Database Error Scenarios', ()=>{
        it('should handle maximum attempts reached', async ()=>{
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Create code with maximum attempts reached
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '123456',
                expiresAt: new Date(Date.now() + 600000),
                attemptsUsed: 5
            });
            // Try to verify with max attempts reached
            try {
                await _emailverificationcodeservice.emailVerificationCodeService.validateCode('test@example.com', '123456');
                fail('Should have thrown an error for too many attempts');
            } catch (error) {
                expect(error.code).toBe('TOO_MANY_ATTEMPTS');
            }
            // User should remain unverified
            const unverifiedUser = await dbManager.getUserById(user.id);
            expect(unverifiedUser.isEmailVerified).toBe(false);
        });
        it('should handle service errors during validation', async ()=>{
            // Test with non-existent user
            try {
                await _emailverificationcodeservice.emailVerificationCodeService.validateCode('nonexistent@example.com', '123456');
                fail('Should have thrown an error for non-existent user');
            } catch (error) {
                expect(error.code).toBe('USER_NOT_FOUND');
            }
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdGVmYW5iZWtrZXIvcHJvamVjdHMvZmFuY3ktcGxhbnRpZXMvc3JjL19fdGVzdHNfXy9pbnRlZ3JhdGlvbi9lbWFpbC12ZXJpZmljYXRpb24tZXJyb3Itc2NlbmFyaW9zLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFbWFpbCBWZXJpZmljYXRpb24gRXJyb3IgU2NlbmFyaW8gVGVzdHNcbiAqIFRlc3RzIGVtYWlsIHNlcnZpY2UgZmFpbHVyZSBoYW5kbGluZywgcmV0cnkgbG9naWMsIGV4cGlyZWQgY29kZSBzY2VuYXJpb3MsIFxuICogY2xlYW51cCBwcm9jZXNzZXMsIGFuZCBjb25jdXJyZW50IHZlcmlmaWNhdGlvbiBhdHRlbXB0c1xuICogUmVxdWlyZW1lbnRzOiAxLjQsIDMuMSwgNy4zLCA3LjRcbiAqL1xuXG5pbXBvcnQgeyBlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlIH0gZnJvbSAnQC9saWIvc2VydmljZXMvZW1haWwtdmVyaWZpY2F0aW9uLWNvZGUtc2VydmljZSc7XG5pbXBvcnQgeyBjcmVhdGVFbWFpbFNlcnZpY2UgfSBmcm9tICdAL2xpYi9zZXJ2aWNlcy9yZXNlbmQtZW1haWwtc2VydmljZSc7XG5pbXBvcnQgeyBFbWFpbFNlcnZpY2VFcnJvciB9IGZyb20gJ0AvbGliL3NlcnZpY2VzL2VtYWlsLXNlcnZpY2UnO1xuXG4vLyBNb2NrIGVtYWlsIHNlcnZpY2UgYW5kIHJlbGF0ZWQgbW9kdWxlc1xuamVzdC5tb2NrKCdAL2xpYi9zZXJ2aWNlcy9yZXNlbmQtZW1haWwtc2VydmljZScpO1xuamVzdC5tb2NrKCdAL2xpYi9zZXJ2aWNlcy9lbWFpbC1zZXJ2aWNlJyk7XG5cbi8vIE1vY2sgZGF0YWJhc2Vcbmplc3QubW9jaygnQC9saWIvZGInLCAoKSA9PiAoe1xuICBkYjoge1xuICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgZnJvbTogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgd2hlcmU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxuICAgIGluc2VydDogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgdmFsdWVzOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgICB1cGRhdGU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxuICAgIHNldDogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgZGVsZXRlOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgICByZXR1cm5pbmc6IGplc3QuZm4oKSxcbiAgICBleGVjdXRlOiBqZXN0LmZuKCksXG4gIH0sXG59KSk7XG5cbi8vIE1vY2sgYXV0aCBmdW5jdGlvbnNcbmplc3QubW9jaygnQC9saWIvYXV0aCcsICgpID0+ICh7XG4gIGdldFVzZXJCeUVtYWlsOiBqZXN0LmZuKCksXG4gIGdldFVzZXJCeUlkOiBqZXN0LmZuKCksXG59KSk7XG5cbmNvbnN0IG1vY2tFbWFpbFNlcnZpY2UgPSB7XG4gIHNlbmRWZXJpZmljYXRpb25FbWFpbDogamVzdC5mbigpLFxufTtcblxuY29uc3QgbW9ja0NyZWF0ZUVtYWlsU2VydmljZSA9IGNyZWF0ZUVtYWlsU2VydmljZSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiBjcmVhdGVFbWFpbFNlcnZpY2U+O1xuY29uc3QgbW9ja1NlbmRFbWFpbFdpdGhSZXRyeSA9IHJlcXVpcmUoJ0AvbGliL3NlcnZpY2VzL2VtYWlsLXNlcnZpY2UnKS5zZW5kRW1haWxXaXRoUmV0cnkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+O1xuY29uc3QgbW9ja0RiID0gcmVxdWlyZSgnQC9saWIvZGInKS5kYjtcbmNvbnN0IG1vY2tHZXRVc2VyQnlFbWFpbCA9IHJlcXVpcmUoJ0AvbGliL2F1dGgnKS5nZXRVc2VyQnlFbWFpbCBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT47XG5jb25zdCBtb2NrR2V0VXNlckJ5SWQgPSByZXF1aXJlKCdAL2xpYi9hdXRoJykuZ2V0VXNlckJ5SWQgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+O1xuXG4vLyBNb2NrIGVudmlyb25tZW50IHZhcmlhYmxlc1xuY29uc3Qgb3JpZ2luYWxFbnYgPSBwcm9jZXNzLmVudjtcblxuYmVmb3JlQWxsKCgpID0+IHtcbiAgcHJvY2Vzcy5lbnYgPSB7XG4gICAgLi4ub3JpZ2luYWxFbnYsXG4gICAgUkVTRU5EX0FQSV9LRVk6ICd0ZXN0LWFwaS1rZXknLFxuICAgIEZST01fRU1BSUw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICBGUk9NX05BTUU6ICdUZXN0IEFwcCcsXG4gICAgVkVSSUZJQ0FUSU9OX0NPREVfRVhQSVJZX01JTlVURVM6ICcxMCcsXG4gICAgTUFYX1ZFUklGSUNBVElPTl9BVFRFTVBUUzogJzUnLFxuICAgIFJFU0VORF9DT09MRE9XTl9TRUNPTkRTOiAnNjAnLFxuICAgIE1BWF9SRVNFTkRfUEVSX0hPVVI6ICc1JyxcbiAgICBOT0RFX0VOVjogJ3Rlc3QnLFxuICB9O1xufSk7XG5cbmFmdGVyQWxsKCgpID0+IHtcbiAgcHJvY2Vzcy5lbnYgPSBvcmlnaW5hbEVudjtcbn0pO1xuXG5kZXNjcmliZSgnRW1haWwgVmVyaWZpY2F0aW9uIEVycm9yIFNjZW5hcmlvIFRlc3RzJywgKCkgPT4ge1xuICBsZXQgZGJNYW5hZ2VyOiBhbnk7XG5cbiAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgZGJNYW5hZ2VyID0gY3JlYXRlRGF0YWJhc2VUZXN0TWFuYWdlcigpO1xuICAgIFxuICAgIC8vIERlZmF1bHQgdG8gc3VjY2Vzc2Z1bCBlbWFpbCBzZXJ2aWNlXG4gICAgbW9ja0NyZWF0ZUVtYWlsU2VydmljZS5tb2NrUmV0dXJuVmFsdWUobW9ja0VtYWlsU2VydmljZSk7XG4gICAgbW9ja1NlbmRFbWFpbFdpdGhSZXRyeS5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKTtcbiAgICBtb2NrRW1haWxTZXJ2aWNlLnNlbmRWZXJpZmljYXRpb25FbWFpbC5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBkYk1hbmFnZXIuY2xlYW51cCgpO1xuICB9KTtcblxuICBkZXNjcmliZSgnRW1haWwgU2VydmljZSBGYWlsdXJlIEhhbmRsaW5nIGFuZCBSZXRyeSBMb2dpYycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBlbWFpbCBzZXJ2aWNlIGVycm9ycyBkdXJpbmcgY29kZSBnZW5lcmF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBlbWFpbCBzZXJ2aWNlIHRvIGZhaWxcbiAgICAgIG1vY2tTZW5kRW1haWxXaXRoUmV0cnkubW9ja1JlamVjdGVkVmFsdWUobmV3IEVtYWlsU2VydmljZUVycm9yKCdRdW90YSBleGNlZWRlZCcsICdRVU9UQV9FWENFRURFRCcpKTtcblxuICAgICAgLy8gQ3JlYXRlIHVzZXJcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdFVzZXIoe1xuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAnVGVzdCBVc2VyJyxcbiAgICAgICAgcGFzc3dvcmRIYXNoOiAnaGFzaGVkX3Bhc3N3b3JkJyxcbiAgICAgICAgaXNFbWFpbFZlcmlmaWVkOiBmYWxzZSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBHZW5lcmF0ZSB2ZXJpZmljYXRpb24gY29kZSAoc2hvdWxkIHdvcmsgZXZlbiBpZiBlbWFpbCBmYWlscylcbiAgICAgIGNvbnN0IHZlcmlmaWNhdGlvbkNvZGUgPSBhd2FpdCBlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlLmdlbmVyYXRlQ29kZSh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdCh2ZXJpZmljYXRpb25Db2RlKS50b01hdGNoKC9eXFxkezZ9JC8pO1xuXG4gICAgICAvLyBWZXJpZnkgY29kZSB3YXMgc3RvcmVkIGluIGRhdGFiYXNlXG4gICAgICBjb25zdCBlbWFpbENvZGVzID0gYXdhaXQgZGJNYW5hZ2VyLmdldEVtYWlsQ29kZXNCeVVzZXJJZCh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdChlbWFpbENvZGVzKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QoZW1haWxDb2Rlc1swXS5jb2RlKS50b0JlKHZlcmlmaWNhdGlvbkNvZGUpO1xuXG4gICAgICAvLyBVc2VyIHNob3VsZCBzdGlsbCBiZSB1bnZlcmlmaWVkXG4gICAgICBjb25zdCB1bnZlcmlmaWVkVXNlciA9IGF3YWl0IGRiTWFuYWdlci5nZXRVc2VyQnlJZCh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdCh1bnZlcmlmaWVkVXNlci5pc0VtYWlsVmVyaWZpZWQpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZGlmZmVyZW50IHR5cGVzIG9mIGVtYWlsIHNlcnZpY2UgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0VXNlcih7XG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgICBwYXNzd29yZEhhc2g6ICdoYXNoZWRfcGFzc3dvcmQnLFxuICAgICAgICBpc0VtYWlsVmVyaWZpZWQ6IGZhbHNlLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFRlc3QgQVBJIGVycm9yXG4gICAgICBtb2NrU2VuZEVtYWlsV2l0aFJldHJ5Lm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFbWFpbFNlcnZpY2VFcnJvcignQVBJIGVycm9yJywgJ0FQSV9FUlJPUicpKTtcbiAgICAgIGNvbnN0IGNvZGUxID0gYXdhaXQgZW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS5nZW5lcmF0ZUNvZGUodXNlci5pZCk7XG4gICAgICBleHBlY3QoY29kZTEpLnRvTWF0Y2goL15cXGR7Nn0kLyk7XG5cbiAgICAgIC8vIFRlc3QgbmV0d29yayBlcnJvclxuICAgICAgbW9ja1NlbmRFbWFpbFdpdGhSZXRyeS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRW1haWxTZXJ2aWNlRXJyb3IoJ05ldHdvcmsgdGltZW91dCcsICdORVRXT1JLX0VSUk9SJykpO1xuICAgICAgY29uc3QgY29kZTIgPSBhd2FpdCBlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlLmdlbmVyYXRlQ29kZSh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdChjb2RlMikudG9NYXRjaCgvXlxcZHs2fSQvKTtcbiAgICAgIGV4cGVjdChjb2RlMikubm90LnRvQmUoY29kZTEpOyAvLyBTaG91bGQgYmUgZGlmZmVyZW50IGNvZGVcblxuICAgICAgLy8gVmVyaWZ5IG9ubHkgbGF0ZXN0IGNvZGUgZXhpc3RzXG4gICAgICBjb25zdCBlbWFpbENvZGVzID0gYXdhaXQgZGJNYW5hZ2VyLmdldEVtYWlsQ29kZXNCeVVzZXJJZCh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdChlbWFpbENvZGVzKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QoZW1haWxDb2Rlc1swXS5jb2RlKS50b0JlKGNvZGUyKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGVtYWlsIHNlcnZpY2UgZXJyb3JzIGJ1dCBzdGlsbCBnZW5lcmF0ZSBjb2RlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdFVzZXIoe1xuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAnVGVzdCBVc2VyJyxcbiAgICAgICAgcGFzc3dvcmRIYXNoOiAnaGFzaGVkX3Bhc3N3b3JkJyxcbiAgICAgICAgaXNFbWFpbFZlcmlmaWVkOiBmYWxzZSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNb2NrIHZhcmlvdXMgZW1haWwgc2VydmljZSBlcnJvcnNcbiAgICAgIG1vY2tTZW5kRW1haWxXaXRoUmV0cnkubW9ja1JlamVjdGVkVmFsdWUobmV3IEVtYWlsU2VydmljZUVycm9yKCdJbnZhbGlkIGVtYWlsJywgJ0lOVkFMSURfRU1BSUwnKSk7XG4gICAgICBcbiAgICAgIC8vIENvZGUgZ2VuZXJhdGlvbiBzaG91bGQgc3RpbGwgd29ya1xuICAgICAgY29uc3QgY29kZSA9IGF3YWl0IGVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UuZ2VuZXJhdGVDb2RlKHVzZXIuaWQpO1xuICAgICAgZXhwZWN0KGNvZGUpLnRvTWF0Y2goL15cXGR7Nn0kLyk7XG5cbiAgICAgIC8vIFZlcmlmeSBjb2RlIHdhcyBzdG9yZWRcbiAgICAgIGNvbnN0IGVtYWlsQ29kZXMgPSBhd2FpdCBkYk1hbmFnZXIuZ2V0RW1haWxDb2Rlc0J5VXNlcklkKHVzZXIuaWQpO1xuICAgICAgZXhwZWN0KGVtYWlsQ29kZXMpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChlbWFpbENvZGVzWzBdLmNvZGUpLnRvQmUoY29kZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFeHBpcmVkIENvZGUgU2NlbmFyaW9zIGFuZCBDbGVhbnVwIFByb2Nlc3NlcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBleHBpcmVkIHZlcmlmaWNhdGlvbiBjb2RlcyBwcm9wZXJseScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSB1c2VyIHdpdGggZXhwaXJlZCB2ZXJpZmljYXRpb24gY29kZVxuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0VXNlcih7XG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgICBwYXNzd29yZEhhc2g6ICdoYXNoZWRfcGFzc3dvcmQnLFxuICAgICAgICBpc0VtYWlsVmVyaWZpZWQ6IGZhbHNlLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGV4cGlyZWRDb2RlID0gYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RFbWFpbENvZGUoe1xuICAgICAgICB1c2VySWQ6IHVzZXIuaWQsXG4gICAgICAgIGNvZGU6ICcxMjM0NTYnLFxuICAgICAgICBleHBpcmVzQXQ6IG5ldyBEYXRlKERhdGUubm93KCkgLSA2MDAwMCksIC8vIEV4cGlyZWQgMSBtaW51dGUgYWdvXG4gICAgICAgIGF0dGVtcHRzVXNlZDogMCxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBUcnkgdG8gdmVyaWZ5IHdpdGggZXhwaXJlZCBjb2RlIHVzaW5nIHNlcnZpY2VcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UudmFsaWRhdGVDb2RlKCd0ZXN0QGV4YW1wbGUuY29tJywgJzEyMzQ1NicpO1xuICAgICAgICBmYWlsKCdTaG91bGQgaGF2ZSB0aHJvd24gYW4gZXJyb3IgZm9yIGV4cGlyZWQgY29kZScpO1xuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBleHBlY3QoZXJyb3IuY29kZSkudG9CZSgnQ09ERV9FWFBJUkVEJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFZlcmlmeSB1c2VyIGlzIHN0aWxsIG5vdCB2ZXJpZmllZFxuICAgICAgY29uc3QgdW52ZXJpZmllZFVzZXIgPSBhd2FpdCBkYk1hbmFnZXIuZ2V0VXNlckJ5SWQodXNlci5pZCk7XG4gICAgICBleHBlY3QodW52ZXJpZmllZFVzZXIuaXNFbWFpbFZlcmlmaWVkKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY2xlYW4gdXAgZXhwaXJlZCBjb2RlcyBkdXJpbmcgdmVyaWZpY2F0aW9uIHNlcnZpY2Ugb3BlcmF0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSB1c2VyIHdpdGggbXVsdGlwbGUgY29kZXMsIHNvbWUgZXhwaXJlZFxuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0VXNlcih7XG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgICBwYXNzd29yZEhhc2g6ICdoYXNoZWRfcGFzc3dvcmQnLFxuICAgICAgICBpc0VtYWlsVmVyaWZpZWQ6IGZhbHNlLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIENyZWF0ZSBleHBpcmVkIGNvZGVcbiAgICAgIGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0RW1haWxDb2RlKHtcbiAgICAgICAgdXNlcklkOiB1c2VyLmlkLFxuICAgICAgICBjb2RlOiAnMTExMTExJyxcbiAgICAgICAgZXhwaXJlc0F0OiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gNjAwMDApLCAvLyBFeHBpcmVkXG4gICAgICAgIGF0dGVtcHRzVXNlZDogMCxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBDcmVhdGUgdmFsaWQgY29kZVxuICAgICAgYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RFbWFpbENvZGUoe1xuICAgICAgICB1c2VySWQ6IHVzZXIuaWQsXG4gICAgICAgIGNvZGU6ICcyMjIyMjInLFxuICAgICAgICBleHBpcmVzQXQ6IG5ldyBEYXRlKERhdGUubm93KCkgKyA2MDAwMDApLCAvLyBWYWxpZCBmb3IgMTAgbWludXRlc1xuICAgICAgICBhdHRlbXB0c1VzZWQ6IDAsXG4gICAgICB9KTtcblxuICAgICAgLy8gVHJpZ2dlciBjbGVhbnVwIGJ5IGNhbGxpbmcgdGhlIHNlcnZpY2UgbWV0aG9kXG4gICAgICBhd2FpdCBlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlLmNsZWFudXBFeHBpcmVkQ29kZXMoKTtcblxuICAgICAgLy8gVmVyaWZ5IGV4cGlyZWQgY29kZSB3YXMgY2xlYW5lZCB1cFxuICAgICAgY29uc3QgcmVtYWluaW5nQ29kZXMgPSBhd2FpdCBkYk1hbmFnZXIuZ2V0RW1haWxDb2Rlc0J5VXNlcklkKHVzZXIuaWQpO1xuICAgICAgZXhwZWN0KHJlbWFpbmluZ0NvZGVzKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QocmVtYWluaW5nQ29kZXNbMF0uY29kZSkudG9CZSgnMjIyMjIyJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjbGVhbnVwIHdoZW4gdXNlciBpcyBkZWxldGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIHVzZXIgd2l0aCB2ZXJpZmljYXRpb24gY29kZXNcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdFVzZXIoe1xuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAnVGVzdCBVc2VyJyxcbiAgICAgICAgcGFzc3dvcmRIYXNoOiAnaGFzaGVkX3Bhc3N3b3JkJyxcbiAgICAgICAgaXNFbWFpbFZlcmlmaWVkOiBmYWxzZSxcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdEVtYWlsQ29kZSh7XG4gICAgICAgIHVzZXJJZDogdXNlci5pZCxcbiAgICAgICAgY29kZTogJzEyMzQ1NicsXG4gICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIDYwMDAwMCksXG4gICAgICAgIGF0dGVtcHRzVXNlZDogMCxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBWZXJpZnkgY29kZSBleGlzdHNcbiAgICAgIGxldCBlbWFpbENvZGVzID0gYXdhaXQgZGJNYW5hZ2VyLmdldEVtYWlsQ29kZXNCeVVzZXJJZCh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdChlbWFpbENvZGVzKS50b0hhdmVMZW5ndGgoMSk7XG5cbiAgICAgIC8vIERlbGV0ZSB1c2VyIChzaG91bGQgY2FzY2FkZSBkZWxldGUgY29kZXMgZHVlIHRvIGZvcmVpZ24ga2V5IGNvbnN0cmFpbnQpXG4gICAgICBhd2FpdCBkYk1hbmFnZXIuZGVsZXRlVXNlcih1c2VyLmlkKTtcblxuICAgICAgLy8gVmVyaWZ5IGNvZGVzIHdlcmUgY2xlYW5lZCB1cFxuICAgICAgZW1haWxDb2RlcyA9IGF3YWl0IGRiTWFuYWdlci5nZXRFbWFpbENvZGVzQnlVc2VySWQodXNlci5pZCk7XG4gICAgICBleHBlY3QoZW1haWxDb2RlcykudG9IYXZlTGVuZ3RoKDApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbXVsdGlwbGUgZXhwaXJlZCBjb2RlcyBmb3Igc2FtZSB1c2VyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIHVzZXIgd2l0aCBtdWx0aXBsZSBleHBpcmVkIGNvZGVzXG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RVc2VyKHtcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgICAgIHBhc3N3b3JkSGFzaDogJ2hhc2hlZF9wYXNzd29yZCcsXG4gICAgICAgIGlzRW1haWxWZXJpZmllZDogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgLy8gQ3JlYXRlIG11bHRpcGxlIGV4cGlyZWQgY29kZXNcbiAgICAgIGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0RW1haWxDb2RlKHtcbiAgICAgICAgdXNlcklkOiB1c2VyLmlkLFxuICAgICAgICBjb2RlOiAnMTExMTExJyxcbiAgICAgICAgZXhwaXJlc0F0OiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gMTIwMDAwKSwgLy8gRXhwaXJlZCAyIG1pbnV0ZXMgYWdvXG4gICAgICAgIGF0dGVtcHRzVXNlZDogMCxcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdEVtYWlsQ29kZSh7XG4gICAgICAgIHVzZXJJZDogdXNlci5pZCxcbiAgICAgICAgY29kZTogJzIyMjIyMicsXG4gICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDYwMDAwKSwgLy8gRXhwaXJlZCAxIG1pbnV0ZSBhZ29cbiAgICAgICAgYXR0ZW1wdHNVc2VkOiAwLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFRyeSB0byB2ZXJpZnkgd2l0aCBvbmUgb2YgdGhlIGV4cGlyZWQgY29kZXNcbiAgICAgIGNvbnN0IHZlcmlmeVJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3QvYXBpL2F1dGgvdmVyaWZ5LWVtYWlsJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgY29kZTogJzExMTExMScsXG4gICAgICAgIH0pLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB2ZXJpZnlSZXNwb25zZSA9IGF3YWl0IHZlcmlmeUVtYWlsSGFuZGxlcih2ZXJpZnlSZXF1ZXN0KTtcbiAgICAgIGNvbnN0IHZlcmlmeURhdGEgPSBhd2FpdCB2ZXJpZnlSZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIC8vIEFzc2VydCBleHBpcmVkIGNvZGUgZXJyb3JcbiAgICAgIGV4cGVjdCh2ZXJpZnlSZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAwKTtcbiAgICAgIGV4cGVjdCh2ZXJpZnlEYXRhLmVycm9yKS50b0NvbnRhaW4oJ1ZlcmlmaWNhdGlvbiBjb2RlIGhhcyBleHBpcmVkJyk7XG5cbiAgICAgIC8vIENsZWFudXAgZXhwaXJlZCBjb2Rlc1xuICAgICAgYXdhaXQgZW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS5jbGVhbnVwRXhwaXJlZENvZGVzKCk7XG5cbiAgICAgIC8vIFZlcmlmeSBhbGwgZXhwaXJlZCBjb2RlcyB3ZXJlIGNsZWFuZWQgdXBcbiAgICAgIGNvbnN0IHJlbWFpbmluZ0NvZGVzID0gYXdhaXQgZGJNYW5hZ2VyLmdldEVtYWlsQ29kZXNCeVVzZXJJZCh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdChyZW1haW5pbmdDb2RlcykudG9IYXZlTGVuZ3RoKDApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ29uY3VycmVudCBWZXJpZmljYXRpb24gQXR0ZW1wdHMgYW5kIFJhY2UgQ29uZGl0aW9ucycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjb25jdXJyZW50IHZlcmlmaWNhdGlvbiBhdHRlbXB0cyBzYWZlbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBDcmVhdGUgdXNlciB3aXRoIHZlcmlmaWNhdGlvbiBjb2RlXG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RVc2VyKHtcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgICAgIHBhc3N3b3JkSGFzaDogJ2hhc2hlZF9wYXNzd29yZCcsXG4gICAgICAgIGlzRW1haWxWZXJpZmllZDogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RFbWFpbENvZGUoe1xuICAgICAgICB1c2VySWQ6IHVzZXIuaWQsXG4gICAgICAgIGNvZGU6ICcxMjM0NTYnLFxuICAgICAgICBleHBpcmVzQXQ6IG5ldyBEYXRlKERhdGUubm93KCkgKyA2MDAwMDApLFxuICAgICAgICBhdHRlbXB0c1VzZWQ6IDAsXG4gICAgICB9KTtcblxuICAgICAgLy8gRXhlY3V0ZSBjb25jdXJyZW50IHZlcmlmaWNhdGlvbiBhdHRlbXB0c1xuICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXG4gICAgICAgIGVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UudmFsaWRhdGVDb2RlKCd0ZXN0QGV4YW1wbGUuY29tJywgJzEyMzQ1NicpLFxuICAgICAgICBlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlLnZhbGlkYXRlQ29kZSgndGVzdEBleGFtcGxlLmNvbScsICcxMjM0NTYnKSxcbiAgICAgIF07XG5cbiAgICAgIC8vIE9uZSBzaG91bGQgc3VjY2VlZCwgb25lIHNob3VsZCBmYWlsXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKHByb21pc2VzKTtcbiAgICAgIFxuICAgICAgY29uc3Qgc3VjY2Vzc0NvdW50ID0gcmVzdWx0cy5maWx0ZXIociA9PiByLnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcgJiYgci52YWx1ZSA9PT0gdHJ1ZSkubGVuZ3RoO1xuICAgICAgY29uc3QgZmFpbHVyZUNvdW50ID0gcmVzdWx0cy5maWx0ZXIociA9PiByLnN0YXR1cyA9PT0gJ3JlamVjdGVkJykubGVuZ3RoO1xuXG4gICAgICAvLyBBdCBsZWFzdCBvbmUgc2hvdWxkIHN1Y2NlZWQsIGFuZCB0aGVyZSBtaWdodCBiZSBmYWlsdXJlcyBkdWUgdG8gcmFjZSBjb25kaXRpb25zXG4gICAgICBleHBlY3Qoc3VjY2Vzc0NvdW50KS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDEpO1xuXG4gICAgICAvLyBWZXJpZnkgdXNlciBpcyB2ZXJpZmllZFxuICAgICAgY29uc3QgdmVyaWZpZWRVc2VyID0gYXdhaXQgZGJNYW5hZ2VyLmdldFVzZXJCeUlkKHVzZXIuaWQpO1xuICAgICAgZXhwZWN0KHZlcmlmaWVkVXNlci5pc0VtYWlsVmVyaWZpZWQpLnRvQmUodHJ1ZSk7XG5cbiAgICAgIC8vIFZlcmlmeSBjb2RlIHdhcyBkZWxldGVkXG4gICAgICBjb25zdCByZW1haW5pbmdDb2RlcyA9IGF3YWl0IGRiTWFuYWdlci5nZXRFbWFpbENvZGVzQnlVc2VySWQodXNlci5pZCk7XG4gICAgICBleHBlY3QocmVtYWluaW5nQ29kZXMpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNvbmN1cnJlbnQgY29kZSBnZW5lcmF0aW9uIHJlcXVlc3RzIHNhZmVseScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSB1c2VyXG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RVc2VyKHtcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgICAgIHBhc3N3b3JkSGFzaDogJ2hhc2hlZF9wYXNzd29yZCcsXG4gICAgICAgIGlzRW1haWxWZXJpZmllZDogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgLy8gRXhlY3V0ZSBjb25jdXJyZW50IGNvZGUgZ2VuZXJhdGlvbiByZXF1ZXN0c1xuICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXG4gICAgICAgIGVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UuZ2VuZXJhdGVDb2RlKHVzZXIuaWQpLFxuICAgICAgICBlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlLmdlbmVyYXRlQ29kZSh1c2VyLmlkKSxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IGNvZGVzID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuXG4gICAgICAvLyBCb3RoIHNob3VsZCBzdWNjZWVkIGFuZCByZXR1cm4gdmFsaWQgY29kZXNcbiAgICAgIGV4cGVjdChjb2Rlc1swXSkudG9NYXRjaCgvXlxcZHs2fSQvKTtcbiAgICAgIGV4cGVjdChjb2Rlc1sxXSkudG9NYXRjaCgvXlxcZHs2fSQvKTtcblxuICAgICAgLy8gVmVyaWZ5IG9ubHkgb25lIGNvZGUgZXhpc3RzIChsYXRlc3Qgb25lKVxuICAgICAgY29uc3QgZW1haWxDb2RlcyA9IGF3YWl0IGRiTWFuYWdlci5nZXRFbWFpbENvZGVzQnlVc2VySWQodXNlci5pZCk7XG4gICAgICBleHBlY3QoZW1haWxDb2RlcykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgXG4gICAgICAvLyBUaGUgcmVtYWluaW5nIGNvZGUgc2hvdWxkIGJlIG9uZSBvZiB0aGUgZ2VuZXJhdGVkIGNvZGVzXG4gICAgICBleHBlY3QoW2NvZGVzWzBdLCBjb2Rlc1sxXV0pLnRvQ29udGFpbihlbWFpbENvZGVzWzBdLmNvZGUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgcmFjZSBjb25kaXRpb24gYmV0d2VlbiB2ZXJpZmljYXRpb24gYW5kIGNvZGUgZXhwaXJhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSB1c2VyIHdpdGggY29kZSB0aGF0IGV4cGlyZXMgdmVyeSBzb29uXG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RVc2VyKHtcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgICAgIHBhc3N3b3JkSGFzaDogJ2hhc2hlZF9wYXNzd29yZCcsXG4gICAgICAgIGlzRW1haWxWZXJpZmllZDogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RFbWFpbENvZGUoe1xuICAgICAgICB1c2VySWQ6IHVzZXIuaWQsXG4gICAgICAgIGNvZGU6ICcxMjM0NTYnLFxuICAgICAgICBleHBpcmVzQXQ6IG5ldyBEYXRlKERhdGUubm93KCkgKyAxMDApLCAvLyBFeHBpcmVzIGluIDEwMG1zXG4gICAgICAgIGF0dGVtcHRzVXNlZDogMCxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBXYWl0IGZvciBjb2RlIHRvIGV4cGlyZVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDE1MCkpO1xuXG4gICAgICAvLyBUcnkgdG8gdmVyaWZ5IHdpdGggZXhwaXJlZCBjb2RlIHVzaW5nIHNlcnZpY2VcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UudmFsaWRhdGVDb2RlKCd0ZXN0QGV4YW1wbGUuY29tJywgJzEyMzQ1NicpO1xuICAgICAgICBmYWlsKCdTaG91bGQgaGF2ZSB0aHJvd24gYW4gZXJyb3IgZm9yIGV4cGlyZWQgY29kZScpO1xuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBleHBlY3QoZXJyb3IuY29kZSkudG9CZSgnQ09ERV9FWFBJUkVEJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVzZXIgc2hvdWxkIHJlbWFpbiB1bnZlcmlmaWVkXG4gICAgICBjb25zdCB1bnZlcmlmaWVkVXNlciA9IGF3YWl0IGRiTWFuYWdlci5nZXRVc2VyQnlJZCh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdCh1bnZlcmlmaWVkVXNlci5pc0VtYWlsVmVyaWZpZWQpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY29uY3VycmVudCBjb2RlIGdlbmVyYXRpb24gZm9yIHNhbWUgdXNlcicsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSB1c2VyXG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RVc2VyKHtcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgICAgIHBhc3N3b3JkSGFzaDogJ2hhc2hlZF9wYXNzd29yZCcsXG4gICAgICAgIGlzRW1haWxWZXJpZmllZDogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgLy8gRXhlY3V0ZSBtdWx0aXBsZSBjb25jdXJyZW50IGNvZGUgZ2VuZXJhdGlvbiByZXF1ZXN0c1xuICAgICAgY29uc3QgcHJvbWlzZXMgPSBBcnJheSg1KS5maWxsKG51bGwpLm1hcCgoKSA9PiBcbiAgICAgICAgZW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS5nZW5lcmF0ZUNvZGUodXNlci5pZClcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGNvZGVzID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuXG4gICAgICAvLyBBbGwgc2hvdWxkIHN1Y2NlZWQgYW5kIHJldHVybiB2YWxpZCBjb2Rlc1xuICAgICAgY29kZXMuZm9yRWFjaChjb2RlID0+IHtcbiAgICAgICAgZXhwZWN0KGNvZGUpLnRvTWF0Y2goL15cXGR7Nn0kLyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gVmVyaWZ5IG9ubHkgb25lIGNvZGUgZXhpc3RzIChsYXRlc3Qgb25lKVxuICAgICAgY29uc3QgZW1haWxDb2RlcyA9IGF3YWl0IGRiTWFuYWdlci5nZXRFbWFpbENvZGVzQnlVc2VySWQodXNlci5pZCk7XG4gICAgICBleHBlY3QoZW1haWxDb2RlcykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgXG4gICAgICAvLyBUaGUgcmVtYWluaW5nIGNvZGUgc2hvdWxkIGJlIG9uZSBvZiB0aGUgZ2VuZXJhdGVkIGNvZGVzXG4gICAgICBleHBlY3QoY29kZXMpLnRvQ29udGFpbihlbWFpbENvZGVzWzBdLmNvZGUpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRGF0YWJhc2UgRXJyb3IgU2NlbmFyaW9zJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIG1heGltdW0gYXR0ZW1wdHMgcmVhY2hlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdFVzZXIoe1xuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAnVGVzdCBVc2VyJyxcbiAgICAgICAgcGFzc3dvcmRIYXNoOiAnaGFzaGVkX3Bhc3N3b3JkJyxcbiAgICAgICAgaXNFbWFpbFZlcmlmaWVkOiBmYWxzZSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBDcmVhdGUgY29kZSB3aXRoIG1heGltdW0gYXR0ZW1wdHMgcmVhY2hlZFxuICAgICAgYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RFbWFpbENvZGUoe1xuICAgICAgICB1c2VySWQ6IHVzZXIuaWQsXG4gICAgICAgIGNvZGU6ICcxMjM0NTYnLFxuICAgICAgICBleHBpcmVzQXQ6IG5ldyBEYXRlKERhdGUubm93KCkgKyA2MDAwMDApLFxuICAgICAgICBhdHRlbXB0c1VzZWQ6IDUsIC8vIE1heGltdW0gYXR0ZW1wdHMgcmVhY2hlZFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFRyeSB0byB2ZXJpZnkgd2l0aCBtYXggYXR0ZW1wdHMgcmVhY2hlZFxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS52YWxpZGF0ZUNvZGUoJ3Rlc3RAZXhhbXBsZS5jb20nLCAnMTIzNDU2Jyk7XG4gICAgICAgIGZhaWwoJ1Nob3VsZCBoYXZlIHRocm93biBhbiBlcnJvciBmb3IgdG9vIG1hbnkgYXR0ZW1wdHMnKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgZXhwZWN0KGVycm9yLmNvZGUpLnRvQmUoJ1RPT19NQU5ZX0FUVEVNUFRTJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVzZXIgc2hvdWxkIHJlbWFpbiB1bnZlcmlmaWVkXG4gICAgICBjb25zdCB1bnZlcmlmaWVkVXNlciA9IGF3YWl0IGRiTWFuYWdlci5nZXRVc2VyQnlJZCh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdCh1bnZlcmlmaWVkVXNlci5pc0VtYWlsVmVyaWZpZWQpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgc2VydmljZSBlcnJvcnMgZHVyaW5nIHZhbGlkYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBUZXN0IHdpdGggbm9uLWV4aXN0ZW50IHVzZXJcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UudmFsaWRhdGVDb2RlKCdub25leGlzdGVudEBleGFtcGxlLmNvbScsICcxMjM0NTYnKTtcbiAgICAgICAgZmFpbCgnU2hvdWxkIGhhdmUgdGhyb3duIGFuIGVycm9yIGZvciBub24tZXhpc3RlbnQgdXNlcicpO1xuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBleHBlY3QoZXJyb3IuY29kZSkudG9CZSgnVVNFUl9OT1RfRk9VTkQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59KTsiXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJkYiIsInNlbGVjdCIsImZuIiwibW9ja1JldHVyblRoaXMiLCJmcm9tIiwid2hlcmUiLCJpbnNlcnQiLCJ2YWx1ZXMiLCJ1cGRhdGUiLCJzZXQiLCJkZWxldGUiLCJyZXR1cm5pbmciLCJleGVjdXRlIiwiZ2V0VXNlckJ5RW1haWwiLCJnZXRVc2VyQnlJZCIsIm1vY2tFbWFpbFNlcnZpY2UiLCJzZW5kVmVyaWZpY2F0aW9uRW1haWwiLCJtb2NrQ3JlYXRlRW1haWxTZXJ2aWNlIiwiY3JlYXRlRW1haWxTZXJ2aWNlIiwibW9ja1NlbmRFbWFpbFdpdGhSZXRyeSIsInJlcXVpcmUiLCJzZW5kRW1haWxXaXRoUmV0cnkiLCJtb2NrRGIiLCJtb2NrR2V0VXNlckJ5RW1haWwiLCJtb2NrR2V0VXNlckJ5SWQiLCJvcmlnaW5hbEVudiIsInByb2Nlc3MiLCJlbnYiLCJiZWZvcmVBbGwiLCJSRVNFTkRfQVBJX0tFWSIsIkZST01fRU1BSUwiLCJGUk9NX05BTUUiLCJWRVJJRklDQVRJT05fQ09ERV9FWFBJUllfTUlOVVRFUyIsIk1BWF9WRVJJRklDQVRJT05fQVRURU1QVFMiLCJSRVNFTkRfQ09PTERPV05fU0VDT05EUyIsIk1BWF9SRVNFTkRfUEVSX0hPVVIiLCJOT0RFX0VOViIsImFmdGVyQWxsIiwiZGVzY3JpYmUiLCJkYk1hbmFnZXIiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsImNyZWF0ZURhdGFiYXNlVGVzdE1hbmFnZXIiLCJtb2NrUmV0dXJuVmFsdWUiLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsImFmdGVyRWFjaCIsImNsZWFudXAiLCJpdCIsIm1vY2tSZWplY3RlZFZhbHVlIiwiRW1haWxTZXJ2aWNlRXJyb3IiLCJ1c2VyIiwiY3JlYXRlVGVzdFVzZXIiLCJlbWFpbCIsIm5hbWUiLCJwYXNzd29yZEhhc2giLCJpc0VtYWlsVmVyaWZpZWQiLCJ2ZXJpZmljYXRpb25Db2RlIiwiZW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZSIsImdlbmVyYXRlQ29kZSIsImlkIiwiZXhwZWN0IiwidG9NYXRjaCIsImVtYWlsQ29kZXMiLCJnZXRFbWFpbENvZGVzQnlVc2VySWQiLCJ0b0hhdmVMZW5ndGgiLCJjb2RlIiwidG9CZSIsInVudmVyaWZpZWRVc2VyIiwiY29kZTEiLCJjb2RlMiIsIm5vdCIsImV4cGlyZWRDb2RlIiwiY3JlYXRlVGVzdEVtYWlsQ29kZSIsInVzZXJJZCIsImV4cGlyZXNBdCIsIkRhdGUiLCJub3ciLCJhdHRlbXB0c1VzZWQiLCJ2YWxpZGF0ZUNvZGUiLCJmYWlsIiwiZXJyb3IiLCJjbGVhbnVwRXhwaXJlZENvZGVzIiwicmVtYWluaW5nQ29kZXMiLCJkZWxldGVVc2VyIiwidmVyaWZ5UmVxdWVzdCIsIk5leHRSZXF1ZXN0IiwibWV0aG9kIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJoZWFkZXJzIiwidmVyaWZ5UmVzcG9uc2UiLCJ2ZXJpZnlFbWFpbEhhbmRsZXIiLCJ2ZXJpZnlEYXRhIiwianNvbiIsInN0YXR1cyIsInRvQ29udGFpbiIsInByb21pc2VzIiwicmVzdWx0cyIsIlByb21pc2UiLCJhbGxTZXR0bGVkIiwic3VjY2Vzc0NvdW50IiwiZmlsdGVyIiwiciIsInZhbHVlIiwibGVuZ3RoIiwiZmFpbHVyZUNvdW50IiwidG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCIsInZlcmlmaWVkVXNlciIsImNvZGVzIiwiYWxsIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJBcnJheSIsImZpbGwiLCJtYXAiLCJmb3JFYWNoIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Q0FLQztBQU1ELHlDQUF5QztBQUN6Q0EsS0FBS0MsSUFBSSxDQUFDO0FBQ1ZELEtBQUtDLElBQUksQ0FBQztBQUVWLGdCQUFnQjtBQUNoQkQsS0FBS0MsSUFBSSxDQUFDLFlBQVksSUFBTyxDQUFBO1FBQzNCQyxJQUFJO1lBQ0ZDLFFBQVFILEtBQUtJLEVBQUUsR0FBR0MsY0FBYztZQUNoQ0MsTUFBTU4sS0FBS0ksRUFBRSxH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