8aa9ecdc5650077174d586f0da59e311
/**
 * Email Verification Error Scenario Tests
 * Tests email service failure handling, retry logic, expired code scenarios, 
 * cleanup processes, and concurrent verification attempts
 * Requirements: 1.4, 3.1, 7.3, 7.4
 */ "use strict";
// Mock email service and related modules
jest.mock('@/lib/services/resend-email-service');
jest.mock('@/lib/services/email-service');
// Mock database
jest.mock('@/lib/db', ()=>({
        db: {
            select: jest.fn().mockReturnThis(),
            from: jest.fn().mockReturnThis(),
            where: jest.fn().mockReturnThis(),
            insert: jest.fn().mockReturnThis(),
            values: jest.fn().mockReturnThis(),
            update: jest.fn().mockReturnThis(),
            set: jest.fn().mockReturnThis(),
            delete: jest.fn().mockReturnThis(),
            returning: jest.fn(),
            execute: jest.fn()
        }
    }));
// Mock auth functions
jest.mock('@/lib/auth', ()=>({
        getUserByEmail: jest.fn(),
        getUserById: jest.fn()
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _emailverificationcodeservice = require("../../lib/services/email-verification-code-service");
const _resendemailservice = require("../../lib/services/resend-email-service");
const _emailservice = require("../../lib/services/email-service");
const mockEmailService = {
    sendVerificationEmail: jest.fn()
};
const mockCreateEmailService = _resendemailservice.createEmailService;
const mockSendEmailWithRetry = require('@/lib/services/email-service').sendEmailWithRetry;
const mockDb = require('@/lib/db').db;
const mockGetUserByEmail = require('@/lib/auth').getUserByEmail;
const mockGetUserById = require('@/lib/auth').getUserById;
// Mock environment variables
const originalEnv = process.env;
beforeAll(()=>{
    process.env = {
        ...originalEnv,
        RESEND_API_KEY: 'test-api-key',
        FROM_EMAIL: 'test@example.com',
        FROM_NAME: 'Test App',
        VERIFICATION_CODE_EXPIRY_MINUTES: '10',
        MAX_VERIFICATION_ATTEMPTS: '5',
        RESEND_COOLDOWN_SECONDS: '60',
        MAX_RESEND_PER_HOUR: '5',
        NODE_ENV: 'test'
    };
});
afterAll(()=>{
    process.env = originalEnv;
});
describe('Email Verification Error Scenario Tests', ()=>{
    beforeEach(async ()=>{
        jest.clearAllMocks();
        // Default to successful email service
        mockCreateEmailService.mockReturnValue(mockEmailService);
        mockSendEmailWithRetry.mockResolvedValue(true);
        mockEmailService.sendVerificationEmail.mockResolvedValue(true);
        // Setup default database mocks
        mockDb.returning.mockResolvedValue([]);
        mockDb.execute.mockResolvedValue([]);
    });
    describe('Email Service Failure Handling and Retry Logic', ()=>{
        it('should handle email service errors during code generation', async ()=>{
            // Mock email service to fail
            mockSendEmailWithRetry.mockRejectedValue(new _emailservice.EmailServiceError('Quota exceeded', 'QUOTA_EXCEEDED'));
            // Mock user data
            const mockUser = {
                id: 1,
                email: 'test@example.com',
                name: 'Test User',
                isEmailVerified: false
            };
            // Mock user lookup
            mockGetUserById.mockResolvedValue(mockUser);
            // Mock code insertion
            mockDb.returning.mockResolvedValueOnce([
                {
                    id: 1,
                    code: '123456',
                    userId: 1
                }
            ]);
            // Generate verification code (should work even if email fails)
            const verificationCode = await _emailverificationcodeservice.emailVerificationCodeService.generateCode(mockUser.id);
            expect(verificationCode).toMatch(/^\d{6}$/);
            // Verify database operations were called
            expect(mockDb.insert).toHaveBeenCalled();
        });
        it('should handle different types of email service errors', async ()=>{
            // Mock user data
            const mockUser = {
                id: 1,
                email: 'test@example.com',
                name: 'Test User',
                isEmailVerified: false
            };
            // Mock user lookup
            mockGetUserById.mockResolvedValue(mockUser);
            // Test API error
            mockSendEmailWithRetry.mockRejectedValue(new _emailservice.EmailServiceError('API error', 'API_ERROR'));
            mockDb.returning.mockResolvedValueOnce([
                {
                    id: 1,
                    code: '123456',
                    userId: 1
                }
            ]);
            const code1 = await _emailverificationcodeservice.emailVerificationCodeService.generateCode(mockUser.id);
            expect(code1).toMatch(/^\d{6}$/);
            // Test network error
            mockSendEmailWithRetry.mockRejectedValue(new _emailservice.EmailServiceError('Network timeout', 'NETWORK_ERROR'));
            mockDb.returning.mockResolvedValueOnce([
                {
                    id: 2,
                    code: '654321',
                    userId: 1
                }
            ]);
            const code2 = await _emailverificationcodeservice.emailVerificationCodeService.generateCode(mockUser.id);
            expect(code2).toMatch(/^\d{6}$/);
            expect(code2).not.toBe(code1); // Should be different code
            // Verify database operations were called
            expect(mockDb.insert).toHaveBeenCalledTimes(2);
        });
    });
    describe('Expired Code Scenarios and Cleanup Processes', ()=>{
        it('should handle expired verification codes properly', async ()=>{
            // Create user with expired verification code
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            const expiredCode = await dbManager.createTestEmailCode({
                userId: user.id,
                code: '123456',
                expiresAt: new Date(Date.now() - 60000),
                attemptsUsed: 0
            });
            // Try to verify with expired code using service
            try {
                await _emailverificationcodeservice.emailVerificationCodeService.validateCode('test@example.com', '123456');
                fail('Should have thrown an error for expired code');
            } catch (error) {
                expect(error.code).toBe('CODE_EXPIRED');
            }
            // Verify user is still not verified
            const unverifiedUser = await dbManager.getUserById(user.id);
            expect(unverifiedUser.isEmailVerified).toBe(false);
        });
        it('should clean up expired codes during verification service operations', async ()=>{
            // Create user with multiple codes, some expired
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Create expired code
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '111111',
                expiresAt: new Date(Date.now() - 60000),
                attemptsUsed: 0
            });
            // Create valid code
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '222222',
                expiresAt: new Date(Date.now() + 600000),
                attemptsUsed: 0
            });
            // Trigger cleanup by calling the service method
            await _emailverificationcodeservice.emailVerificationCodeService.cleanupExpiredCodes();
            // Verify expired code was cleaned up
            const remainingCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(remainingCodes).toHaveLength(1);
            expect(remainingCodes[0].code).toBe('222222');
        });
        it('should handle cleanup when user is deleted', async ()=>{
            // Create user with verification codes
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '123456',
                expiresAt: new Date(Date.now() + 600000),
                attemptsUsed: 0
            });
            // Verify code exists
            let emailCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(emailCodes).toHaveLength(1);
            // Delete user (should cascade delete codes due to foreign key constraint)
            await dbManager.deleteUser(user.id);
            // Verify codes were cleaned up
            emailCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(emailCodes).toHaveLength(0);
        });
        it('should handle multiple expired codes for same user', async ()=>{
            // Create user with multiple expired codes
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Create multiple expired codes
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '111111',
                expiresAt: new Date(Date.now() - 120000),
                attemptsUsed: 0
            });
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '222222',
                expiresAt: new Date(Date.now() - 60000),
                attemptsUsed: 0
            });
            // Try to verify with one of the expired codes
            const verifyRequest = new NextRequest('http://localhost/api/auth/verify-email', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com',
                    code: '111111'
                }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            const verifyResponse = await verifyEmailHandler(verifyRequest);
            const verifyData = await verifyResponse.json();
            // Assert expired code error
            expect(verifyResponse.status).toBe(400);
            expect(verifyData.error).toContain('Verification code has expired');
            // Cleanup expired codes
            await _emailverificationcodeservice.emailVerificationCodeService.cleanupExpiredCodes();
            // Verify all expired codes were cleaned up
            const remainingCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(remainingCodes).toHaveLength(0);
        });
    });
    describe('Concurrent Verification Attempts and Race Conditions', ()=>{
        it('should handle concurrent verification attempts safely', async ()=>{
            // Create user with verification code
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '123456',
                expiresAt: new Date(Date.now() + 600000),
                attemptsUsed: 0
            });
            // Execute concurrent verification attempts
            const promises = [
                _emailverificationcodeservice.emailVerificationCodeService.validateCode('test@example.com', '123456'),
                _emailverificationcodeservice.emailVerificationCodeService.validateCode('test@example.com', '123456')
            ];
            // One should succeed, one should fail
            const results = await Promise.allSettled(promises);
            const successCount = results.filter((r)=>r.status === 'fulfilled' && r.value === true).length;
            const failureCount = results.filter((r)=>r.status === 'rejected').length;
            // At least one should succeed, and there might be failures due to race conditions
            expect(successCount).toBeGreaterThanOrEqual(1);
            // Verify user is verified
            const verifiedUser = await dbManager.getUserById(user.id);
            expect(verifiedUser.isEmailVerified).toBe(true);
            // Verify code was deleted
            const remainingCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(remainingCodes).toHaveLength(0);
        });
        it('should handle concurrent code generation requests safely', async ()=>{
            // Create user
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Execute concurrent code generation requests
            const promises = [
                _emailverificationcodeservice.emailVerificationCodeService.generateCode(user.id),
                _emailverificationcodeservice.emailVerificationCodeService.generateCode(user.id)
            ];
            const codes = await Promise.all(promises);
            // Both should succeed and return valid codes
            expect(codes[0]).toMatch(/^\d{6}$/);
            expect(codes[1]).toMatch(/^\d{6}$/);
            // Verify only one code exists (latest one)
            const emailCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(emailCodes).toHaveLength(1);
            // The remaining code should be one of the generated codes
            expect([
                codes[0],
                codes[1]
            ]).toContain(emailCodes[0].code);
        });
        it('should handle race condition between verification and code expiration', async ()=>{
            // Create user with code that expires very soon
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '123456',
                expiresAt: new Date(Date.now() + 100),
                attemptsUsed: 0
            });
            // Wait for code to expire
            await new Promise((resolve)=>setTimeout(resolve, 150));
            // Try to verify with expired code using service
            try {
                await _emailverificationcodeservice.emailVerificationCodeService.validateCode('test@example.com', '123456');
                fail('Should have thrown an error for expired code');
            } catch (error) {
                expect(error.code).toBe('CODE_EXPIRED');
            }
            // User should remain unverified
            const unverifiedUser = await dbManager.getUserById(user.id);
            expect(unverifiedUser.isEmailVerified).toBe(false);
        });
        it('should handle concurrent code generation for same user', async ()=>{
            // Create user
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Execute multiple concurrent code generation requests
            const promises = Array(5).fill(null).map(()=>_emailverificationcodeservice.emailVerificationCodeService.generateCode(user.id));
            const codes = await Promise.all(promises);
            // All should succeed and return valid codes
            codes.forEach((code)=>{
                expect(code).toMatch(/^\d{6}$/);
            });
            // Verify only one code exists (latest one)
            const emailCodes = await dbManager.getEmailCodesByUserId(user.id);
            expect(emailCodes).toHaveLength(1);
            // The remaining code should be one of the generated codes
            expect(codes).toContain(emailCodes[0].code);
        });
    });
    describe('Database Error Scenarios', ()=>{
        it('should handle maximum attempts reached', async ()=>{
            const user = await dbManager.createTestUser({
                email: 'test@example.com',
                name: 'Test User',
                passwordHash: 'hashed_password',
                isEmailVerified: false
            });
            // Create code with maximum attempts reached
            await dbManager.createTestEmailCode({
                userId: user.id,
                code: '123456',
                expiresAt: new Date(Date.now() + 600000),
                attemptsUsed: 5
            });
            // Try to verify with max attempts reached
            try {
                await _emailverificationcodeservice.emailVerificationCodeService.validateCode('test@example.com', '123456');
                fail('Should have thrown an error for too many attempts');
            } catch (error) {
                expect(error.code).toBe('TOO_MANY_ATTEMPTS');
            }
            // User should remain unverified
            const unverifiedUser = await dbManager.getUserById(user.id);
            expect(unverifiedUser.isEmailVerified).toBe(false);
        });
        it('should handle service errors during validation', async ()=>{
            // Test with non-existent user
            try {
                await _emailverificationcodeservice.emailVerificationCodeService.validateCode('nonexistent@example.com', '123456');
                fail('Should have thrown an error for non-existent user');
            } catch (error) {
                expect(error.code).toBe('USER_NOT_FOUND');
            }
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdGVmYW5iZWtrZXIvcHJvamVjdHMvZmFuY3ktcGxhbnRpZXMvc3JjL19fdGVzdHNfXy9pbnRlZ3JhdGlvbi9lbWFpbC12ZXJpZmljYXRpb24tZXJyb3Itc2NlbmFyaW9zLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFbWFpbCBWZXJpZmljYXRpb24gRXJyb3IgU2NlbmFyaW8gVGVzdHNcbiAqIFRlc3RzIGVtYWlsIHNlcnZpY2UgZmFpbHVyZSBoYW5kbGluZywgcmV0cnkgbG9naWMsIGV4cGlyZWQgY29kZSBzY2VuYXJpb3MsIFxuICogY2xlYW51cCBwcm9jZXNzZXMsIGFuZCBjb25jdXJyZW50IHZlcmlmaWNhdGlvbiBhdHRlbXB0c1xuICogUmVxdWlyZW1lbnRzOiAxLjQsIDMuMSwgNy4zLCA3LjRcbiAqL1xuXG5pbXBvcnQgeyBlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlIH0gZnJvbSAnQC9saWIvc2VydmljZXMvZW1haWwtdmVyaWZpY2F0aW9uLWNvZGUtc2VydmljZSc7XG5pbXBvcnQgeyBjcmVhdGVFbWFpbFNlcnZpY2UgfSBmcm9tICdAL2xpYi9zZXJ2aWNlcy9yZXNlbmQtZW1haWwtc2VydmljZSc7XG5pbXBvcnQgeyBFbWFpbFNlcnZpY2VFcnJvciB9IGZyb20gJ0AvbGliL3NlcnZpY2VzL2VtYWlsLXNlcnZpY2UnO1xuXG4vLyBNb2NrIGVtYWlsIHNlcnZpY2UgYW5kIHJlbGF0ZWQgbW9kdWxlc1xuamVzdC5tb2NrKCdAL2xpYi9zZXJ2aWNlcy9yZXNlbmQtZW1haWwtc2VydmljZScpO1xuamVzdC5tb2NrKCdAL2xpYi9zZXJ2aWNlcy9lbWFpbC1zZXJ2aWNlJyk7XG5cbi8vIE1vY2sgZGF0YWJhc2Vcbmplc3QubW9jaygnQC9saWIvZGInLCAoKSA9PiAoe1xuICBkYjoge1xuICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgZnJvbTogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgd2hlcmU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxuICAgIGluc2VydDogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgdmFsdWVzOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgICB1cGRhdGU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxuICAgIHNldDogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgZGVsZXRlOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcbiAgICByZXR1cm5pbmc6IGplc3QuZm4oKSxcbiAgICBleGVjdXRlOiBqZXN0LmZuKCksXG4gIH0sXG59KSk7XG5cbi8vIE1vY2sgYXV0aCBmdW5jdGlvbnNcbmplc3QubW9jaygnQC9saWIvYXV0aCcsICgpID0+ICh7XG4gIGdldFVzZXJCeUVtYWlsOiBqZXN0LmZuKCksXG4gIGdldFVzZXJCeUlkOiBqZXN0LmZuKCksXG59KSk7XG5cbmNvbnN0IG1vY2tFbWFpbFNlcnZpY2UgPSB7XG4gIHNlbmRWZXJpZmljYXRpb25FbWFpbDogamVzdC5mbigpLFxufTtcblxuY29uc3QgbW9ja0NyZWF0ZUVtYWlsU2VydmljZSA9IGNyZWF0ZUVtYWlsU2VydmljZSBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiBjcmVhdGVFbWFpbFNlcnZpY2U+O1xuY29uc3QgbW9ja1NlbmRFbWFpbFdpdGhSZXRyeSA9IHJlcXVpcmUoJ0AvbGliL3NlcnZpY2VzL2VtYWlsLXNlcnZpY2UnKS5zZW5kRW1haWxXaXRoUmV0cnkgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+O1xuY29uc3QgbW9ja0RiID0gcmVxdWlyZSgnQC9saWIvZGInKS5kYjtcbmNvbnN0IG1vY2tHZXRVc2VyQnlFbWFpbCA9IHJlcXVpcmUoJ0AvbGliL2F1dGgnKS5nZXRVc2VyQnlFbWFpbCBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPGFueT47XG5jb25zdCBtb2NrR2V0VXNlckJ5SWQgPSByZXF1aXJlKCdAL2xpYi9hdXRoJykuZ2V0VXNlckJ5SWQgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+O1xuXG4vLyBNb2NrIGVudmlyb25tZW50IHZhcmlhYmxlc1xuY29uc3Qgb3JpZ2luYWxFbnYgPSBwcm9jZXNzLmVudjtcblxuYmVmb3JlQWxsKCgpID0+IHtcbiAgcHJvY2Vzcy5lbnYgPSB7XG4gICAgLi4ub3JpZ2luYWxFbnYsXG4gICAgUkVTRU5EX0FQSV9LRVk6ICd0ZXN0LWFwaS1rZXknLFxuICAgIEZST01fRU1BSUw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICBGUk9NX05BTUU6ICdUZXN0IEFwcCcsXG4gICAgVkVSSUZJQ0FUSU9OX0NPREVfRVhQSVJZX01JTlVURVM6ICcxMCcsXG4gICAgTUFYX1ZFUklGSUNBVElPTl9BVFRFTVBUUzogJzUnLFxuICAgIFJFU0VORF9DT09MRE9XTl9TRUNPTkRTOiAnNjAnLFxuICAgIE1BWF9SRVNFTkRfUEVSX0hPVVI6ICc1JyxcbiAgICBOT0RFX0VOVjogJ3Rlc3QnLFxuICB9O1xufSk7XG5cbmFmdGVyQWxsKCgpID0+IHtcbiAgcHJvY2Vzcy5lbnYgPSBvcmlnaW5hbEVudjtcbn0pO1xuXG5kZXNjcmliZSgnRW1haWwgVmVyaWZpY2F0aW9uIEVycm9yIFNjZW5hcmlvIFRlc3RzJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICBcbiAgICAvLyBEZWZhdWx0IHRvIHN1Y2Nlc3NmdWwgZW1haWwgc2VydmljZVxuICAgIG1vY2tDcmVhdGVFbWFpbFNlcnZpY2UubW9ja1JldHVyblZhbHVlKG1vY2tFbWFpbFNlcnZpY2UpO1xuICAgIG1vY2tTZW5kRW1haWxXaXRoUmV0cnkubW9ja1Jlc29sdmVkVmFsdWUodHJ1ZSk7XG4gICAgbW9ja0VtYWlsU2VydmljZS5zZW5kVmVyaWZpY2F0aW9uRW1haWwubW9ja1Jlc29sdmVkVmFsdWUodHJ1ZSk7XG5cbiAgICAvLyBTZXR1cCBkZWZhdWx0IGRhdGFiYXNlIG1vY2tzXG4gICAgbW9ja0RiLnJldHVybmluZy5tb2NrUmVzb2x2ZWRWYWx1ZShbXSk7XG4gICAgbW9ja0RiLmV4ZWN1dGUubW9ja1Jlc29sdmVkVmFsdWUoW10pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRW1haWwgU2VydmljZSBGYWlsdXJlIEhhbmRsaW5nIGFuZCBSZXRyeSBMb2dpYycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBlbWFpbCBzZXJ2aWNlIGVycm9ycyBkdXJpbmcgY29kZSBnZW5lcmF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBlbWFpbCBzZXJ2aWNlIHRvIGZhaWxcbiAgICAgIG1vY2tTZW5kRW1haWxXaXRoUmV0cnkubW9ja1JlamVjdGVkVmFsdWUobmV3IEVtYWlsU2VydmljZUVycm9yKCdRdW90YSBleGNlZWRlZCcsICdRVU9UQV9FWENFRURFRCcpKTtcblxuICAgICAgLy8gTW9jayB1c2VyIGRhdGFcbiAgICAgIGNvbnN0IG1vY2tVc2VyID0ge1xuICAgICAgICBpZDogMSxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgICAgIGlzRW1haWxWZXJpZmllZDogZmFsc2UsXG4gICAgICB9O1xuXG4gICAgICAvLyBNb2NrIHVzZXIgbG9va3VwXG4gICAgICBtb2NrR2V0VXNlckJ5SWQubW9ja1Jlc29sdmVkVmFsdWUobW9ja1VzZXIpO1xuXG4gICAgICAvLyBNb2NrIGNvZGUgaW5zZXJ0aW9uXG4gICAgICBtb2NrRGIucmV0dXJuaW5nLm1vY2tSZXNvbHZlZFZhbHVlT25jZShbeyBpZDogMSwgY29kZTogJzEyMzQ1NicsIHVzZXJJZDogMSB9XSk7XG5cbiAgICAgIC8vIEdlbmVyYXRlIHZlcmlmaWNhdGlvbiBjb2RlIChzaG91bGQgd29yayBldmVuIGlmIGVtYWlsIGZhaWxzKVxuICAgICAgY29uc3QgdmVyaWZpY2F0aW9uQ29kZSA9IGF3YWl0IGVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UuZ2VuZXJhdGVDb2RlKG1vY2tVc2VyLmlkKTtcbiAgICAgIGV4cGVjdCh2ZXJpZmljYXRpb25Db2RlKS50b01hdGNoKC9eXFxkezZ9JC8pO1xuXG4gICAgICAvLyBWZXJpZnkgZGF0YWJhc2Ugb3BlcmF0aW9ucyB3ZXJlIGNhbGxlZFxuICAgICAgZXhwZWN0KG1vY2tEYi5pbnNlcnQpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGRpZmZlcmVudCB0eXBlcyBvZiBlbWFpbCBzZXJ2aWNlIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgdXNlciBkYXRhXG4gICAgICBjb25zdCBtb2NrVXNlciA9IHtcbiAgICAgICAgaWQ6IDEsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgICBpc0VtYWlsVmVyaWZpZWQ6IGZhbHNlLFxuICAgICAgfTtcblxuICAgICAgLy8gTW9jayB1c2VyIGxvb2t1cFxuICAgICAgbW9ja0dldFVzZXJCeUlkLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tVc2VyKTtcblxuICAgICAgLy8gVGVzdCBBUEkgZXJyb3JcbiAgICAgIG1vY2tTZW5kRW1haWxXaXRoUmV0cnkubW9ja1JlamVjdGVkVmFsdWUobmV3IEVtYWlsU2VydmljZUVycm9yKCdBUEkgZXJyb3InLCAnQVBJX0VSUk9SJykpO1xuICAgICAgbW9ja0RiLnJldHVybmluZy5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoW3sgaWQ6IDEsIGNvZGU6ICcxMjM0NTYnLCB1c2VySWQ6IDEgfV0pO1xuICAgICAgXG4gICAgICBjb25zdCBjb2RlMSA9IGF3YWl0IGVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UuZ2VuZXJhdGVDb2RlKG1vY2tVc2VyLmlkKTtcbiAgICAgIGV4cGVjdChjb2RlMSkudG9NYXRjaCgvXlxcZHs2fSQvKTtcblxuICAgICAgLy8gVGVzdCBuZXR3b3JrIGVycm9yXG4gICAgICBtb2NrU2VuZEVtYWlsV2l0aFJldHJ5Lm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFbWFpbFNlcnZpY2VFcnJvcignTmV0d29yayB0aW1lb3V0JywgJ05FVFdPUktfRVJST1InKSk7XG4gICAgICBtb2NrRGIucmV0dXJuaW5nLm1vY2tSZXNvbHZlZFZhbHVlT25jZShbeyBpZDogMiwgY29kZTogJzY1NDMyMScsIHVzZXJJZDogMSB9XSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGNvZGUyID0gYXdhaXQgZW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS5nZW5lcmF0ZUNvZGUobW9ja1VzZXIuaWQpO1xuICAgICAgZXhwZWN0KGNvZGUyKS50b01hdGNoKC9eXFxkezZ9JC8pO1xuICAgICAgZXhwZWN0KGNvZGUyKS5ub3QudG9CZShjb2RlMSk7IC8vIFNob3VsZCBiZSBkaWZmZXJlbnQgY29kZVxuXG4gICAgICAvLyBWZXJpZnkgZGF0YWJhc2Ugb3BlcmF0aW9ucyB3ZXJlIGNhbGxlZFxuICAgICAgZXhwZWN0KG1vY2tEYi5pbnNlcnQpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygyKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0V4cGlyZWQgQ29kZSBTY2VuYXJpb3MgYW5kIENsZWFudXAgUHJvY2Vzc2VzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIGV4cGlyZWQgdmVyaWZpY2F0aW9uIGNvZGVzIHByb3Blcmx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIHVzZXIgd2l0aCBleHBpcmVkIHZlcmlmaWNhdGlvbiBjb2RlXG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RVc2VyKHtcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgICAgIHBhc3N3b3JkSGFzaDogJ2hhc2hlZF9wYXNzd29yZCcsXG4gICAgICAgIGlzRW1haWxWZXJpZmllZDogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZXhwaXJlZENvZGUgPSBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdEVtYWlsQ29kZSh7XG4gICAgICAgIHVzZXJJZDogdXNlci5pZCxcbiAgICAgICAgY29kZTogJzEyMzQ1NicsXG4gICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDYwMDAwKSwgLy8gRXhwaXJlZCAxIG1pbnV0ZSBhZ29cbiAgICAgICAgYXR0ZW1wdHNVc2VkOiAwLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFRyeSB0byB2ZXJpZnkgd2l0aCBleHBpcmVkIGNvZGUgdXNpbmcgc2VydmljZVxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS52YWxpZGF0ZUNvZGUoJ3Rlc3RAZXhhbXBsZS5jb20nLCAnMTIzNDU2Jyk7XG4gICAgICAgIGZhaWwoJ1Nob3VsZCBoYXZlIHRocm93biBhbiBlcnJvciBmb3IgZXhwaXJlZCBjb2RlJyk7XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIGV4cGVjdChlcnJvci5jb2RlKS50b0JlKCdDT0RFX0VYUElSRUQnKTtcbiAgICAgIH1cblxuICAgICAgLy8gVmVyaWZ5IHVzZXIgaXMgc3RpbGwgbm90IHZlcmlmaWVkXG4gICAgICBjb25zdCB1bnZlcmlmaWVkVXNlciA9IGF3YWl0IGRiTWFuYWdlci5nZXRVc2VyQnlJZCh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdCh1bnZlcmlmaWVkVXNlci5pc0VtYWlsVmVyaWZpZWQpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBjbGVhbiB1cCBleHBpcmVkIGNvZGVzIGR1cmluZyB2ZXJpZmljYXRpb24gc2VydmljZSBvcGVyYXRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIHVzZXIgd2l0aCBtdWx0aXBsZSBjb2Rlcywgc29tZSBleHBpcmVkXG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RVc2VyKHtcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgICAgIHBhc3N3b3JkSGFzaDogJ2hhc2hlZF9wYXNzd29yZCcsXG4gICAgICAgIGlzRW1haWxWZXJpZmllZDogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgLy8gQ3JlYXRlIGV4cGlyZWQgY29kZVxuICAgICAgYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RFbWFpbENvZGUoe1xuICAgICAgICB1c2VySWQ6IHVzZXIuaWQsXG4gICAgICAgIGNvZGU6ICcxMTExMTEnLFxuICAgICAgICBleHBpcmVzQXQ6IG5ldyBEYXRlKERhdGUubm93KCkgLSA2MDAwMCksIC8vIEV4cGlyZWRcbiAgICAgICAgYXR0ZW1wdHNVc2VkOiAwLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIENyZWF0ZSB2YWxpZCBjb2RlXG4gICAgICBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdEVtYWlsQ29kZSh7XG4gICAgICAgIHVzZXJJZDogdXNlci5pZCxcbiAgICAgICAgY29kZTogJzIyMjIyMicsXG4gICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIDYwMDAwMCksIC8vIFZhbGlkIGZvciAxMCBtaW51dGVzXG4gICAgICAgIGF0dGVtcHRzVXNlZDogMCxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBUcmlnZ2VyIGNsZWFudXAgYnkgY2FsbGluZyB0aGUgc2VydmljZSBtZXRob2RcbiAgICAgIGF3YWl0IGVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UuY2xlYW51cEV4cGlyZWRDb2RlcygpO1xuXG4gICAgICAvLyBWZXJpZnkgZXhwaXJlZCBjb2RlIHdhcyBjbGVhbmVkIHVwXG4gICAgICBjb25zdCByZW1haW5pbmdDb2RlcyA9IGF3YWl0IGRiTWFuYWdlci5nZXRFbWFpbENvZGVzQnlVc2VySWQodXNlci5pZCk7XG4gICAgICBleHBlY3QocmVtYWluaW5nQ29kZXMpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChyZW1haW5pbmdDb2Rlc1swXS5jb2RlKS50b0JlKCcyMjIyMjInKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNsZWFudXAgd2hlbiB1c2VyIGlzIGRlbGV0ZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBDcmVhdGUgdXNlciB3aXRoIHZlcmlmaWNhdGlvbiBjb2Rlc1xuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0VXNlcih7XG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgICBwYXNzd29yZEhhc2g6ICdoYXNoZWRfcGFzc3dvcmQnLFxuICAgICAgICBpc0VtYWlsVmVyaWZpZWQ6IGZhbHNlLFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0RW1haWxDb2RlKHtcbiAgICAgICAgdXNlcklkOiB1c2VyLmlkLFxuICAgICAgICBjb2RlOiAnMTIzNDU2JyxcbiAgICAgICAgZXhwaXJlc0F0OiBuZXcgRGF0ZShEYXRlLm5vdygpICsgNjAwMDAwKSxcbiAgICAgICAgYXR0ZW1wdHNVc2VkOiAwLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFZlcmlmeSBjb2RlIGV4aXN0c1xuICAgICAgbGV0IGVtYWlsQ29kZXMgPSBhd2FpdCBkYk1hbmFnZXIuZ2V0RW1haWxDb2Rlc0J5VXNlcklkKHVzZXIuaWQpO1xuICAgICAgZXhwZWN0KGVtYWlsQ29kZXMpLnRvSGF2ZUxlbmd0aCgxKTtcblxuICAgICAgLy8gRGVsZXRlIHVzZXIgKHNob3VsZCBjYXNjYWRlIGRlbGV0ZSBjb2RlcyBkdWUgdG8gZm9yZWlnbiBrZXkgY29uc3RyYWludClcbiAgICAgIGF3YWl0IGRiTWFuYWdlci5kZWxldGVVc2VyKHVzZXIuaWQpO1xuXG4gICAgICAvLyBWZXJpZnkgY29kZXMgd2VyZSBjbGVhbmVkIHVwXG4gICAgICBlbWFpbENvZGVzID0gYXdhaXQgZGJNYW5hZ2VyLmdldEVtYWlsQ29kZXNCeVVzZXJJZCh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdChlbWFpbENvZGVzKS50b0hhdmVMZW5ndGgoMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBtdWx0aXBsZSBleHBpcmVkIGNvZGVzIGZvciBzYW1lIHVzZXInLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBDcmVhdGUgdXNlciB3aXRoIG11bHRpcGxlIGV4cGlyZWQgY29kZXNcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdFVzZXIoe1xuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAnVGVzdCBVc2VyJyxcbiAgICAgICAgcGFzc3dvcmRIYXNoOiAnaGFzaGVkX3Bhc3N3b3JkJyxcbiAgICAgICAgaXNFbWFpbFZlcmlmaWVkOiBmYWxzZSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBDcmVhdGUgbXVsdGlwbGUgZXhwaXJlZCBjb2Rlc1xuICAgICAgYXdhaXQgZGJNYW5hZ2VyLmNyZWF0ZVRlc3RFbWFpbENvZGUoe1xuICAgICAgICB1c2VySWQ6IHVzZXIuaWQsXG4gICAgICAgIGNvZGU6ICcxMTExMTEnLFxuICAgICAgICBleHBpcmVzQXQ6IG5ldyBEYXRlKERhdGUubm93KCkgLSAxMjAwMDApLCAvLyBFeHBpcmVkIDIgbWludXRlcyBhZ29cbiAgICAgICAgYXR0ZW1wdHNVc2VkOiAwLFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0RW1haWxDb2RlKHtcbiAgICAgICAgdXNlcklkOiB1c2VyLmlkLFxuICAgICAgICBjb2RlOiAnMjIyMjIyJyxcbiAgICAgICAgZXhwaXJlc0F0OiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gNjAwMDApLCAvLyBFeHBpcmVkIDEgbWludXRlIGFnb1xuICAgICAgICBhdHRlbXB0c1VzZWQ6IDAsXG4gICAgICB9KTtcblxuICAgICAgLy8gVHJ5IHRvIHZlcmlmeSB3aXRoIG9uZSBvZiB0aGUgZXhwaXJlZCBjb2Rlc1xuICAgICAgY29uc3QgdmVyaWZ5UmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdC9hcGkvYXV0aC92ZXJpZnktZW1haWwnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBjb2RlOiAnMTExMTExJyxcbiAgICAgICAgfSksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHZlcmlmeVJlc3BvbnNlID0gYXdhaXQgdmVyaWZ5RW1haWxIYW5kbGVyKHZlcmlmeVJlcXVlc3QpO1xuICAgICAgY29uc3QgdmVyaWZ5RGF0YSA9IGF3YWl0IHZlcmlmeVJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgLy8gQXNzZXJ0IGV4cGlyZWQgY29kZSBlcnJvclxuICAgICAgZXhwZWN0KHZlcmlmeVJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDApO1xuICAgICAgZXhwZWN0KHZlcmlmeURhdGEuZXJyb3IpLnRvQ29udGFpbignVmVyaWZpY2F0aW9uIGNvZGUgaGFzIGV4cGlyZWQnKTtcblxuICAgICAgLy8gQ2xlYW51cCBleHBpcmVkIGNvZGVzXG4gICAgICBhd2FpdCBlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlLmNsZWFudXBFeHBpcmVkQ29kZXMoKTtcblxuICAgICAgLy8gVmVyaWZ5IGFsbCBleHBpcmVkIGNvZGVzIHdlcmUgY2xlYW5lZCB1cFxuICAgICAgY29uc3QgcmVtYWluaW5nQ29kZXMgPSBhd2FpdCBkYk1hbmFnZXIuZ2V0RW1haWxDb2Rlc0J5VXNlcklkKHVzZXIuaWQpO1xuICAgICAgZXhwZWN0KHJlbWFpbmluZ0NvZGVzKS50b0hhdmVMZW5ndGgoMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDb25jdXJyZW50IFZlcmlmaWNhdGlvbiBBdHRlbXB0cyBhbmQgUmFjZSBDb25kaXRpb25zJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNvbmN1cnJlbnQgdmVyaWZpY2F0aW9uIGF0dGVtcHRzIHNhZmVseScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSB1c2VyIHdpdGggdmVyaWZpY2F0aW9uIGNvZGVcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdFVzZXIoe1xuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAnVGVzdCBVc2VyJyxcbiAgICAgICAgcGFzc3dvcmRIYXNoOiAnaGFzaGVkX3Bhc3N3b3JkJyxcbiAgICAgICAgaXNFbWFpbFZlcmlmaWVkOiBmYWxzZSxcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdEVtYWlsQ29kZSh7XG4gICAgICAgIHVzZXJJZDogdXNlci5pZCxcbiAgICAgICAgY29kZTogJzEyMzQ1NicsXG4gICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIDYwMDAwMCksXG4gICAgICAgIGF0dGVtcHRzVXNlZDogMCxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBFeGVjdXRlIGNvbmN1cnJlbnQgdmVyaWZpY2F0aW9uIGF0dGVtcHRzXG4gICAgICBjb25zdCBwcm9taXNlcyA9IFtcbiAgICAgICAgZW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS52YWxpZGF0ZUNvZGUoJ3Rlc3RAZXhhbXBsZS5jb20nLCAnMTIzNDU2JyksXG4gICAgICAgIGVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UudmFsaWRhdGVDb2RlKCd0ZXN0QGV4YW1wbGUuY29tJywgJzEyMzQ1NicpLFxuICAgICAgXTtcblxuICAgICAgLy8gT25lIHNob3VsZCBzdWNjZWVkLCBvbmUgc2hvdWxkIGZhaWxcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQocHJvbWlzZXMpO1xuICAgICAgXG4gICAgICBjb25zdCBzdWNjZXNzQ291bnQgPSByZXN1bHRzLmZpbHRlcihyID0+IHIuc3RhdHVzID09PSAnZnVsZmlsbGVkJyAmJiByLnZhbHVlID09PSB0cnVlKS5sZW5ndGg7XG4gICAgICBjb25zdCBmYWlsdXJlQ291bnQgPSByZXN1bHRzLmZpbHRlcihyID0+IHIuc3RhdHVzID09PSAncmVqZWN0ZWQnKS5sZW5ndGg7XG5cbiAgICAgIC8vIEF0IGxlYXN0IG9uZSBzaG91bGQgc3VjY2VlZCwgYW5kIHRoZXJlIG1pZ2h0IGJlIGZhaWx1cmVzIGR1ZSB0byByYWNlIGNvbmRpdGlvbnNcbiAgICAgIGV4cGVjdChzdWNjZXNzQ291bnQpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMSk7XG5cbiAgICAgIC8vIFZlcmlmeSB1c2VyIGlzIHZlcmlmaWVkXG4gICAgICBjb25zdCB2ZXJpZmllZFVzZXIgPSBhd2FpdCBkYk1hbmFnZXIuZ2V0VXNlckJ5SWQodXNlci5pZCk7XG4gICAgICBleHBlY3QodmVyaWZpZWRVc2VyLmlzRW1haWxWZXJpZmllZCkudG9CZSh0cnVlKTtcblxuICAgICAgLy8gVmVyaWZ5IGNvZGUgd2FzIGRlbGV0ZWRcbiAgICAgIGNvbnN0IHJlbWFpbmluZ0NvZGVzID0gYXdhaXQgZGJNYW5hZ2VyLmdldEVtYWlsQ29kZXNCeVVzZXJJZCh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdChyZW1haW5pbmdDb2RlcykudG9IYXZlTGVuZ3RoKDApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY29uY3VycmVudCBjb2RlIGdlbmVyYXRpb24gcmVxdWVzdHMgc2FmZWx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIHVzZXJcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdFVzZXIoe1xuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAnVGVzdCBVc2VyJyxcbiAgICAgICAgcGFzc3dvcmRIYXNoOiAnaGFzaGVkX3Bhc3N3b3JkJyxcbiAgICAgICAgaXNFbWFpbFZlcmlmaWVkOiBmYWxzZSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBFeGVjdXRlIGNvbmN1cnJlbnQgY29kZSBnZW5lcmF0aW9uIHJlcXVlc3RzXG4gICAgICBjb25zdCBwcm9taXNlcyA9IFtcbiAgICAgICAgZW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS5nZW5lcmF0ZUNvZGUodXNlci5pZCksXG4gICAgICAgIGVtYWlsVmVyaWZpY2F0aW9uQ29kZVNlcnZpY2UuZ2VuZXJhdGVDb2RlKHVzZXIuaWQpLFxuICAgICAgXTtcblxuICAgICAgY29uc3QgY29kZXMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cbiAgICAgIC8vIEJvdGggc2hvdWxkIHN1Y2NlZWQgYW5kIHJldHVybiB2YWxpZCBjb2Rlc1xuICAgICAgZXhwZWN0KGNvZGVzWzBdKS50b01hdGNoKC9eXFxkezZ9JC8pO1xuICAgICAgZXhwZWN0KGNvZGVzWzFdKS50b01hdGNoKC9eXFxkezZ9JC8pO1xuXG4gICAgICAvLyBWZXJpZnkgb25seSBvbmUgY29kZSBleGlzdHMgKGxhdGVzdCBvbmUpXG4gICAgICBjb25zdCBlbWFpbENvZGVzID0gYXdhaXQgZGJNYW5hZ2VyLmdldEVtYWlsQ29kZXNCeVVzZXJJZCh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdChlbWFpbENvZGVzKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBcbiAgICAgIC8vIFRoZSByZW1haW5pbmcgY29kZSBzaG91bGQgYmUgb25lIG9mIHRoZSBnZW5lcmF0ZWQgY29kZXNcbiAgICAgIGV4cGVjdChbY29kZXNbMF0sIGNvZGVzWzFdXSkudG9Db250YWluKGVtYWlsQ29kZXNbMF0uY29kZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSByYWNlIGNvbmRpdGlvbiBiZXR3ZWVuIHZlcmlmaWNhdGlvbiBhbmQgY29kZSBleHBpcmF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIHVzZXIgd2l0aCBjb2RlIHRoYXQgZXhwaXJlcyB2ZXJ5IHNvb25cbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdFVzZXIoe1xuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAnVGVzdCBVc2VyJyxcbiAgICAgICAgcGFzc3dvcmRIYXNoOiAnaGFzaGVkX3Bhc3N3b3JkJyxcbiAgICAgICAgaXNFbWFpbFZlcmlmaWVkOiBmYWxzZSxcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdEVtYWlsQ29kZSh7XG4gICAgICAgIHVzZXJJZDogdXNlci5pZCxcbiAgICAgICAgY29kZTogJzEyMzQ1NicsXG4gICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIDEwMCksIC8vIEV4cGlyZXMgaW4gMTAwbXNcbiAgICAgICAgYXR0ZW1wdHNVc2VkOiAwLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFdhaXQgZm9yIGNvZGUgdG8gZXhwaXJlXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTUwKSk7XG5cbiAgICAgIC8vIFRyeSB0byB2ZXJpZnkgd2l0aCBleHBpcmVkIGNvZGUgdXNpbmcgc2VydmljZVxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS52YWxpZGF0ZUNvZGUoJ3Rlc3RAZXhhbXBsZS5jb20nLCAnMTIzNDU2Jyk7XG4gICAgICAgIGZhaWwoJ1Nob3VsZCBoYXZlIHRocm93biBhbiBlcnJvciBmb3IgZXhwaXJlZCBjb2RlJyk7XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIGV4cGVjdChlcnJvci5jb2RlKS50b0JlKCdDT0RFX0VYUElSRUQnKTtcbiAgICAgIH1cblxuICAgICAgLy8gVXNlciBzaG91bGQgcmVtYWluIHVudmVyaWZpZWRcbiAgICAgIGNvbnN0IHVudmVyaWZpZWRVc2VyID0gYXdhaXQgZGJNYW5hZ2VyLmdldFVzZXJCeUlkKHVzZXIuaWQpO1xuICAgICAgZXhwZWN0KHVudmVyaWZpZWRVc2VyLmlzRW1haWxWZXJpZmllZCkudG9CZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjb25jdXJyZW50IGNvZGUgZ2VuZXJhdGlvbiBmb3Igc2FtZSB1c2VyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIHVzZXJcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdFVzZXIoe1xuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAnVGVzdCBVc2VyJyxcbiAgICAgICAgcGFzc3dvcmRIYXNoOiAnaGFzaGVkX3Bhc3N3b3JkJyxcbiAgICAgICAgaXNFbWFpbFZlcmlmaWVkOiBmYWxzZSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBFeGVjdXRlIG11bHRpcGxlIGNvbmN1cnJlbnQgY29kZSBnZW5lcmF0aW9uIHJlcXVlc3RzXG4gICAgICBjb25zdCBwcm9taXNlcyA9IEFycmF5KDUpLmZpbGwobnVsbCkubWFwKCgpID0+IFxuICAgICAgICBlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlLmdlbmVyYXRlQ29kZSh1c2VyLmlkKVxuICAgICAgKTtcblxuICAgICAgY29uc3QgY29kZXMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cbiAgICAgIC8vIEFsbCBzaG91bGQgc3VjY2VlZCBhbmQgcmV0dXJuIHZhbGlkIGNvZGVzXG4gICAgICBjb2Rlcy5mb3JFYWNoKGNvZGUgPT4ge1xuICAgICAgICBleHBlY3QoY29kZSkudG9NYXRjaCgvXlxcZHs2fSQvKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBWZXJpZnkgb25seSBvbmUgY29kZSBleGlzdHMgKGxhdGVzdCBvbmUpXG4gICAgICBjb25zdCBlbWFpbENvZGVzID0gYXdhaXQgZGJNYW5hZ2VyLmdldEVtYWlsQ29kZXNCeVVzZXJJZCh1c2VyLmlkKTtcbiAgICAgIGV4cGVjdChlbWFpbENvZGVzKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBcbiAgICAgIC8vIFRoZSByZW1haW5pbmcgY29kZSBzaG91bGQgYmUgb25lIG9mIHRoZSBnZW5lcmF0ZWQgY29kZXNcbiAgICAgIGV4cGVjdChjb2RlcykudG9Db250YWluKGVtYWlsQ29kZXNbMF0uY29kZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdEYXRhYmFzZSBFcnJvciBTY2VuYXJpb3MnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbWF4aW11bSBhdHRlbXB0cyByZWFjaGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGRiTWFuYWdlci5jcmVhdGVUZXN0VXNlcih7XG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgICAgICBwYXNzd29yZEhhc2g6ICdoYXNoZWRfcGFzc3dvcmQnLFxuICAgICAgICBpc0VtYWlsVmVyaWZpZWQ6IGZhbHNlLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIENyZWF0ZSBjb2RlIHdpdGggbWF4aW11bSBhdHRlbXB0cyByZWFjaGVkXG4gICAgICBhd2FpdCBkYk1hbmFnZXIuY3JlYXRlVGVzdEVtYWlsQ29kZSh7XG4gICAgICAgIHVzZXJJZDogdXNlci5pZCxcbiAgICAgICAgY29kZTogJzEyMzQ1NicsXG4gICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoRGF0ZS5ub3coKSArIDYwMDAwMCksXG4gICAgICAgIGF0dGVtcHRzVXNlZDogNSwgLy8gTWF4aW11bSBhdHRlbXB0cyByZWFjaGVkXG4gICAgICB9KTtcblxuICAgICAgLy8gVHJ5IHRvIHZlcmlmeSB3aXRoIG1heCBhdHRlbXB0cyByZWFjaGVkXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlLnZhbGlkYXRlQ29kZSgndGVzdEBleGFtcGxlLmNvbScsICcxMjM0NTYnKTtcbiAgICAgICAgZmFpbCgnU2hvdWxkIGhhdmUgdGhyb3duIGFuIGVycm9yIGZvciB0b28gbWFueSBhdHRlbXB0cycpO1xuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBleHBlY3QoZXJyb3IuY29kZSkudG9CZSgnVE9PX01BTllfQVRURU1QVFMnKTtcbiAgICAgIH1cblxuICAgICAgLy8gVXNlciBzaG91bGQgcmVtYWluIHVudmVyaWZpZWRcbiAgICAgIGNvbnN0IHVudmVyaWZpZWRVc2VyID0gYXdhaXQgZGJNYW5hZ2VyLmdldFVzZXJCeUlkKHVzZXIuaWQpO1xuICAgICAgZXhwZWN0KHVudmVyaWZpZWRVc2VyLmlzRW1haWxWZXJpZmllZCkudG9CZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBzZXJ2aWNlIGVycm9ycyBkdXJpbmcgdmFsaWRhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFRlc3Qgd2l0aCBub24tZXhpc3RlbnQgdXNlclxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZW1haWxWZXJpZmljYXRpb25Db2RlU2VydmljZS52YWxpZGF0ZUNvZGUoJ25vbmV4aXN0ZW50QGV4YW1wbGUuY29tJywgJzEyMzQ1NicpO1xuICAgICAgICBmYWlsKCdTaG91bGQgaGF2ZSB0aHJvd24gYW4gZXJyb3IgZm9yIG5vbi1leGlzdGVudCB1c2VyJyk7XG4gICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIGV4cGVjdChlcnJvci5jb2RlKS50b0JlKCdVU0VSX05PVF9GT1VORCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsImRiIiwic2VsZWN0IiwiZm4iLCJtb2NrUmV0dXJuVGhpcyIsImZyb20iLCJ3aGVyZSIsImluc2VydCIsInZhbHVlcyIsInVwZGF0ZSIsInNldCIsImRlbGV0ZSIsInJldHVybmluZyIsImV4ZWN1dGUiLCJnZXRVc2VyQnlFbWFpbCIsImdldFVzZXJCeUlkIiwibW9ja0VtYWlsU2VydmljZSIsInNlbmRWZXJpZmljYXRpb25FbWFpbCIsIm1vY2tDcmVhdGVFbWFpbFNlcnZpY2UiLCJjcmVhdGVFbWFpbFNlcnZpY2UiLCJtb2NrU2VuZEVtYWlsV2l0aFJldHJ5IiwicmVxdWlyZSIsInNlbmRFbWFpbFdpdGhSZXRyeSIsIm1vY2tEYiIsIm1vY2tHZXRVc2VyQnlFbWFpbCIsIm1vY2tHZXRVc2VyQnlJZCIsIm9yaWdpbmFsRW52IiwicHJvY2VzcyIsImVudiIsImJlZm9yZUFsbCIsIlJFU0VORF9BUElfS0VZIiwiRlJPTV9FTUFJTCIsIkZST01fTkFNRSIsIlZFUklGSUNBVElPTl9DT0RFX0VYUElSWV9NSU5VVEVTIiwiTUFYX1ZFUklGSUNBVElPTl9BVFRFTVBUUyIsIlJFU0VORF9DT09MRE9XTl9TRUNPTkRTIiwiTUFYX1JFU0VORF9QRVJfSE9VUiIsIk5PREVfRU5WIiwiYWZ0ZXJBbGwiLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwibW9ja1JldHVyblZhbHVlIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJpdCIsIm1vY2tSZWplY3RlZFZhbHVlIiwiRW1haWxTZXJ2aWNlRXJyb3IiLCJtb2NrVXNlciIsImlkIiwiZW1haWwiLCJuYW1lIiwiaXNFbWFpbFZlcmlmaWVkIiwibW9ja1Jlc29sdmVkVmFsdWVPbmNlIiwiY29kZSIsInVzZXJJZCIsInZlcmlmaWNhdGlvbkNvZGUiLCJlbWFpbFZlcmlmaWNhdGlvbkNvZGVTZXJ2aWNlIiwiZ2VuZXJhdGVDb2RlIiwiZXhwZWN0IiwidG9NYXRjaCIsInRvSGF2ZUJlZW5DYWxsZWQiLCJjb2RlMSIsImNvZGUyIiwibm90IiwidG9CZSIsInRvSGF2ZUJlZW5DYWxsZWRUaW1lcyIsInVzZXIiLCJkYk1hbmFnZXIiLCJjcmVhdGVUZXN0VXNlciIsInBhc3N3b3JkSGFzaCIsImV4cGlyZWRDb2RlIiwiY3JlYXRlVGVzdEVtYWlsQ29kZSIsImV4cGlyZXNBdCIsIkRhdGUiLCJub3ciLCJhdHRlbXB0c1VzZWQiLCJ2YWxpZGF0ZUNvZGUiLCJmYWlsIiwiZXJyb3IiLCJ1bnZlcmlmaWVkVXNlciIsImNsZWFudXBFeHBpcmVkQ29kZXMiLCJyZW1haW5pbmdDb2RlcyIsImdldEVtYWlsQ29kZXNCeVVzZXJJZCIsInRvSGF2ZUxlbmd0aCIsImVtYWlsQ29kZXMiLCJkZWxldGVVc2VyIiwidmVyaWZ5UmVxdWVzdCIsIk5leHRSZXF1ZXN0IiwibWV0aG9kIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJoZWFkZXJzIiwidmVyaWZ5UmVzcG9uc2UiLCJ2ZXJpZnlFbWFpbEhhbmRsZXIiLCJ2ZXJpZnlEYXRhIiwianNvbiIsInN0YXR1cyIsInRvQ29udGFpbiIsInByb21pc2VzIiwicmVzdWx0cyIsIlByb21pc2UiLCJhbGxTZXR0bGVkIiwic3VjY2Vzc0NvdW50IiwiZmlsdGVyIiwiciIsInZhbHVlIiwibGVuZ3RoIiwiZmFpbHVyZUNvdW50IiwidG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCIsInZlcmlmaWVkVXNlciIsImNvZGVzIiwiYWxsIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJBcnJheSIsImZpbGwiLCJtYXAiLCJmb3JFYWNoIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Q0FLQztBQU1ELHlDQUF5QztBQUN6Q0EsS0FBS0MsSUFBSSxDQUFDO0FBQ1ZELEtBQUtDLElBQUksQ0FBQztBQUVWLGdCQUFnQjtBQUNo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