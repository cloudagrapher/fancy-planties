{"version":3,"sources":["/Users/stefanbekker/projects/fancy-planties/src/__tests__/integration/email-verification-error-scenarios.test.ts"],"sourcesContent":["/**\n * Email Verification Error Scenario Tests\n * Tests email service failure handling, retry logic, expired code scenarios, \n * cleanup processes, and concurrent verification attempts\n * Requirements: 1.4, 3.1, 7.3, 7.4\n */\n\nimport { createDatabaseTestManager } from '@/test-utils/setup/database-test-manager';\nimport { emailVerificationCodeService } from '@/lib/services/email-verification-code-service';\nimport { createEmailService } from '@/lib/services/resend-email-service';\nimport { EmailServiceError } from '@/lib/services/email-service';\n\n// Mock email service and related modules\njest.mock('@/lib/services/resend-email-service');\njest.mock('@/lib/services/email-service');\n\nconst mockEmailService = {\n  sendVerificationEmail: jest.fn(),\n};\n\nconst mockCreateEmailService = createEmailService as jest.MockedFunction<typeof createEmailService>;\nconst mockSendEmailWithRetry = require('@/lib/services/email-service').sendEmailWithRetry as jest.MockedFunction<any>;\n\n// Mock environment variables\nconst originalEnv = process.env;\n\nbeforeAll(() => {\n  process.env = {\n    ...originalEnv,\n    RESEND_API_KEY: 'test-api-key',\n    FROM_EMAIL: 'test@example.com',\n    FROM_NAME: 'Test App',\n    VERIFICATION_CODE_EXPIRY_MINUTES: '10',\n    MAX_VERIFICATION_ATTEMPTS: '5',\n    RESEND_COOLDOWN_SECONDS: '60',\n    MAX_RESEND_PER_HOUR: '5',\n    NODE_ENV: 'test',\n  };\n});\n\nafterAll(() => {\n  process.env = originalEnv;\n});\n\ndescribe('Email Verification Error Scenario Tests', () => {\n  let dbManager: any;\n\n  beforeEach(async () => {\n    jest.clearAllMocks();\n    dbManager = createDatabaseTestManager();\n    \n    // Default to successful email service\n    mockCreateEmailService.mockReturnValue(mockEmailService);\n    mockSendEmailWithRetry.mockResolvedValue(true);\n    mockEmailService.sendVerificationEmail.mockResolvedValue(true);\n  });\n\n  afterEach(async () => {\n    await dbManager.cleanup();\n  });\n\n  describe('Email Service Failure Handling and Retry Logic', () => {\n    it('should handle email service errors during code generation', async () => {\n      // Mock email service to fail\n      mockSendEmailWithRetry.mockRejectedValue(new EmailServiceError('Quota exceeded', 'QUOTA_EXCEEDED'));\n\n      // Create user\n      const user = await dbManager.createTestUser({\n        email: 'test@example.com',\n        name: 'Test User',\n        passwordHash: 'hashed_password',\n        isEmailVerified: false,\n      });\n\n      // Generate verification code (should work even if email fails)\n      const verificationCode = await emailVerificationCodeService.generateCode(user.id);\n      expect(verificationCode).toMatch(/^\\d{6}$/);\n\n      // Verify code was stored in database\n      const emailCodes = await dbManager.getEmailCodesByUserId(user.id);\n      expect(emailCodes).toHaveLength(1);\n      expect(emailCodes[0].code).toBe(verificationCode);\n\n      // User should still be unverified\n      const unverifiedUser = await dbManager.getUserById(user.id);\n      expect(unverifiedUser.isEmailVerified).toBe(false);\n    });\n\n    it('should handle different types of email service errors', async () => {\n      const user = await dbManager.createTestUser({\n        email: 'test@example.com',\n        name: 'Test User',\n        passwordHash: 'hashed_password',\n        isEmailVerified: false,\n      });\n\n      // Test API error\n      mockSendEmailWithRetry.mockRejectedValue(new EmailServiceError('API error', 'API_ERROR'));\n      const code1 = await emailVerificationCodeService.generateCode(user.id);\n      expect(code1).toMatch(/^\\d{6}$/);\n\n      // Test network error\n      mockSendEmailWithRetry.mockRejectedValue(new EmailServiceError('Network timeout', 'NETWORK_ERROR'));\n      const code2 = await emailVerificationCodeService.generateCode(user.id);\n      expect(code2).toMatch(/^\\d{6}$/);\n      expect(code2).not.toBe(code1); // Should be different code\n\n      // Verify only latest code exists\n      const emailCodes = await dbManager.getEmailCodesByUserId(user.id);\n      expect(emailCodes).toHaveLength(1);\n      expect(emailCodes[0].code).toBe(code2);\n    });\n\n    it('should handle email service errors but still generate codes', async () => {\n      const user = await dbManager.createTestUser({\n        email: 'test@example.com',\n        name: 'Test User',\n        passwordHash: 'hashed_password',\n        isEmailVerified: false,\n      });\n\n      // Mock various email service errors\n      mockSendEmailWithRetry.mockRejectedValue(new EmailServiceError('Invalid email', 'INVALID_EMAIL'));\n      \n      // Code generation should still work\n      const code = await emailVerificationCodeService.generateCode(user.id);\n      expect(code).toMatch(/^\\d{6}$/);\n\n      // Verify code was stored\n      const emailCodes = await dbManager.getEmailCodesByUserId(user.id);\n      expect(emailCodes).toHaveLength(1);\n      expect(emailCodes[0].code).toBe(code);\n    });\n  });\n\n  describe('Expired Code Scenarios and Cleanup Processes', () => {\n    it('should handle expired verification codes properly', async () => {\n      // Create user with expired verification code\n      const user = await dbManager.createTestUser({\n        email: 'test@example.com',\n        name: 'Test User',\n        passwordHash: 'hashed_password',\n        isEmailVerified: false,\n      });\n\n      const expiredCode = await dbManager.createTestEmailCode({\n        userId: user.id,\n        code: '123456',\n        expiresAt: new Date(Date.now() - 60000), // Expired 1 minute ago\n        attemptsUsed: 0,\n      });\n\n      // Try to verify with expired code using service\n      try {\n        await emailVerificationCodeService.validateCode('test@example.com', '123456');\n        fail('Should have thrown an error for expired code');\n      } catch (error: any) {\n        expect(error.code).toBe('CODE_EXPIRED');\n      }\n\n      // Verify user is still not verified\n      const unverifiedUser = await dbManager.getUserById(user.id);\n      expect(unverifiedUser.isEmailVerified).toBe(false);\n    });\n\n    it('should clean up expired codes during verification service operations', async () => {\n      // Create user with multiple codes, some expired\n      const user = await dbManager.createTestUser({\n        email: 'test@example.com',\n        name: 'Test User',\n        passwordHash: 'hashed_password',\n        isEmailVerified: false,\n      });\n\n      // Create expired code\n      await dbManager.createTestEmailCode({\n        userId: user.id,\n        code: '111111',\n        expiresAt: new Date(Date.now() - 60000), // Expired\n        attemptsUsed: 0,\n      });\n\n      // Create valid code\n      await dbManager.createTestEmailCode({\n        userId: user.id,\n        code: '222222',\n        expiresAt: new Date(Date.now() + 600000), // Valid for 10 minutes\n        attemptsUsed: 0,\n      });\n\n      // Trigger cleanup by calling the service method\n      await emailVerificationCodeService.cleanupExpiredCodes();\n\n      // Verify expired code was cleaned up\n      const remainingCodes = await dbManager.getEmailCodesByUserId(user.id);\n      expect(remainingCodes).toHaveLength(1);\n      expect(remainingCodes[0].code).toBe('222222');\n    });\n\n    it('should handle cleanup when user is deleted', async () => {\n      // Create user with verification codes\n      const user = await dbManager.createTestUser({\n        email: 'test@example.com',\n        name: 'Test User',\n        passwordHash: 'hashed_password',\n        isEmailVerified: false,\n      });\n\n      await dbManager.createTestEmailCode({\n        userId: user.id,\n        code: '123456',\n        expiresAt: new Date(Date.now() + 600000),\n        attemptsUsed: 0,\n      });\n\n      // Verify code exists\n      let emailCodes = await dbManager.getEmailCodesByUserId(user.id);\n      expect(emailCodes).toHaveLength(1);\n\n      // Delete user (should cascade delete codes due to foreign key constraint)\n      await dbManager.deleteUser(user.id);\n\n      // Verify codes were cleaned up\n      emailCodes = await dbManager.getEmailCodesByUserId(user.id);\n      expect(emailCodes).toHaveLength(0);\n    });\n\n    it('should handle multiple expired codes for same user', async () => {\n      // Create user with multiple expired codes\n      const user = await dbManager.createTestUser({\n        email: 'test@example.com',\n        name: 'Test User',\n        passwordHash: 'hashed_password',\n        isEmailVerified: false,\n      });\n\n      // Create multiple expired codes\n      await dbManager.createTestEmailCode({\n        userId: user.id,\n        code: '111111',\n        expiresAt: new Date(Date.now() - 120000), // Expired 2 minutes ago\n        attemptsUsed: 0,\n      });\n\n      await dbManager.createTestEmailCode({\n        userId: user.id,\n        code: '222222',\n        expiresAt: new Date(Date.now() - 60000), // Expired 1 minute ago\n        attemptsUsed: 0,\n      });\n\n      // Try to verify with one of the expired codes\n      const verifyRequest = new NextRequest('http://localhost/api/auth/verify-email', {\n        method: 'POST',\n        body: JSON.stringify({\n          email: 'test@example.com',\n          code: '111111',\n        }),\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n\n      const verifyResponse = await verifyEmailHandler(verifyRequest);\n      const verifyData = await verifyResponse.json();\n\n      // Assert expired code error\n      expect(verifyResponse.status).toBe(400);\n      expect(verifyData.error).toContain('Verification code has expired');\n\n      // Cleanup expired codes\n      await emailVerificationCodeService.cleanupExpiredCodes();\n\n      // Verify all expired codes were cleaned up\n      const remainingCodes = await dbManager.getEmailCodesByUserId(user.id);\n      expect(remainingCodes).toHaveLength(0);\n    });\n  });\n\n  describe('Concurrent Verification Attempts and Race Conditions', () => {\n    it('should handle concurrent verification attempts safely', async () => {\n      // Create user with verification code\n      const user = await dbManager.createTestUser({\n        email: 'test@example.com',\n        name: 'Test User',\n        passwordHash: 'hashed_password',\n        isEmailVerified: false,\n      });\n\n      await dbManager.createTestEmailCode({\n        userId: user.id,\n        code: '123456',\n        expiresAt: new Date(Date.now() + 600000),\n        attemptsUsed: 0,\n      });\n\n      // Execute concurrent verification attempts\n      const promises = [\n        emailVerificationCodeService.validateCode('test@example.com', '123456'),\n        emailVerificationCodeService.validateCode('test@example.com', '123456'),\n      ];\n\n      // One should succeed, one should fail\n      const results = await Promise.allSettled(promises);\n      \n      const successCount = results.filter(r => r.status === 'fulfilled' && r.value === true).length;\n      const failureCount = results.filter(r => r.status === 'rejected').length;\n\n      // At least one should succeed, and there might be failures due to race conditions\n      expect(successCount).toBeGreaterThanOrEqual(1);\n\n      // Verify user is verified\n      const verifiedUser = await dbManager.getUserById(user.id);\n      expect(verifiedUser.isEmailVerified).toBe(true);\n\n      // Verify code was deleted\n      const remainingCodes = await dbManager.getEmailCodesByUserId(user.id);\n      expect(remainingCodes).toHaveLength(0);\n    });\n\n    it('should handle concurrent code generation requests safely', async () => {\n      // Create user\n      const user = await dbManager.createTestUser({\n        email: 'test@example.com',\n        name: 'Test User',\n        passwordHash: 'hashed_password',\n        isEmailVerified: false,\n      });\n\n      // Execute concurrent code generation requests\n      const promises = [\n        emailVerificationCodeService.generateCode(user.id),\n        emailVerificationCodeService.generateCode(user.id),\n      ];\n\n      const codes = await Promise.all(promises);\n\n      // Both should succeed and return valid codes\n      expect(codes[0]).toMatch(/^\\d{6}$/);\n      expect(codes[1]).toMatch(/^\\d{6}$/);\n\n      // Verify only one code exists (latest one)\n      const emailCodes = await dbManager.getEmailCodesByUserId(user.id);\n      expect(emailCodes).toHaveLength(1);\n      \n      // The remaining code should be one of the generated codes\n      expect([codes[0], codes[1]]).toContain(emailCodes[0].code);\n    });\n\n    it('should handle race condition between verification and code expiration', async () => {\n      // Create user with code that expires very soon\n      const user = await dbManager.createTestUser({\n        email: 'test@example.com',\n        name: 'Test User',\n        passwordHash: 'hashed_password',\n        isEmailVerified: false,\n      });\n\n      await dbManager.createTestEmailCode({\n        userId: user.id,\n        code: '123456',\n        expiresAt: new Date(Date.now() + 100), // Expires in 100ms\n        attemptsUsed: 0,\n      });\n\n      // Wait for code to expire\n      await new Promise(resolve => setTimeout(resolve, 150));\n\n      // Try to verify with expired code using service\n      try {\n        await emailVerificationCodeService.validateCode('test@example.com', '123456');\n        fail('Should have thrown an error for expired code');\n      } catch (error: any) {\n        expect(error.code).toBe('CODE_EXPIRED');\n      }\n\n      // User should remain unverified\n      const unverifiedUser = await dbManager.getUserById(user.id);\n      expect(unverifiedUser.isEmailVerified).toBe(false);\n    });\n\n    it('should handle concurrent code generation for same user', async () => {\n      // Create user\n      const user = await dbManager.createTestUser({\n        email: 'test@example.com',\n        name: 'Test User',\n        passwordHash: 'hashed_password',\n        isEmailVerified: false,\n      });\n\n      // Execute multiple concurrent code generation requests\n      const promises = Array(5).fill(null).map(() => \n        emailVerificationCodeService.generateCode(user.id)\n      );\n\n      const codes = await Promise.all(promises);\n\n      // All should succeed and return valid codes\n      codes.forEach(code => {\n        expect(code).toMatch(/^\\d{6}$/);\n      });\n\n      // Verify only one code exists (latest one)\n      const emailCodes = await dbManager.getEmailCodesByUserId(user.id);\n      expect(emailCodes).toHaveLength(1);\n      \n      // The remaining code should be one of the generated codes\n      expect(codes).toContain(emailCodes[0].code);\n    });\n  });\n\n  describe('Database Error Scenarios', () => {\n    it('should handle maximum attempts reached', async () => {\n      const user = await dbManager.createTestUser({\n        email: 'test@example.com',\n        name: 'Test User',\n        passwordHash: 'hashed_password',\n        isEmailVerified: false,\n      });\n\n      // Create code with maximum attempts reached\n      await dbManager.createTestEmailCode({\n        userId: user.id,\n        code: '123456',\n        expiresAt: new Date(Date.now() + 600000),\n        attemptsUsed: 5, // Maximum attempts reached\n      });\n\n      // Try to verify with max attempts reached\n      try {\n        await emailVerificationCodeService.validateCode('test@example.com', '123456');\n        fail('Should have thrown an error for too many attempts');\n      } catch (error: any) {\n        expect(error.code).toBe('TOO_MANY_ATTEMPTS');\n      }\n\n      // User should remain unverified\n      const unverifiedUser = await dbManager.getUserById(user.id);\n      expect(unverifiedUser.isEmailVerified).toBe(false);\n    });\n\n    it('should handle service errors during validation', async () => {\n      // Test with non-existent user\n      try {\n        await emailVerificationCodeService.validateCode('nonexistent@example.com', '123456');\n        fail('Should have thrown an error for non-existent user');\n      } catch (error: any) {\n        expect(error.code).toBe('USER_NOT_FOUND');\n      }\n    });\n  });\n});"],"names":["jest","mock","mockEmailService","sendVerificationEmail","fn","mockCreateEmailService","createEmailService","mockSendEmailWithRetry","require","sendEmailWithRetry","originalEnv","process","env","beforeAll","RESEND_API_KEY","FROM_EMAIL","FROM_NAME","VERIFICATION_CODE_EXPIRY_MINUTES","MAX_VERIFICATION_ATTEMPTS","RESEND_COOLDOWN_SECONDS","MAX_RESEND_PER_HOUR","NODE_ENV","afterAll","describe","dbManager","beforeEach","clearAllMocks","createDatabaseTestManager","mockReturnValue","mockResolvedValue","afterEach","cleanup","it","mockRejectedValue","EmailServiceError","user","createTestUser","email","name","passwordHash","isEmailVerified","verificationCode","emailVerificationCodeService","generateCode","id","expect","toMatch","emailCodes","getEmailCodesByUserId","toHaveLength","code","toBe","unverifiedUser","getUserById","code1","code2","not","expiredCode","createTestEmailCode","userId","expiresAt","Date","now","attemptsUsed","validateCode","fail","error","cleanupExpiredCodes","remainingCodes","deleteUser","verifyRequest","NextRequest","method","body","JSON","stringify","headers","verifyResponse","verifyEmailHandler","verifyData","json","status","toContain","promises","results","Promise","allSettled","successCount","filter","r","value","length","failureCount","toBeGreaterThanOrEqual","verifiedUser","codes","all","resolve","setTimeout","Array","fill","map","forEach"],"mappings":"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"}