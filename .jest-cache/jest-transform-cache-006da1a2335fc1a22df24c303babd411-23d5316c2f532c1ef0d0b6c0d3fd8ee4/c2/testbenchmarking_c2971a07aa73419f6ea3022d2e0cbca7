511d6983c71618918f15b111e0341472
/**
 * Test Benchmarking and Alerting System
 * 
 * Provides performance benchmarking and alerting for CI/CD integration.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get recordBenchmark () {
        return recordBenchmark;
    },
    get saveBenchmarkReport () {
        return saveBenchmarkReport;
    },
    get testBenchmarkingSystem () {
        return testBenchmarkingSystem;
    },
    get withBenchmarking () {
        return withBenchmarking;
    }
});
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
/**
 * Test benchmarking system for performance monitoring
 */ class TestBenchmarkingSystem {
    constructor(){
        this.results = [];
        this.baselines = new Map();
        this.thresholds = new Map();
        this.alerts = [];
        // Load baseline data if available
        this.loadBaselines();
        // Set default thresholds
        this.setDefaultThresholds();
    }
    /**
   * Record a benchmark result
   */ recordBenchmark(testName, duration, memoryUsage, environment = 'local') {
        const result = {
            testName,
            duration,
            memoryUsage,
            timestamp: new Date(),
            environment,
            branch: process.env.GITHUB_REF_NAME || process.env.BRANCH_NAME,
            commit: process.env.GITHUB_SHA || process.env.COMMIT_SHA
        };
        this.results.push(result);
        this.checkThresholds(result);
        this.checkRegression(result);
    }
    /**
   * Set performance thresholds for a test
   */ setThresholds(testName, thresholds) {
        this.thresholds.set(testName, thresholds);
    }
    /**
   * Set baseline performance for comparison
   */ setBaseline(testName, result) {
        this.baselines.set(testName, result);
    }
    /**
   * Generate comprehensive benchmark report
   */ generateReport() {
        const totalTests = this.results.length;
        const totalDuration = this.results.reduce((sum, r)=>sum + r.duration, 0);
        const averageDuration = totalTests > 0 ? totalDuration / totalTests : 0;
        const memoryPeak = Math.max(...this.results.map((r)=>r.memoryUsage));
        // Find slowest tests
        const slowestTests = [
            ...this.results
        ].sort((a, b)=>b.duration - a.duration).slice(0, 10);
        // Find regressions
        const regressions = this.findRegressions();
        return {
            summary: {
                totalTests,
                averageDuration,
                totalDuration,
                memoryPeak: memoryPeak / 1024 / 1024,
                alertCount: this.alerts.length
            },
            alerts: [
                ...this.alerts
            ],
            slowestTests,
            regressions
        };
    }
    /**
   * Generate CI-friendly report output
   */ generateCIReport() {
        const report = this.generateReport();
        const lines = [];
        lines.push('## ðŸ“Š Test Performance Report');
        lines.push('');
        lines.push('### ðŸ“ˆ Summary');
        lines.push(`- **Total Tests**: ${report.summary.totalTests}`);
        lines.push(`- **Average Duration**: ${report.summary.averageDuration.toFixed(2)}ms`);
        lines.push(`- **Total Duration**: ${report.summary.totalDuration.toFixed(2)}ms`);
        lines.push(`- **Memory Peak**: ${report.summary.memoryPeak.toFixed(2)}MB`);
        lines.push(`- **Alerts**: ${report.summary.alertCount}`);
        lines.push('');
        // Alerts section
        if (report.alerts.length > 0) {
            lines.push('### ðŸš¨ Performance Alerts');
            lines.push('| Test | Type | Severity | Details |');
            lines.push('|------|------|----------|---------|');
            report.alerts.forEach((alert)=>{
                const icon = alert.severity === 'error' ? 'ðŸ”´' : 'âš ï¸';
                lines.push(`| ${alert.testName} | ${alert.type} | ${icon} ${alert.severity} | ${alert.message} |`);
            });
            lines.push('');
        }
        // Slowest tests
        if (report.slowestTests.length > 0) {
            lines.push('### ðŸŒ Slowest Tests');
            lines.push('| Test | Duration | Memory |');
            lines.push('|------|----------|--------|');
            report.slowestTests.slice(0, 5).forEach((test)=>{
                lines.push(`| ${test.testName} | ${test.duration.toFixed(2)}ms | ${(test.memoryUsage / 1024 / 1024).toFixed(2)}MB |`);
            });
            lines.push('');
        }
        // Regressions
        if (report.regressions.length > 0) {
            lines.push('### ðŸ“‰ Performance Regressions');
            lines.push('| Test | Current | Baseline | Regression |');
            lines.push('|------|---------|----------|------------|');
            report.regressions.forEach((regression)=>{
                lines.push(`| ${regression.testName} | ${regression.currentDuration.toFixed(2)}ms | ${regression.baselineDuration.toFixed(2)}ms | +${regression.regressionPercent.toFixed(1)}% |`);
            });
            lines.push('');
        }
        return lines.join('\n');
    }
    /**
   * Export benchmark data for storage
   */ exportData() {
        return {
            results: this.results,
            baselines: Object.fromEntries(this.baselines),
            thresholds: Object.fromEntries(this.thresholds),
            alerts: this.alerts,
            timestamp: new Date().toISOString(),
            environment: process.env.CI ? 'ci' : 'local'
        };
    }
    /**
   * Import benchmark data
   */ importData(data) {
        if (data.results) {
            this.results = data.results;
        }
        if (data.baselines) {
            this.baselines = new Map(Object.entries(data.baselines));
        }
        if (data.thresholds) {
            this.thresholds = new Map(Object.entries(data.thresholds));
        }
        if (data.alerts) {
            this.alerts = data.alerts;
        }
    }
    /**
   * Check if result exceeds thresholds
   */ checkThresholds(result) {
        const thresholds = this.thresholds.get(result.testName) || this.getDefaultThresholds();
        // Check duration threshold
        if (result.duration > thresholds.maxDuration) {
            this.alerts.push({
                type: 'duration',
                severity: result.duration > thresholds.maxDuration * 2 ? 'error' : 'warning',
                testName: result.testName,
                current: result.duration,
                threshold: thresholds.maxDuration,
                message: `Test duration ${result.duration.toFixed(2)}ms exceeds threshold ${thresholds.maxDuration}ms`
            });
        }
        // Check memory threshold
        const memoryMB = result.memoryUsage / 1024 / 1024;
        if (memoryMB > thresholds.maxMemoryMB) {
            this.alerts.push({
                type: 'memory',
                severity: memoryMB > thresholds.maxMemoryMB * 2 ? 'error' : 'warning',
                testName: result.testName,
                current: memoryMB,
                threshold: thresholds.maxMemoryMB,
                message: `Memory usage ${memoryMB.toFixed(2)}MB exceeds threshold ${thresholds.maxMemoryMB}MB`
            });
        }
    }
    /**
   * Check for performance regression
   */ checkRegression(result) {
        const baseline = this.baselines.get(result.testName);
        if (!baseline) return;
        const thresholds = this.thresholds.get(result.testName) || this.getDefaultThresholds();
        const regressionPercent = (result.duration - baseline.duration) / baseline.duration * 100;
        if (regressionPercent > thresholds.regressionThreshold) {
            this.alerts.push({
                type: 'regression',
                severity: regressionPercent > thresholds.regressionThreshold * 2 ? 'error' : 'warning',
                testName: result.testName,
                current: result.duration,
                threshold: baseline.duration * (1 + thresholds.regressionThreshold / 100),
                baseline: baseline.duration,
                message: `Performance regression of ${regressionPercent.toFixed(1)}% detected`
            });
        }
    }
    /**
   * Find all performance regressions
   */ findRegressions() {
        const regressions = [];
        this.results.forEach((result)=>{
            const baseline = this.baselines.get(result.testName);
            if (baseline) {
                const regressionPercent = (result.duration - baseline.duration) / baseline.duration * 100;
                if (regressionPercent > 10) {
                    regressions.push({
                        testName: result.testName,
                        currentDuration: result.duration,
                        baselineDuration: baseline.duration,
                        regressionPercent
                    });
                }
            }
        });
        return regressions.sort((a, b)=>b.regressionPercent - a.regressionPercent);
    }
    /**
   * Load baseline data from storage
   */ loadBaselines() {
        try {
            // In a real implementation, would load from file or database
            const baselineData = process.env.BENCHMARK_BASELINES;
            if (baselineData) {
                const baselines = JSON.parse(baselineData);
                this.baselines = new Map(Object.entries(baselines));
            }
        } catch (error) {
            console.warn('Failed to load benchmark baselines:', error);
        }
    }
    /**
   * Set default performance thresholds
   */ setDefaultThresholds() {
        const defaultThresholds = {
            maxDuration: 1000,
            maxMemoryMB: 50,
            regressionThreshold: 20
        };
        // Set specific thresholds for different test types
        this.thresholds.set('unit', {
            maxDuration: 100,
            maxMemoryMB: 10,
            regressionThreshold: 15
        });
        this.thresholds.set('integration', {
            maxDuration: 2000,
            maxMemoryMB: 100,
            regressionThreshold: 25
        });
        this.thresholds.set('e2e', {
            maxDuration: 10000,
            maxMemoryMB: 200,
            regressionThreshold: 30
        });
    }
    /**
   * Get default thresholds
   */ getDefaultThresholds() {
        return {
            maxDuration: 1000,
            maxMemoryMB: 50,
            regressionThreshold: 20
        };
    }
    /**
   * Clear all data
   */ reset() {
        this.results = [];
        this.alerts = [];
    }
}
const testBenchmarkingSystem = new TestBenchmarkingSystem();
function withBenchmarking(testType = 'unit') {
    beforeEach(()=>{
        const testName = expect.getState().currentTestName || 'unknown';
        const startTime = performance.now();
        const startMemory = process.memoryUsage().heapUsed;
        // Store start metrics
        global.__testStartTime = startTime;
        global.__testStartMemory = startMemory;
    });
    afterEach(()=>{
        const testName = expect.getState().currentTestName || 'unknown';
        const endTime = performance.now();
        const endMemory = process.memoryUsage().heapUsed;
        const duration = endTime - global.__testStartTime;
        const memoryUsage = endMemory - global.__testStartMemory;
        testBenchmarkingSystem.recordBenchmark(testName, duration, memoryUsage, process.env.CI ? 'ci' : 'local');
    });
}
function recordBenchmark(testName, duration, memoryUsage) {
    testBenchmarkingSystem.recordBenchmark(testName, duration, memoryUsage);
}
async function saveBenchmarkReport(outputPath = 'coverage/benchmark-report.json') {
    const report = testBenchmarkingSystem.generateReport();
    const data = testBenchmarkingSystem.exportData();
    try {
        // Save detailed data
        const fs = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("fs")));
        fs.writeFileSync(outputPath, JSON.stringify(data, null, 2));
        // Save CI report
        const ciReport = testBenchmarkingSystem.generateCIReport();
        fs.writeFileSync(outputPath.replace('.json', '-ci.md'), ciReport);
        console.log(`ðŸ“Š Benchmark report saved to ${outputPath}`);
    } catch (error) {
        console.error('Failed to save benchmark report:', error);
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdGVmYW5iZWtrZXIvcHJvamVjdHMvZmFuY3ktcGxhbnRpZXMvc3JjL3Rlc3QtdXRpbHMvcGVyZm9ybWFuY2UvdGVzdC1iZW5jaG1hcmtpbmcudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUZXN0IEJlbmNobWFya2luZyBhbmQgQWxlcnRpbmcgU3lzdGVtXG4gKiBcbiAqIFByb3ZpZGVzIHBlcmZvcm1hbmNlIGJlbmNobWFya2luZyBhbmQgYWxlcnRpbmcgZm9yIENJL0NEIGludGVncmF0aW9uLlxuICovXG5cbmludGVyZmFjZSBCZW5jaG1hcmtSZXN1bHQge1xuICB0ZXN0TmFtZTogc3RyaW5nO1xuICBkdXJhdGlvbjogbnVtYmVyO1xuICBtZW1vcnlVc2FnZTogbnVtYmVyO1xuICB0aW1lc3RhbXA6IERhdGU7XG4gIGVudmlyb25tZW50OiAnbG9jYWwnIHwgJ2NpJztcbiAgYnJhbmNoPzogc3RyaW5nO1xuICBjb21taXQ/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBCZW5jaG1hcmtUaHJlc2hvbGRzIHtcbiAgbWF4RHVyYXRpb246IG51bWJlcjtcbiAgbWF4TWVtb3J5TUI6IG51bWJlcjtcbiAgcmVncmVzc2lvblRocmVzaG9sZDogbnVtYmVyOyAvLyBQZXJjZW50YWdlIGluY3JlYXNlIHRoYXQgdHJpZ2dlcnMgYWxlcnRcbn1cblxuaW50ZXJmYWNlIFBlcmZvcm1hbmNlQWxlcnQge1xuICB0eXBlOiAnZHVyYXRpb24nIHwgJ21lbW9yeScgfCAncmVncmVzc2lvbic7XG4gIHNldmVyaXR5OiAnd2FybmluZycgfCAnZXJyb3InO1xuICB0ZXN0TmFtZTogc3RyaW5nO1xuICBjdXJyZW50OiBudW1iZXI7XG4gIHRocmVzaG9sZDogbnVtYmVyO1xuICBiYXNlbGluZT86IG51bWJlcjtcbiAgbWVzc2FnZTogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgQmVuY2htYXJrUmVwb3J0IHtcbiAgc3VtbWFyeToge1xuICAgIHRvdGFsVGVzdHM6IG51bWJlcjtcbiAgICBhdmVyYWdlRHVyYXRpb246IG51bWJlcjtcbiAgICB0b3RhbER1cmF0aW9uOiBudW1iZXI7XG4gICAgbWVtb3J5UGVhazogbnVtYmVyO1xuICAgIGFsZXJ0Q291bnQ6IG51bWJlcjtcbiAgfTtcbiAgYWxlcnRzOiBQZXJmb3JtYW5jZUFsZXJ0W107XG4gIHNsb3dlc3RUZXN0czogQmVuY2htYXJrUmVzdWx0W107XG4gIHJlZ3Jlc3Npb25zOiBBcnJheTx7XG4gICAgdGVzdE5hbWU6IHN0cmluZztcbiAgICBjdXJyZW50RHVyYXRpb246IG51bWJlcjtcbiAgICBiYXNlbGluZUR1cmF0aW9uOiBudW1iZXI7XG4gICAgcmVncmVzc2lvblBlcmNlbnQ6IG51bWJlcjtcbiAgfT47XG59XG5cbi8qKlxuICogVGVzdCBiZW5jaG1hcmtpbmcgc3lzdGVtIGZvciBwZXJmb3JtYW5jZSBtb25pdG9yaW5nXG4gKi9cbmNsYXNzIFRlc3RCZW5jaG1hcmtpbmdTeXN0ZW0ge1xuICBwcml2YXRlIHJlc3VsdHM6IEJlbmNobWFya1Jlc3VsdFtdID0gW107XG4gIHByaXZhdGUgYmFzZWxpbmVzID0gbmV3IE1hcDxzdHJpbmcsIEJlbmNobWFya1Jlc3VsdD4oKTtcbiAgcHJpdmF0ZSB0aHJlc2hvbGRzOiBNYXA8c3RyaW5nLCBCZW5jaG1hcmtUaHJlc2hvbGRzPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBhbGVydHM6IFBlcmZvcm1hbmNlQWxlcnRbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIExvYWQgYmFzZWxpbmUgZGF0YSBpZiBhdmFpbGFibGVcbiAgICB0aGlzLmxvYWRCYXNlbGluZXMoKTtcbiAgICBcbiAgICAvLyBTZXQgZGVmYXVsdCB0aHJlc2hvbGRzXG4gICAgdGhpcy5zZXREZWZhdWx0VGhyZXNob2xkcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY29yZCBhIGJlbmNobWFyayByZXN1bHRcbiAgICovXG4gIHJlY29yZEJlbmNobWFyayhcbiAgICB0ZXN0TmFtZTogc3RyaW5nLFxuICAgIGR1cmF0aW9uOiBudW1iZXIsXG4gICAgbWVtb3J5VXNhZ2U6IG51bWJlcixcbiAgICBlbnZpcm9ubWVudDogJ2xvY2FsJyB8ICdjaScgPSAnbG9jYWwnXG4gICk6IHZvaWQge1xuICAgIGNvbnN0IHJlc3VsdDogQmVuY2htYXJrUmVzdWx0ID0ge1xuICAgICAgdGVzdE5hbWUsXG4gICAgICBkdXJhdGlvbixcbiAgICAgIG1lbW9yeVVzYWdlLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgZW52aXJvbm1lbnQsXG4gICAgICBicmFuY2g6IHByb2Nlc3MuZW52LkdJVEhVQl9SRUZfTkFNRSB8fCBwcm9jZXNzLmVudi5CUkFOQ0hfTkFNRSxcbiAgICAgIGNvbW1pdDogcHJvY2Vzcy5lbnYuR0lUSFVCX1NIQSB8fCBwcm9jZXNzLmVudi5DT01NSVRfU0hBLFxuICAgIH07XG5cbiAgICB0aGlzLnJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgIHRoaXMuY2hlY2tUaHJlc2hvbGRzKHJlc3VsdCk7XG4gICAgdGhpcy5jaGVja1JlZ3Jlc3Npb24ocmVzdWx0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgcGVyZm9ybWFuY2UgdGhyZXNob2xkcyBmb3IgYSB0ZXN0XG4gICAqL1xuICBzZXRUaHJlc2hvbGRzKHRlc3ROYW1lOiBzdHJpbmcsIHRocmVzaG9sZHM6IEJlbmNobWFya1RocmVzaG9sZHMpOiB2b2lkIHtcbiAgICB0aGlzLnRocmVzaG9sZHMuc2V0KHRlc3ROYW1lLCB0aHJlc2hvbGRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYmFzZWxpbmUgcGVyZm9ybWFuY2UgZm9yIGNvbXBhcmlzb25cbiAgICovXG4gIHNldEJhc2VsaW5lKHRlc3ROYW1lOiBzdHJpbmcsIHJlc3VsdDogQmVuY2htYXJrUmVzdWx0KTogdm9pZCB7XG4gICAgdGhpcy5iYXNlbGluZXMuc2V0KHRlc3ROYW1lLCByZXN1bHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGNvbXByZWhlbnNpdmUgYmVuY2htYXJrIHJlcG9ydFxuICAgKi9cbiAgZ2VuZXJhdGVSZXBvcnQoKTogQmVuY2htYXJrUmVwb3J0IHtcbiAgICBjb25zdCB0b3RhbFRlc3RzID0gdGhpcy5yZXN1bHRzLmxlbmd0aDtcbiAgICBjb25zdCB0b3RhbER1cmF0aW9uID0gdGhpcy5yZXN1bHRzLnJlZHVjZSgoc3VtLCByKSA9PiBzdW0gKyByLmR1cmF0aW9uLCAwKTtcbiAgICBjb25zdCBhdmVyYWdlRHVyYXRpb24gPSB0b3RhbFRlc3RzID4gMCA/IHRvdGFsRHVyYXRpb24gLyB0b3RhbFRlc3RzIDogMDtcbiAgICBjb25zdCBtZW1vcnlQZWFrID0gTWF0aC5tYXgoLi4udGhpcy5yZXN1bHRzLm1hcChyID0+IHIubWVtb3J5VXNhZ2UpKTtcblxuICAgIC8vIEZpbmQgc2xvd2VzdCB0ZXN0c1xuICAgIGNvbnN0IHNsb3dlc3RUZXN0cyA9IFsuLi50aGlzLnJlc3VsdHNdXG4gICAgICAuc29ydCgoYSwgYikgPT4gYi5kdXJhdGlvbiAtIGEuZHVyYXRpb24pXG4gICAgICAuc2xpY2UoMCwgMTApO1xuXG4gICAgLy8gRmluZCByZWdyZXNzaW9uc1xuICAgIGNvbnN0IHJlZ3Jlc3Npb25zID0gdGhpcy5maW5kUmVncmVzc2lvbnMoKTtcblxuICAgIHJldHVybiB7XG4gICAgICBzdW1tYXJ5OiB7XG4gICAgICAgIHRvdGFsVGVzdHMsXG4gICAgICAgIGF2ZXJhZ2VEdXJhdGlvbixcbiAgICAgICAgdG90YWxEdXJhdGlvbixcbiAgICAgICAgbWVtb3J5UGVhazogbWVtb3J5UGVhayAvIDEwMjQgLyAxMDI0LCAvLyBDb252ZXJ0IHRvIE1CXG4gICAgICAgIGFsZXJ0Q291bnQ6IHRoaXMuYWxlcnRzLmxlbmd0aCxcbiAgICAgIH0sXG4gICAgICBhbGVydHM6IFsuLi50aGlzLmFsZXJ0c10sXG4gICAgICBzbG93ZXN0VGVzdHMsXG4gICAgICByZWdyZXNzaW9ucyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIENJLWZyaWVuZGx5IHJlcG9ydCBvdXRwdXRcbiAgICovXG4gIGdlbmVyYXRlQ0lSZXBvcnQoKTogc3RyaW5nIHtcbiAgICBjb25zdCByZXBvcnQgPSB0aGlzLmdlbmVyYXRlUmVwb3J0KCk7XG4gICAgY29uc3QgbGluZXM6IHN0cmluZ1tdID0gW107XG5cbiAgICBsaW5lcy5wdXNoKCcjIyDwn5OKIFRlc3QgUGVyZm9ybWFuY2UgUmVwb3J0Jyk7XG4gICAgbGluZXMucHVzaCgnJyk7XG4gICAgbGluZXMucHVzaCgnIyMjIPCfk4ggU3VtbWFyeScpO1xuICAgIGxpbmVzLnB1c2goYC0gKipUb3RhbCBUZXN0cyoqOiAke3JlcG9ydC5zdW1tYXJ5LnRvdGFsVGVzdHN9YCk7XG4gICAgbGluZXMucHVzaChgLSAqKkF2ZXJhZ2UgRHVyYXRpb24qKjogJHtyZXBvcnQuc3VtbWFyeS5hdmVyYWdlRHVyYXRpb24udG9GaXhlZCgyKX1tc2ApO1xuICAgIGxpbmVzLnB1c2goYC0gKipUb3RhbCBEdXJhdGlvbioqOiAke3JlcG9ydC5zdW1tYXJ5LnRvdGFsRHVyYXRpb24udG9GaXhlZCgyKX1tc2ApO1xuICAgIGxpbmVzLnB1c2goYC0gKipNZW1vcnkgUGVhayoqOiAke3JlcG9ydC5zdW1tYXJ5Lm1lbW9yeVBlYWsudG9GaXhlZCgyKX1NQmApO1xuICAgIGxpbmVzLnB1c2goYC0gKipBbGVydHMqKjogJHtyZXBvcnQuc3VtbWFyeS5hbGVydENvdW50fWApO1xuICAgIGxpbmVzLnB1c2goJycpO1xuXG4gICAgLy8gQWxlcnRzIHNlY3Rpb25cbiAgICBpZiAocmVwb3J0LmFsZXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICBsaW5lcy5wdXNoKCcjIyMg8J+aqCBQZXJmb3JtYW5jZSBBbGVydHMnKTtcbiAgICAgIGxpbmVzLnB1c2goJ3wgVGVzdCB8IFR5cGUgfCBTZXZlcml0eSB8IERldGFpbHMgfCcpO1xuICAgICAgbGluZXMucHVzaCgnfC0tLS0tLXwtLS0tLS18LS0tLS0tLS0tLXwtLS0tLS0tLS18Jyk7XG4gICAgICBcbiAgICAgIHJlcG9ydC5hbGVydHMuZm9yRWFjaChhbGVydCA9PiB7XG4gICAgICAgIGNvbnN0IGljb24gPSBhbGVydC5zZXZlcml0eSA9PT0gJ2Vycm9yJyA/ICfwn5S0JyA6ICfimqDvuI8nO1xuICAgICAgICBsaW5lcy5wdXNoKGB8ICR7YWxlcnQudGVzdE5hbWV9IHwgJHthbGVydC50eXBlfSB8ICR7aWNvbn0gJHthbGVydC5zZXZlcml0eX0gfCAke2FsZXJ0Lm1lc3NhZ2V9IHxgKTtcbiAgICAgIH0pO1xuICAgICAgbGluZXMucHVzaCgnJyk7XG4gICAgfVxuXG4gICAgLy8gU2xvd2VzdCB0ZXN0c1xuICAgIGlmIChyZXBvcnQuc2xvd2VzdFRlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIGxpbmVzLnB1c2goJyMjIyDwn5CMIFNsb3dlc3QgVGVzdHMnKTtcbiAgICAgIGxpbmVzLnB1c2goJ3wgVGVzdCB8IER1cmF0aW9uIHwgTWVtb3J5IHwnKTtcbiAgICAgIGxpbmVzLnB1c2goJ3wtLS0tLS18LS0tLS0tLS0tLXwtLS0tLS0tLXwnKTtcbiAgICAgIFxuICAgICAgcmVwb3J0LnNsb3dlc3RUZXN0cy5zbGljZSgwLCA1KS5mb3JFYWNoKHRlc3QgPT4ge1xuICAgICAgICBsaW5lcy5wdXNoKGB8ICR7dGVzdC50ZXN0TmFtZX0gfCAke3Rlc3QuZHVyYXRpb24udG9GaXhlZCgyKX1tcyB8ICR7KHRlc3QubWVtb3J5VXNhZ2UgLyAxMDI0IC8gMTAyNCkudG9GaXhlZCgyKX1NQiB8YCk7XG4gICAgICB9KTtcbiAgICAgIGxpbmVzLnB1c2goJycpO1xuICAgIH1cblxuICAgIC8vIFJlZ3Jlc3Npb25zXG4gICAgaWYgKHJlcG9ydC5yZWdyZXNzaW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBsaW5lcy5wdXNoKCcjIyMg8J+TiSBQZXJmb3JtYW5jZSBSZWdyZXNzaW9ucycpO1xuICAgICAgbGluZXMucHVzaCgnfCBUZXN0IHwgQ3VycmVudCB8IEJhc2VsaW5lIHwgUmVncmVzc2lvbiB8Jyk7XG4gICAgICBsaW5lcy5wdXNoKCd8LS0tLS0tfC0tLS0tLS0tLXwtLS0tLS0tLS0tfC0tLS0tLS0tLS0tLXwnKTtcbiAgICAgIFxuICAgICAgcmVwb3J0LnJlZ3Jlc3Npb25zLmZvckVhY2gocmVncmVzc2lvbiA9PiB7XG4gICAgICAgIGxpbmVzLnB1c2goYHwgJHtyZWdyZXNzaW9uLnRlc3ROYW1lfSB8ICR7cmVncmVzc2lvbi5jdXJyZW50RHVyYXRpb24udG9GaXhlZCgyKX1tcyB8ICR7cmVncmVzc2lvbi5iYXNlbGluZUR1cmF0aW9uLnRvRml4ZWQoMil9bXMgfCArJHtyZWdyZXNzaW9uLnJlZ3Jlc3Npb25QZXJjZW50LnRvRml4ZWQoMSl9JSB8YCk7XG4gICAgICB9KTtcbiAgICAgIGxpbmVzLnB1c2goJycpO1xuICAgIH1cblxuICAgIHJldHVybiBsaW5lcy5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvcnQgYmVuY2htYXJrIGRhdGEgZm9yIHN0b3JhZ2VcbiAgICovXG4gIGV4cG9ydERhdGEoKTogYW55IHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0czogdGhpcy5yZXN1bHRzLFxuICAgICAgYmFzZWxpbmVzOiBPYmplY3QuZnJvbUVudHJpZXModGhpcy5iYXNlbGluZXMpLFxuICAgICAgdGhyZXNob2xkczogT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMudGhyZXNob2xkcyksXG4gICAgICBhbGVydHM6IHRoaXMuYWxlcnRzLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICBlbnZpcm9ubWVudDogcHJvY2Vzcy5lbnYuQ0kgPyAnY2knIDogJ2xvY2FsJyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEltcG9ydCBiZW5jaG1hcmsgZGF0YVxuICAgKi9cbiAgaW1wb3J0RGF0YShkYXRhOiBhbnkpOiB2b2lkIHtcbiAgICBpZiAoZGF0YS5yZXN1bHRzKSB7XG4gICAgICB0aGlzLnJlc3VsdHMgPSBkYXRhLnJlc3VsdHM7XG4gICAgfVxuICAgIGlmIChkYXRhLmJhc2VsaW5lcykge1xuICAgICAgdGhpcy5iYXNlbGluZXMgPSBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKGRhdGEuYmFzZWxpbmVzKSk7XG4gICAgfVxuICAgIGlmIChkYXRhLnRocmVzaG9sZHMpIHtcbiAgICAgIHRoaXMudGhyZXNob2xkcyA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoZGF0YS50aHJlc2hvbGRzKSk7XG4gICAgfVxuICAgIGlmIChkYXRhLmFsZXJ0cykge1xuICAgICAgdGhpcy5hbGVydHMgPSBkYXRhLmFsZXJ0cztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgcmVzdWx0IGV4Y2VlZHMgdGhyZXNob2xkc1xuICAgKi9cbiAgcHJpdmF0ZSBjaGVja1RocmVzaG9sZHMocmVzdWx0OiBCZW5jaG1hcmtSZXN1bHQpOiB2b2lkIHtcbiAgICBjb25zdCB0aHJlc2hvbGRzID0gdGhpcy50aHJlc2hvbGRzLmdldChyZXN1bHQudGVzdE5hbWUpIHx8IHRoaXMuZ2V0RGVmYXVsdFRocmVzaG9sZHMoKTtcbiAgICBcbiAgICAvLyBDaGVjayBkdXJhdGlvbiB0aHJlc2hvbGRcbiAgICBpZiAocmVzdWx0LmR1cmF0aW9uID4gdGhyZXNob2xkcy5tYXhEdXJhdGlvbikge1xuICAgICAgdGhpcy5hbGVydHMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdkdXJhdGlvbicsXG4gICAgICAgIHNldmVyaXR5OiByZXN1bHQuZHVyYXRpb24gPiB0aHJlc2hvbGRzLm1heER1cmF0aW9uICogMiA/ICdlcnJvcicgOiAnd2FybmluZycsXG4gICAgICAgIHRlc3ROYW1lOiByZXN1bHQudGVzdE5hbWUsXG4gICAgICAgIGN1cnJlbnQ6IHJlc3VsdC5kdXJhdGlvbixcbiAgICAgICAgdGhyZXNob2xkOiB0aHJlc2hvbGRzLm1heER1cmF0aW9uLFxuICAgICAgICBtZXNzYWdlOiBgVGVzdCBkdXJhdGlvbiAke3Jlc3VsdC5kdXJhdGlvbi50b0ZpeGVkKDIpfW1zIGV4Y2VlZHMgdGhyZXNob2xkICR7dGhyZXNob2xkcy5tYXhEdXJhdGlvbn1tc2AsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBtZW1vcnkgdGhyZXNob2xkXG4gICAgY29uc3QgbWVtb3J5TUIgPSByZXN1bHQubWVtb3J5VXNhZ2UgLyAxMDI0IC8gMTAyNDtcbiAgICBpZiAobWVtb3J5TUIgPiB0aHJlc2hvbGRzLm1heE1lbW9yeU1CKSB7XG4gICAgICB0aGlzLmFsZXJ0cy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ21lbW9yeScsXG4gICAgICAgIHNldmVyaXR5OiBtZW1vcnlNQiA+IHRocmVzaG9sZHMubWF4TWVtb3J5TUIgKiAyID8gJ2Vycm9yJyA6ICd3YXJuaW5nJyxcbiAgICAgICAgdGVzdE5hbWU6IHJlc3VsdC50ZXN0TmFtZSxcbiAgICAgICAgY3VycmVudDogbWVtb3J5TUIsXG4gICAgICAgIHRocmVzaG9sZDogdGhyZXNob2xkcy5tYXhNZW1vcnlNQixcbiAgICAgICAgbWVzc2FnZTogYE1lbW9yeSB1c2FnZSAke21lbW9yeU1CLnRvRml4ZWQoMil9TUIgZXhjZWVkcyB0aHJlc2hvbGQgJHt0aHJlc2hvbGRzLm1heE1lbW9yeU1CfU1CYCxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBmb3IgcGVyZm9ybWFuY2UgcmVncmVzc2lvblxuICAgKi9cbiAgcHJpdmF0ZSBjaGVja1JlZ3Jlc3Npb24ocmVzdWx0OiBCZW5jaG1hcmtSZXN1bHQpOiB2b2lkIHtcbiAgICBjb25zdCBiYXNlbGluZSA9IHRoaXMuYmFzZWxpbmVzLmdldChyZXN1bHQudGVzdE5hbWUpO1xuICAgIGlmICghYmFzZWxpbmUpIHJldHVybjtcblxuICAgIGNvbnN0IHRocmVzaG9sZHMgPSB0aGlzLnRocmVzaG9sZHMuZ2V0KHJlc3VsdC50ZXN0TmFtZSkgfHwgdGhpcy5nZXREZWZhdWx0VGhyZXNob2xkcygpO1xuICAgIGNvbnN0IHJlZ3Jlc3Npb25QZXJjZW50ID0gKChyZXN1bHQuZHVyYXRpb24gLSBiYXNlbGluZS5kdXJhdGlvbikgLyBiYXNlbGluZS5kdXJhdGlvbikgKiAxMDA7XG5cbiAgICBpZiAocmVncmVzc2lvblBlcmNlbnQgPiB0aHJlc2hvbGRzLnJlZ3Jlc3Npb25UaHJlc2hvbGQpIHtcbiAgICAgIHRoaXMuYWxlcnRzLnB1c2goe1xuICAgICAgICB0eXBlOiAncmVncmVzc2lvbicsXG4gICAgICAgIHNldmVyaXR5OiByZWdyZXNzaW9uUGVyY2VudCA+IHRocmVzaG9sZHMucmVncmVzc2lvblRocmVzaG9sZCAqIDIgPyAnZXJyb3InIDogJ3dhcm5pbmcnLFxuICAgICAgICB0ZXN0TmFtZTogcmVzdWx0LnRlc3ROYW1lLFxuICAgICAgICBjdXJyZW50OiByZXN1bHQuZHVyYXRpb24sXG4gICAgICAgIHRocmVzaG9sZDogYmFzZWxpbmUuZHVyYXRpb24gKiAoMSArIHRocmVzaG9sZHMucmVncmVzc2lvblRocmVzaG9sZCAvIDEwMCksXG4gICAgICAgIGJhc2VsaW5lOiBiYXNlbGluZS5kdXJhdGlvbixcbiAgICAgICAgbWVzc2FnZTogYFBlcmZvcm1hbmNlIHJlZ3Jlc3Npb24gb2YgJHtyZWdyZXNzaW9uUGVyY2VudC50b0ZpeGVkKDEpfSUgZGV0ZWN0ZWRgLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgYWxsIHBlcmZvcm1hbmNlIHJlZ3Jlc3Npb25zXG4gICAqL1xuICBwcml2YXRlIGZpbmRSZWdyZXNzaW9ucygpOiBBcnJheTx7XG4gICAgdGVzdE5hbWU6IHN0cmluZztcbiAgICBjdXJyZW50RHVyYXRpb246IG51bWJlcjtcbiAgICBiYXNlbGluZUR1cmF0aW9uOiBudW1iZXI7XG4gICAgcmVncmVzc2lvblBlcmNlbnQ6IG51bWJlcjtcbiAgfT4ge1xuICAgIGNvbnN0IHJlZ3Jlc3Npb25zOiBBcnJheTx7XG4gICAgICB0ZXN0TmFtZTogc3RyaW5nO1xuICAgICAgY3VycmVudER1cmF0aW9uOiBudW1iZXI7XG4gICAgICBiYXNlbGluZUR1cmF0aW9uOiBudW1iZXI7XG4gICAgICByZWdyZXNzaW9uUGVyY2VudDogbnVtYmVyO1xuICAgIH0+ID0gW107XG5cbiAgICB0aGlzLnJlc3VsdHMuZm9yRWFjaChyZXN1bHQgPT4ge1xuICAgICAgY29uc3QgYmFzZWxpbmUgPSB0aGlzLmJhc2VsaW5lcy5nZXQocmVzdWx0LnRlc3ROYW1lKTtcbiAgICAgIGlmIChiYXNlbGluZSkge1xuICAgICAgICBjb25zdCByZWdyZXNzaW9uUGVyY2VudCA9ICgocmVzdWx0LmR1cmF0aW9uIC0gYmFzZWxpbmUuZHVyYXRpb24pIC8gYmFzZWxpbmUuZHVyYXRpb24pICogMTAwO1xuICAgICAgICBpZiAocmVncmVzc2lvblBlcmNlbnQgPiAxMCkgeyAvLyAxMCUgdGhyZXNob2xkIGZvciByZXBvcnRpbmdcbiAgICAgICAgICByZWdyZXNzaW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHRlc3ROYW1lOiByZXN1bHQudGVzdE5hbWUsXG4gICAgICAgICAgICBjdXJyZW50RHVyYXRpb246IHJlc3VsdC5kdXJhdGlvbixcbiAgICAgICAgICAgIGJhc2VsaW5lRHVyYXRpb246IGJhc2VsaW5lLmR1cmF0aW9uLFxuICAgICAgICAgICAgcmVncmVzc2lvblBlcmNlbnQsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZWdyZXNzaW9ucy5zb3J0KChhLCBiKSA9PiBiLnJlZ3Jlc3Npb25QZXJjZW50IC0gYS5yZWdyZXNzaW9uUGVyY2VudCk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBiYXNlbGluZSBkYXRhIGZyb20gc3RvcmFnZVxuICAgKi9cbiAgcHJpdmF0ZSBsb2FkQmFzZWxpbmVzKCk6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICAvLyBJbiBhIHJlYWwgaW1wbGVtZW50YXRpb24sIHdvdWxkIGxvYWQgZnJvbSBmaWxlIG9yIGRhdGFiYXNlXG4gICAgICBjb25zdCBiYXNlbGluZURhdGEgPSBwcm9jZXNzLmVudi5CRU5DSE1BUktfQkFTRUxJTkVTO1xuICAgICAgaWYgKGJhc2VsaW5lRGF0YSkge1xuICAgICAgICBjb25zdCBiYXNlbGluZXMgPSBKU09OLnBhcnNlKGJhc2VsaW5lRGF0YSk7XG4gICAgICAgIHRoaXMuYmFzZWxpbmVzID0gbmV3IE1hcChPYmplY3QuZW50cmllcyhiYXNlbGluZXMpKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gbG9hZCBiZW5jaG1hcmsgYmFzZWxpbmVzOicsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IGRlZmF1bHQgcGVyZm9ybWFuY2UgdGhyZXNob2xkc1xuICAgKi9cbiAgcHJpdmF0ZSBzZXREZWZhdWx0VGhyZXNob2xkcygpOiB2b2lkIHtcbiAgICBjb25zdCBkZWZhdWx0VGhyZXNob2xkczogQmVuY2htYXJrVGhyZXNob2xkcyA9IHtcbiAgICAgIG1heER1cmF0aW9uOiAxMDAwLCAvLyAxIHNlY29uZFxuICAgICAgbWF4TWVtb3J5TUI6IDUwLCAvLyA1ME1CXG4gICAgICByZWdyZXNzaW9uVGhyZXNob2xkOiAyMCwgLy8gMjAlIGluY3JlYXNlXG4gICAgfTtcblxuICAgIC8vIFNldCBzcGVjaWZpYyB0aHJlc2hvbGRzIGZvciBkaWZmZXJlbnQgdGVzdCB0eXBlc1xuICAgIHRoaXMudGhyZXNob2xkcy5zZXQoJ3VuaXQnLCB7XG4gICAgICBtYXhEdXJhdGlvbjogMTAwLFxuICAgICAgbWF4TWVtb3J5TUI6IDEwLFxuICAgICAgcmVncmVzc2lvblRocmVzaG9sZDogMTUsXG4gICAgfSk7XG5cbiAgICB0aGlzLnRocmVzaG9sZHMuc2V0KCdpbnRlZ3JhdGlvbicsIHtcbiAgICAgIG1heER1cmF0aW9uOiAyMDAwLFxuICAgICAgbWF4TWVtb3J5TUI6IDEwMCxcbiAgICAgIHJlZ3Jlc3Npb25UaHJlc2hvbGQ6IDI1LFxuICAgIH0pO1xuXG4gICAgdGhpcy50aHJlc2hvbGRzLnNldCgnZTJlJywge1xuICAgICAgbWF4RHVyYXRpb246IDEwMDAwLFxuICAgICAgbWF4TWVtb3J5TUI6IDIwMCxcbiAgICAgIHJlZ3Jlc3Npb25UaHJlc2hvbGQ6IDMwLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBkZWZhdWx0IHRocmVzaG9sZHNcbiAgICovXG4gIHByaXZhdGUgZ2V0RGVmYXVsdFRocmVzaG9sZHMoKTogQmVuY2htYXJrVGhyZXNob2xkcyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1heER1cmF0aW9uOiAxMDAwLFxuICAgICAgbWF4TWVtb3J5TUI6IDUwLFxuICAgICAgcmVncmVzc2lvblRocmVzaG9sZDogMjAsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgZGF0YVxuICAgKi9cbiAgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy5yZXN1bHRzID0gW107XG4gICAgdGhpcy5hbGVydHMgPSBbXTtcbiAgfVxufVxuXG4vLyBHbG9iYWwgaW5zdGFuY2VcbmV4cG9ydCBjb25zdCB0ZXN0QmVuY2htYXJraW5nU3lzdGVtID0gbmV3IFRlc3RCZW5jaG1hcmtpbmdTeXN0ZW0oKTtcblxuLyoqXG4gKiBKZXN0IGhlbHBlciBmb3IgYXV0b21hdGljIGJlbmNobWFya2luZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gd2l0aEJlbmNobWFya2luZyh0ZXN0VHlwZTogJ3VuaXQnIHwgJ2ludGVncmF0aW9uJyB8ICdlMmUnID0gJ3VuaXQnKSB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGNvbnN0IHRlc3ROYW1lID0gZXhwZWN0LmdldFN0YXRlKCkuY3VycmVudFRlc3ROYW1lIHx8ICd1bmtub3duJztcbiAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCBzdGFydE1lbW9yeSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKS5oZWFwVXNlZDtcbiAgICBcbiAgICAvLyBTdG9yZSBzdGFydCBtZXRyaWNzXG4gICAgKGdsb2JhbCBhcyBhbnkpLl9fdGVzdFN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgICAoZ2xvYmFsIGFzIGFueSkuX190ZXN0U3RhcnRNZW1vcnkgPSBzdGFydE1lbW9yeTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBjb25zdCB0ZXN0TmFtZSA9IGV4cGVjdC5nZXRTdGF0ZSgpLmN1cnJlbnRUZXN0TmFtZSB8fCAndW5rbm93bic7XG4gICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IGVuZE1lbW9yeSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKS5oZWFwVXNlZDtcbiAgICBcbiAgICBjb25zdCBkdXJhdGlvbiA9IGVuZFRpbWUgLSAoZ2xvYmFsIGFzIGFueSkuX190ZXN0U3RhcnRUaW1lO1xuICAgIGNvbnN0IG1lbW9yeVVzYWdlID0gZW5kTWVtb3J5IC0gKGdsb2JhbCBhcyBhbnkpLl9fdGVzdFN0YXJ0TWVtb3J5O1xuICAgIFxuICAgIHRlc3RCZW5jaG1hcmtpbmdTeXN0ZW0ucmVjb3JkQmVuY2htYXJrKFxuICAgICAgdGVzdE5hbWUsXG4gICAgICBkdXJhdGlvbixcbiAgICAgIG1lbW9yeVVzYWdlLFxuICAgICAgcHJvY2Vzcy5lbnYuQ0kgPyAnY2knIDogJ2xvY2FsJ1xuICAgICk7XG4gIH0pO1xufVxuXG4vKipcbiAqIE1hbnVhbCBiZW5jaG1hcmsgcmVjb3JkaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWNvcmRCZW5jaG1hcmsodGVzdE5hbWU6IHN0cmluZywgZHVyYXRpb246IG51bWJlciwgbWVtb3J5VXNhZ2U6IG51bWJlcik6IHZvaWQge1xuICB0ZXN0QmVuY2htYXJraW5nU3lzdGVtLnJlY29yZEJlbmNobWFyayh0ZXN0TmFtZSwgZHVyYXRpb24sIG1lbW9yeVVzYWdlKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhbmQgc2F2ZSBiZW5jaG1hcmsgcmVwb3J0XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzYXZlQmVuY2htYXJrUmVwb3J0KG91dHB1dFBhdGg6IHN0cmluZyA9ICdjb3ZlcmFnZS9iZW5jaG1hcmstcmVwb3J0Lmpzb24nKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IHJlcG9ydCA9IHRlc3RCZW5jaG1hcmtpbmdTeXN0ZW0uZ2VuZXJhdGVSZXBvcnQoKTtcbiAgY29uc3QgZGF0YSA9IHRlc3RCZW5jaG1hcmtpbmdTeXN0ZW0uZXhwb3J0RGF0YSgpO1xuICBcbiAgdHJ5IHtcbiAgICAvLyBTYXZlIGRldGFpbGVkIGRhdGFcbiAgICBjb25zdCBmcyA9IGF3YWl0IGltcG9ydCgnZnMnKTtcbiAgICBmcy53cml0ZUZpbGVTeW5jKG91dHB1dFBhdGgsIEpTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpKTtcbiAgICBcbiAgICAvLyBTYXZlIENJIHJlcG9ydFxuICAgIGNvbnN0IGNpUmVwb3J0ID0gdGVzdEJlbmNobWFya2luZ1N5c3RlbS5nZW5lcmF0ZUNJUmVwb3J0KCk7XG4gICAgZnMud3JpdGVGaWxlU3luYyhvdXRwdXRQYXRoLnJlcGxhY2UoJy5qc29uJywgJy1jaS5tZCcpLCBjaVJlcG9ydCk7XG4gICAgXG4gICAgY29uc29sZS5sb2coYPCfk4ogQmVuY2htYXJrIHJlcG9ydCBzYXZlZCB0byAke291dHB1dFBhdGh9YCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNhdmUgYmVuY2htYXJrIHJlcG9ydDonLCBlcnJvcik7XG4gIH1cbn0iXSwibmFtZXMiOlsicmVjb3JkQmVuY2htYXJrIiwic2F2ZUJlbmNobWFya1JlcG9ydCIsInRlc3RCZW5jaG1hcmtpbmdTeXN0ZW0iLCJ3aXRoQmVuY2htYXJraW5nIiwiVGVzdEJlbmNobWFya2luZ1N5c3RlbSIsInJlc3VsdHMiLCJiYXNlbGluZXMiLCJNYXAiLCJ0aHJlc2hvbGRzIiwiYWxlcnRzIiwibG9hZEJhc2VsaW5lcyIsInNldERlZmF1bHRUaHJlc2hvbGRzIiwidGVzdE5hbWUiLCJkdXJhdGlvbiIsIm1lbW9yeVVzYWdlIiwiZW52aXJvbm1lbnQiLCJyZXN1bHQiLCJ0aW1lc3RhbXAiLCJEYXRlIiwiYnJhbmNoIiwicHJvY2VzcyIsImVudiIsIkdJVEhVQl9SRUZfTkFNRSIsIkJSQU5DSF9OQU1FIiwiY29tbWl0IiwiR0lUSFVCX1NIQSIsIkNPTU1JVF9TSEEiLCJwdXNoIiwiY2hlY2tUaHJlc2hvbGRzIiwiY2hlY2tSZWdyZXNzaW9uIiwic2V0VGhyZXNob2xkcyIsInNldCIsInNldEJhc2VsaW5lIiwiZ2VuZXJhdGVSZXBvcnQiLCJ0b3RhbFRlc3RzIiwibGVuZ3RoIiwidG90YWxEdXJhdGlvbiIsInJlZHVjZSIsInN1bSIsInIiLCJhdmVyYWdlRHVyYXRpb24iLCJtZW1vcnlQZWFrIiwiTWF0aCIsIm1heCIsIm1hcCIsInNsb3dlc3RUZXN0cyIsInNvcnQiLCJhIiwiYiIsInNsaWNlIiwicmVncmVzc2lvbnMiLCJmaW5kUmVncmVzc2lvbnMiLCJzdW1tYXJ5IiwiYWxlcnRDb3VudCIsImdlbmVyYXRlQ0lSZXBvcnQiLCJyZXBvcnQiLCJsaW5lcyIsInRvRml4ZWQiLCJmb3JFYWNoIiwiYWxlcnQiLCJpY29uIiwic2V2ZXJpdHkiLCJ0eXBlIiwibWVzc2FnZSIsInRlc3QiLCJyZWdyZXNzaW9uIiwiY3VycmVudER1cmF0aW9uIiwiYmFzZWxpbmVEdXJhdGlvbiIsInJlZ3Jlc3Npb25QZXJjZW50Iiwiam9pbiIsImV4cG9ydERhdGEiLCJPYmplY3QiLCJmcm9tRW50cmllcyIsInRvSVNPU3RyaW5nIiwiQ0kiLCJpbXBvcnREYXRhIiwiZGF0YSIsImVudHJpZXMiLCJnZXQiLCJnZXREZWZhdWx0VGhyZXNob2xkcyIsIm1heER1cmF0aW9uIiwiY3VycmVudCIsInRocmVzaG9sZCIsIm1lbW9yeU1CIiwibWF4TWVtb3J5TUIiLCJiYXNlbGluZSIsInJlZ3Jlc3Npb25UaHJlc2hvbGQiLCJiYXNlbGluZURhdGEiLCJCRU5DSE1BUktfQkFTRUxJTkVTIiwiSlNPTiIsInBhcnNlIiwiZXJyb3IiLCJjb25zb2xlIiwid2FybiIsImRlZmF1bHRUaHJlc2hvbGRzIiwicmVzZXQiLCJ0ZXN0VHlwZSIsImJlZm9yZUVhY2giLCJleHBlY3QiLCJnZXRTdGF0ZSIsImN1cnJlbnRUZXN0TmFtZSIsInN0YXJ0VGltZSIsInBlcmZvcm1hbmNlIiwibm93Iiwic3RhcnRNZW1vcnkiLCJoZWFwVXNlZCIsImdsb2JhbCIsIl9fdGVzdFN0YXJ0VGltZSIsIl9fdGVzdFN0YXJ0TWVtb3J5IiwiYWZ0ZXJFYWNoIiwiZW5kVGltZSIsImVuZE1lbW9yeSIsIm91dHB1dFBhdGgiLCJmcyIsIndyaXRlRmlsZVN5bmMiLCJzdHJpbmdpZnkiLCJjaVJlcG9ydCIsInJlcGxhY2UiLCJsb2ciXSwibWFwcGluZ3MiOiJBQUFBOzs7O0NBSUM7Ozs7Ozs7Ozs7O1FBNlplQTtlQUFBQTs7UUFPTUM7ZUFBQUE7O1FBM0NUQztlQUFBQTs7UUFLR0M7ZUFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaFZoQjs7Q0FFQyxHQUNELE1BQU1DO0lBTUosYUFBYzthQUxOQyxVQUE2QixFQUFFO2FBQy9CQyxZQUFZLElBQUlDO2FBQ2hCQyxhQUErQyxJQUFJRDthQUNuREUsU0FBNkIsRUFBRTtRQUdyQyxrQ0FBa0M7UUFDbEMsSUFBSSxDQUFDQyxhQUFhO1FBRWxCLHlCQUF5QjtRQUN6QixJQUFJLENBQUNDLG9CQUFvQjtJQUMzQjtJQUVBOztHQUVDLEdBQ0RYLGdCQUNFWSxRQUFnQixFQUNoQkMsUUFBZ0IsRUFDaEJDLFdBQW1CLEVBQ25CQyxjQUE4QixPQUFPLEVBQy9CO1FBQ04sTUFBTUMsU0FBMEI7WUFDOUJKO1lBQ0FDO1lBQ0FDO1lBQ0FHLFdBQVcsSUFBSUM7WUFDZkg7WUFDQUksUUFBUUMsUUFBUUMsR0FBRyxDQUFDQyxlQUFlLElBQUlGLFFBQVFDLEdBQUcsQ0FBQ0UsV0FBVztZQUM5REMsUUFBUUosUUFBUUMsR0FBRyxDQUFDSSxVQUFVLElBQUlMLFFBQVFDLEdBQUcsQ0FBQ0ssVUFBVTtR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