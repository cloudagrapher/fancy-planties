c1ab9b00fe6e809780c382c16bc81327
/**
 * Efficient Test Data Setup and Teardown
 * 
 * Provides optimized utilities for fast test data creation and cleanup.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get BatchOperations () {
        return BatchOperations;
    },
    get LazyTestData () {
        return LazyTestData;
    },
    get createPlantInstancePool () {
        return createPlantInstancePool;
    },
    get createPlantPool () {
        return createPlantPool;
    },
    get createUserPool () {
        return createUserPool;
    },
    get efficientTestData () {
        return efficientTestData;
    },
    get generateTestData () {
        return generateTestData;
    },
    get setupEfficientTestData () {
        return setupEfficientTestData;
    },
    get setupTransactionIsolation () {
        return setupTransactionIsolation;
    }
});
/**
 * Efficient test data manager with object pooling
 */ class EfficientTestDataManager {
    /**
   * Create a data pool for reusable test objects
   */ createPool(poolName, factory, cleanup, initialSize = 5) {
        const pool = {
            available: [],
            inUse: new Set(),
            factory,
            cleanup
        };
        // Pre-populate pool
        for(let i = 0; i < initialSize; i++){
            pool.available.push(factory());
        }
        this.pools.set(poolName, pool);
    }
    /**
   * Get an item from the pool (reuse if available, create if needed)
   */ getFromPool(poolName) {
        const pool = this.pools.get(poolName);
        if (!pool) {
            throw new Error(`Pool '${poolName}' not found`);
        }
        let item;
        if (pool.available.length > 0) {
            item = pool.available.pop();
        } else {
            item = pool.factory();
        }
        pool.inUse.add(item);
        return item;
    }
    /**
   * Return an item to the pool for reuse
   */ async returnToPool(poolName, item) {
        const pool = this.pools.get(poolName);
        if (!pool) {
            throw new Error(`Pool '${poolName}' not found`);
        }
        if (pool.inUse.has(item)) {
            pool.inUse.delete(item);
            await pool.cleanup(item);
            pool.available.push(item);
        }
    }
    /**
   * Create a database transaction for test isolation
   */ async createTransaction(testName) {
        const transactionId = `tx_${testName}_${Date.now()}`;
        // Mock transaction for now - in real implementation would use actual DB
        const transaction = {
            id: transactionId,
            rollback: async ()=>{
                console.log(`ðŸ”„ Rolling back transaction: ${transactionId}`);
            },
            commit: async ()=>{
                console.log(`âœ… Committing transaction: ${transactionId}`);
            }
        };
        this.transactions.set(transactionId, transaction);
        return transactionId;
    }
    /**
   * Rollback a transaction (for test cleanup)
   */ async rollbackTransaction(transactionId) {
        const transaction = this.transactions.get(transactionId);
        if (transaction) {
            await transaction.rollback();
            this.transactions.delete(transactionId);
        }
    }
    /**
   * Add a cleanup task to be executed during teardown
   */ addCleanupTask(task) {
        this.cleanupTasks.push(task);
    }
    /**
   * Execute all cleanup tasks
   */ async executeCleanup() {
        const startTime = performance.now();
        // Execute cleanup tasks in parallel for speed
        await Promise.all(this.cleanupTasks.map((task)=>task()));
        // Rollback any remaining transactions
        await Promise.all(Array.from(this.transactions.keys()).map((id)=>this.rollbackTransaction(id)));
        // Clear cleanup tasks
        this.cleanupTasks = [];
        const duration = performance.now() - startTime;
        console.log(`ðŸ§¹ Cleanup completed in ${duration.toFixed(2)}ms`);
    }
    /**
   * Reset all pools and cleanup
   */ async reset() {
        await this.executeCleanup();
        // Clear all pools
        for (const [poolName, pool] of this.pools){
            // Cleanup all items in use
            for (const item of pool.inUse){
                await pool.cleanup(item);
            }
            // Cleanup all available items
            for (const item of pool.available){
                await pool.cleanup(item);
            }
        }
        this.pools.clear();
        this.transactions.clear();
    }
    constructor(){
        this.pools = new Map();
        this.transactions = new Map();
        this.cleanupTasks = [];
    }
}
const efficientTestData = new EfficientTestDataManager();
function createUserPool() {
    efficientTestData.createPool('users', ()=>({
            id: Math.floor(Math.random() * 1000000),
            email: `test${Date.now()}@example.com`,
            username: `user${Date.now()}`,
            hashedPassword: 'hashed_password',
            createdAt: new Date()
        }), async (user)=>{
        // Reset user state for reuse
        user.email = `test${Date.now()}@example.com`;
        user.username = `user${Date.now()}`;
    }, 3 // Keep 3 users in pool
    );
}
function createPlantPool() {
    efficientTestData.createPool('plants', ()=>({
            id: Math.floor(Math.random() * 1000000),
            commonName: 'Test Plant',
            scientificName: 'Testicus planticus',
            family: 'Testaceae',
            userId: 1
        }), async (plant)=>{
        // Reset plant state for reuse
        plant.commonName = 'Test Plant';
        plant.scientificName = 'Testicus planticus';
    }, 5 // Keep 5 plants in pool
    );
}
function createPlantInstancePool() {
    efficientTestData.createPool('plantInstances', ()=>({
            id: Math.floor(Math.random() * 1000000),
            plantId: 1,
            nickname: 'Test Instance',
            location: 'Test Location',
            userId: 1,
            careHistory: []
        }), async (instance)=>{
        // Reset instance state for reuse
        instance.nickname = 'Test Instance';
        instance.location = 'Test Location';
        instance.careHistory = [];
    }, 5 // Keep 5 instances in pool
    );
}
function setupEfficientTestData() {
    beforeAll(async ()=>{
        createUserPool();
        createPlantPool();
        createPlantInstancePool();
    });
    afterAll(async ()=>{
        await efficientTestData.reset();
    });
}
function setupTransactionIsolation() {
    let transactionId;
    beforeEach(async ()=>{
        const testName = expect.getState().currentTestName || 'unknown';
        transactionId = await efficientTestData.createTransaction(testName);
    });
    afterEach(async ()=>{
        if (transactionId) {
            await efficientTestData.rollbackTransaction(transactionId);
        }
    });
}
class BatchOperations {
    constructor(batchSize = 10){
        this.operations = [];
        this.batchSize = batchSize;
    }
    /**
   * Add an operation to the batch
   */ add(operation) {
        this.operations.push(operation);
    }
    /**
   * Execute all operations in batches
   */ async execute() {
        const results = [];
        for(let i = 0; i < this.operations.length; i += this.batchSize){
            const batch = this.operations.slice(i, i + this.batchSize);
            const batchResults = await Promise.all(batch.map((op)=>op()));
            results.push(...batchResults);
        }
        return results;
    }
    /**
   * Clear all operations
   */ clear() {
        this.operations = [];
    }
}
function* generateTestData(factory, count) {
    for(let i = 0; i < count; i++){
        yield factory();
    }
}
class LazyTestData {
    constructor(factory){
        this.data = null;
        this.factory = factory;
    }
    async get() {
        if (this.data === null) {
            this.data = await this.factory();
        }
        return this.data;
    }
    reset() {
        this.data = null;
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdGVmYW5iZWtrZXIvcHJvamVjdHMvZmFuY3ktcGxhbnRpZXMvc3JjL3Rlc3QtdXRpbHMvcGVyZm9ybWFuY2UvZWZmaWNpZW50LXRlc3QtZGF0YS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEVmZmljaWVudCBUZXN0IERhdGEgU2V0dXAgYW5kIFRlYXJkb3duXG4gKiBcbiAqIFByb3ZpZGVzIG9wdGltaXplZCB1dGlsaXRpZXMgZm9yIGZhc3QgdGVzdCBkYXRhIGNyZWF0aW9uIGFuZCBjbGVhbnVwLlxuICovXG5cbmltcG9ydCB7IHRlc3RQZXJmb3JtYW5jZU1vbml0b3IgfSBmcm9tICcuL3Rlc3QtcGVyZm9ybWFuY2UtbW9uaXRvcic7XG5cbmludGVyZmFjZSBUZXN0RGF0YVBvb2w8VD4ge1xuICBhdmFpbGFibGU6IFRbXTtcbiAgaW5Vc2U6IFNldDxUPjtcbiAgZmFjdG9yeTogKCkgPT4gVDtcbiAgY2xlYW51cDogKGl0ZW06IFQpID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+O1xufVxuXG5pbnRlcmZhY2UgRGF0YWJhc2VUcmFuc2FjdGlvbiB7XG4gIGlkOiBzdHJpbmc7XG4gIHJvbGxiYWNrOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBjb21taXQ6ICgpID0+IFByb21pc2U8dm9pZD47XG59XG5cbi8qKlxuICogRWZmaWNpZW50IHRlc3QgZGF0YSBtYW5hZ2VyIHdpdGggb2JqZWN0IHBvb2xpbmdcbiAqL1xuY2xhc3MgRWZmaWNpZW50VGVzdERhdGFNYW5hZ2VyIHtcbiAgcHJpdmF0ZSBwb29scyA9IG5ldyBNYXA8c3RyaW5nLCBUZXN0RGF0YVBvb2w8YW55Pj4oKTtcbiAgcHJpdmF0ZSB0cmFuc2FjdGlvbnMgPSBuZXcgTWFwPHN0cmluZywgRGF0YWJhc2VUcmFuc2FjdGlvbj4oKTtcbiAgcHJpdmF0ZSBjbGVhbnVwVGFza3M6ICgoKSA9PiBQcm9taXNlPHZvaWQ+KVtdID0gW107XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGRhdGEgcG9vbCBmb3IgcmV1c2FibGUgdGVzdCBvYmplY3RzXG4gICAqL1xuICBjcmVhdGVQb29sPFQ+KFxuICAgIHBvb2xOYW1lOiBzdHJpbmcsXG4gICAgZmFjdG9yeTogKCkgPT4gVCxcbiAgICBjbGVhbnVwOiAoaXRlbTogVCkgPT4gdm9pZCB8IFByb21pc2U8dm9pZD4sXG4gICAgaW5pdGlhbFNpemU6IG51bWJlciA9IDVcbiAgKTogdm9pZCB7XG4gICAgY29uc3QgcG9vbDogVGVzdERhdGFQb29sPFQ+ID0ge1xuICAgICAgYXZhaWxhYmxlOiBbXSxcbiAgICAgIGluVXNlOiBuZXcgU2V0KCksXG4gICAgICBmYWN0b3J5LFxuICAgICAgY2xlYW51cCxcbiAgICB9O1xuXG4gICAgLy8gUHJlLXBvcHVsYXRlIHBvb2xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluaXRpYWxTaXplOyBpKyspIHtcbiAgICAgIHBvb2wuYXZhaWxhYmxlLnB1c2goZmFjdG9yeSgpKTtcbiAgICB9XG5cbiAgICB0aGlzLnBvb2xzLnNldChwb29sTmFtZSwgcG9vbCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGl0ZW0gZnJvbSB0aGUgcG9vbCAocmV1c2UgaWYgYXZhaWxhYmxlLCBjcmVhdGUgaWYgbmVlZGVkKVxuICAgKi9cbiAgZ2V0RnJvbVBvb2w8VD4ocG9vbE5hbWU6IHN0cmluZyk6IFQge1xuICAgIGNvbnN0IHBvb2wgPSB0aGlzLnBvb2xzLmdldChwb29sTmFtZSkgYXMgVGVzdERhdGFQb29sPFQ+O1xuICAgIGlmICghcG9vbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb29sICcke3Bvb2xOYW1lfScgbm90IGZvdW5kYCk7XG4gICAgfVxuXG4gICAgbGV0IGl0ZW06IFQ7XG4gICAgaWYgKHBvb2wuYXZhaWxhYmxlLmxlbmd0aCA+IDApIHtcbiAgICAgIGl0ZW0gPSBwb29sLmF2YWlsYWJsZS5wb3AoKSE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZW0gPSBwb29sLmZhY3RvcnkoKTtcbiAgICB9XG5cbiAgICBwb29sLmluVXNlLmFkZChpdGVtKTtcbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gaXRlbSB0byB0aGUgcG9vbCBmb3IgcmV1c2VcbiAgICovXG4gIGFzeW5jIHJldHVyblRvUG9vbDxUPihwb29sTmFtZTogc3RyaW5nLCBpdGVtOiBUKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgcG9vbCA9IHRoaXMucG9vbHMuZ2V0KHBvb2xOYW1lKSBhcyBUZXN0RGF0YVBvb2w8VD47XG4gICAgaWYgKCFwb29sKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvb2wgJyR7cG9vbE5hbWV9JyBub3QgZm91bmRgKTtcbiAgICB9XG5cbiAgICBpZiAocG9vbC5pblVzZS5oYXMoaXRlbSkpIHtcbiAgICAgIHBvb2wuaW5Vc2UuZGVsZXRlKGl0ZW0pO1xuICAgICAgYXdhaXQgcG9vbC5jbGVhbnVwKGl0ZW0pO1xuICAgICAgcG9vbC5hdmFpbGFibGUucHVzaChpdGVtKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgZGF0YWJhc2UgdHJhbnNhY3Rpb24gZm9yIHRlc3QgaXNvbGF0aW9uXG4gICAqL1xuICBhc3luYyBjcmVhdGVUcmFuc2FjdGlvbih0ZXN0TmFtZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbklkID0gYHR4XyR7dGVzdE5hbWV9XyR7RGF0ZS5ub3coKX1gO1xuICAgIFxuICAgIC8vIE1vY2sgdHJhbnNhY3Rpb24gZm9yIG5vdyAtIGluIHJlYWwgaW1wbGVtZW50YXRpb24gd291bGQgdXNlIGFjdHVhbCBEQlxuICAgIGNvbnN0IHRyYW5zYWN0aW9uOiBEYXRhYmFzZVRyYW5zYWN0aW9uID0ge1xuICAgICAgaWQ6IHRyYW5zYWN0aW9uSWQsXG4gICAgICByb2xsYmFjazogYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+UhCBSb2xsaW5nIGJhY2sgdHJhbnNhY3Rpb246ICR7dHJhbnNhY3Rpb25JZH1gKTtcbiAgICAgIH0sXG4gICAgICBjb21taXQ6IGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coYOKchSBDb21taXR0aW5nIHRyYW5zYWN0aW9uOiAke3RyYW5zYWN0aW9uSWR9YCk7XG4gICAgICB9LFxuICAgIH07XG5cbiAgICB0aGlzLnRyYW5zYWN0aW9ucy5zZXQodHJhbnNhY3Rpb25JZCwgdHJhbnNhY3Rpb24pO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbklkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJvbGxiYWNrIGEgdHJhbnNhY3Rpb24gKGZvciB0ZXN0IGNsZWFudXApXG4gICAqL1xuICBhc3luYyByb2xsYmFja1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy50cmFuc2FjdGlvbnMuZ2V0KHRyYW5zYWN0aW9uSWQpO1xuICAgIGlmICh0cmFuc2FjdGlvbikge1xuICAgICAgYXdhaXQgdHJhbnNhY3Rpb24ucm9sbGJhY2soKTtcbiAgICAgIHRoaXMudHJhbnNhY3Rpb25zLmRlbGV0ZSh0cmFuc2FjdGlvbklkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgY2xlYW51cCB0YXNrIHRvIGJlIGV4ZWN1dGVkIGR1cmluZyB0ZWFyZG93blxuICAgKi9cbiAgYWRkQ2xlYW51cFRhc2sodGFzazogKCkgPT4gUHJvbWlzZTx2b2lkPik6IHZvaWQge1xuICAgIHRoaXMuY2xlYW51cFRhc2tzLnB1c2godGFzayk7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBhbGwgY2xlYW51cCB0YXNrc1xuICAgKi9cbiAgYXN5bmMgZXhlY3V0ZUNsZWFudXAoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgXG4gICAgLy8gRXhlY3V0ZSBjbGVhbnVwIHRhc2tzIGluIHBhcmFsbGVsIGZvciBzcGVlZFxuICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuY2xlYW51cFRhc2tzLm1hcCh0YXNrID0+IHRhc2soKSkpO1xuICAgIFxuICAgIC8vIFJvbGxiYWNrIGFueSByZW1haW5pbmcgdHJhbnNhY3Rpb25zXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBBcnJheS5mcm9tKHRoaXMudHJhbnNhY3Rpb25zLmtleXMoKSkubWFwKGlkID0+IHRoaXMucm9sbGJhY2tUcmFuc2FjdGlvbihpZCkpXG4gICAgKTtcblxuICAgIC8vIENsZWFyIGNsZWFudXAgdGFza3NcbiAgICB0aGlzLmNsZWFudXBUYXNrcyA9IFtdO1xuICAgIFxuICAgIGNvbnN0IGR1cmF0aW9uID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWU7XG4gICAgY29uc29sZS5sb2coYPCfp7kgQ2xlYW51cCBjb21wbGV0ZWQgaW4gJHtkdXJhdGlvbi50b0ZpeGVkKDIpfW1zYCk7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgYWxsIHBvb2xzIGFuZCBjbGVhbnVwXG4gICAqL1xuICBhc3luYyByZXNldCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLmV4ZWN1dGVDbGVhbnVwKCk7XG4gICAgXG4gICAgLy8gQ2xlYXIgYWxsIHBvb2xzXG4gICAgZm9yIChjb25zdCBbcG9vbE5hbWUsIHBvb2xdIG9mIHRoaXMucG9vbHMpIHtcbiAgICAgIC8vIENsZWFudXAgYWxsIGl0ZW1zIGluIHVzZVxuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHBvb2wuaW5Vc2UpIHtcbiAgICAgICAgYXdhaXQgcG9vbC5jbGVhbnVwKGl0ZW0pO1xuICAgICAgfVxuICAgICAgLy8gQ2xlYW51cCBhbGwgYXZhaWxhYmxlIGl0ZW1zXG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgcG9vbC5hdmFpbGFibGUpIHtcbiAgICAgICAgYXdhaXQgcG9vbC5jbGVhbnVwKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICB0aGlzLnBvb2xzLmNsZWFyKCk7XG4gICAgdGhpcy50cmFuc2FjdGlvbnMuY2xlYXIoKTtcbiAgfVxufVxuXG4vLyBHbG9iYWwgaW5zdGFuY2VcbmV4cG9ydCBjb25zdCBlZmZpY2llbnRUZXN0RGF0YSA9IG5ldyBFZmZpY2llbnRUZXN0RGF0YU1hbmFnZXIoKTtcblxuLyoqXG4gKiBGYXN0IHRlc3QgdXNlciBmYWN0b3J5IHdpdGggcG9vbGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVXNlclBvb2woKSB7XG4gIGVmZmljaWVudFRlc3REYXRhLmNyZWF0ZVBvb2woXG4gICAgJ3VzZXJzJyxcbiAgICAoKSA9PiAoe1xuICAgICAgaWQ6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDApLFxuICAgICAgZW1haWw6IGB0ZXN0JHtEYXRlLm5vdygpfUBleGFtcGxlLmNvbWAsXG4gICAgICB1c2VybmFtZTogYHVzZXIke0RhdGUubm93KCl9YCxcbiAgICAgIGhhc2hlZFBhc3N3b3JkOiAnaGFzaGVkX3Bhc3N3b3JkJyxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICB9KSxcbiAgICBhc3luYyAodXNlcikgPT4ge1xuICAgICAgLy8gUmVzZXQgdXNlciBzdGF0ZSBmb3IgcmV1c2VcbiAgICAgIHVzZXIuZW1haWwgPSBgdGVzdCR7RGF0ZS5ub3coKX1AZXhhbXBsZS5jb21gO1xuICAgICAgdXNlci51c2VybmFtZSA9IGB1c2VyJHtEYXRlLm5vdygpfWA7XG4gICAgfSxcbiAgICAzIC8vIEtlZXAgMyB1c2VycyBpbiBwb29sXG4gICk7XG59XG5cbi8qKlxuICogRmFzdCBwbGFudCBkYXRhIGZhY3Rvcnkgd2l0aCBwb29saW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQbGFudFBvb2woKSB7XG4gIGVmZmljaWVudFRlc3REYXRhLmNyZWF0ZVBvb2woXG4gICAgJ3BsYW50cycsXG4gICAgKCkgPT4gKHtcbiAgICAgIGlkOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwKSxcbiAgICAgIGNvbW1vbk5hbWU6ICdUZXN0IFBsYW50JyxcbiAgICAgIHNjaWVudGlmaWNOYW1lOiAnVGVzdGljdXMgcGxhbnRpY3VzJyxcbiAgICAgIGZhbWlseTogJ1Rlc3RhY2VhZScsXG4gICAgICB1c2VySWQ6IDEsXG4gICAgfSksXG4gICAgYXN5bmMgKHBsYW50KSA9PiB7XG4gICAgICAvLyBSZXNldCBwbGFudCBzdGF0ZSBmb3IgcmV1c2VcbiAgICAgIHBsYW50LmNvbW1vbk5hbWUgPSAnVGVzdCBQbGFudCc7XG4gICAgICBwbGFudC5zY2llbnRpZmljTmFtZSA9ICdUZXN0aWN1cyBwbGFudGljdXMnO1xuICAgIH0sXG4gICAgNSAvLyBLZWVwIDUgcGxhbnRzIGluIHBvb2xcbiAgKTtcbn1cblxuLyoqXG4gKiBGYXN0IHBsYW50IGluc3RhbmNlIGZhY3Rvcnkgd2l0aCBwb29saW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQbGFudEluc3RhbmNlUG9vbCgpIHtcbiAgZWZmaWNpZW50VGVzdERhdGEuY3JlYXRlUG9vbChcbiAgICAncGxhbnRJbnN0YW5jZXMnLFxuICAgICgpID0+ICh7XG4gICAgICBpZDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMCksXG4gICAgICBwbGFudElkOiAxLFxuICAgICAgbmlja25hbWU6ICdUZXN0IEluc3RhbmNlJyxcbiAgICAgIGxvY2F0aW9uOiAnVGVzdCBMb2NhdGlvbicsXG4gICAgICB1c2VySWQ6IDEsXG4gICAgICBjYXJlSGlzdG9yeTogW10sXG4gICAgfSksXG4gICAgYXN5bmMgKGluc3RhbmNlKSA9PiB7XG4gICAgICAvLyBSZXNldCBpbnN0YW5jZSBzdGF0ZSBmb3IgcmV1c2VcbiAgICAgIGluc3RhbmNlLm5pY2tuYW1lID0gJ1Rlc3QgSW5zdGFuY2UnO1xuICAgICAgaW5zdGFuY2UubG9jYXRpb24gPSAnVGVzdCBMb2NhdGlvbic7XG4gICAgICBpbnN0YW5jZS5jYXJlSGlzdG9yeSA9IFtdO1xuICAgIH0sXG4gICAgNSAvLyBLZWVwIDUgaW5zdGFuY2VzIGluIHBvb2xcbiAgKTtcbn1cblxuLyoqXG4gKiBTZXR1cCBlZmZpY2llbnQgdGVzdCBkYXRhIGZvciBhIHRlc3Qgc3VpdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldHVwRWZmaWNpZW50VGVzdERhdGEoKSB7XG4gIGJlZm9yZUFsbChhc3luYyAoKSA9PiB7XG4gICAgY3JlYXRlVXNlclBvb2woKTtcbiAgICBjcmVhdGVQbGFudFBvb2woKTtcbiAgICBjcmVhdGVQbGFudEluc3RhbmNlUG9vbCgpO1xuICB9KTtcblxuICBhZnRlckFsbChhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZWZmaWNpZW50VGVzdERhdGEucmVzZXQoKTtcbiAgfSk7XG59XG5cbi8qKlxuICogU2V0dXAgdHJhbnNhY3Rpb24tYmFzZWQgdGVzdCBpc29sYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldHVwVHJhbnNhY3Rpb25Jc29sYXRpb24oKSB7XG4gIGxldCB0cmFuc2FjdGlvbklkOiBzdHJpbmc7XG5cbiAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgdGVzdE5hbWUgPSBleHBlY3QuZ2V0U3RhdGUoKS5jdXJyZW50VGVzdE5hbWUgfHwgJ3Vua25vd24nO1xuICAgIHRyYW5zYWN0aW9uSWQgPSBhd2FpdCBlZmZpY2llbnRUZXN0RGF0YS5jcmVhdGVUcmFuc2FjdGlvbih0ZXN0TmFtZSk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaChhc3luYyAoKSA9PiB7XG4gICAgaWYgKHRyYW5zYWN0aW9uSWQpIHtcbiAgICAgIGF3YWl0IGVmZmljaWVudFRlc3REYXRhLnJvbGxiYWNrVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25JZCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBCYXRjaCBvcGVyYXRpb25zIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcbiAqL1xuZXhwb3J0IGNsYXNzIEJhdGNoT3BlcmF0aW9ucyB7XG4gIHByaXZhdGUgb3BlcmF0aW9uczogKCgpID0+IFByb21pc2U8YW55PilbXSA9IFtdO1xuICBwcml2YXRlIGJhdGNoU2l6ZTogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKGJhdGNoU2l6ZTogbnVtYmVyID0gMTApIHtcbiAgICB0aGlzLmJhdGNoU2l6ZSA9IGJhdGNoU2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYW4gb3BlcmF0aW9uIHRvIHRoZSBiYXRjaFxuICAgKi9cbiAgYWRkKG9wZXJhdGlvbjogKCkgPT4gUHJvbWlzZTxhbnk+KTogdm9pZCB7XG4gICAgdGhpcy5vcGVyYXRpb25zLnB1c2gob3BlcmF0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGFsbCBvcGVyYXRpb25zIGluIGJhdGNoZXNcbiAgICovXG4gIGFzeW5jIGV4ZWN1dGUoKTogUHJvbWlzZTxhbnlbXT4ge1xuICAgIGNvbnN0IHJlc3VsdHM6IGFueVtdID0gW107XG4gICAgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm9wZXJhdGlvbnMubGVuZ3RoOyBpICs9IHRoaXMuYmF0Y2hTaXplKSB7XG4gICAgICBjb25zdCBiYXRjaCA9IHRoaXMub3BlcmF0aW9ucy5zbGljZShpLCBpICsgdGhpcy5iYXRjaFNpemUpO1xuICAgICAgY29uc3QgYmF0Y2hSZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoYmF0Y2gubWFwKG9wID0+IG9wKCkpKTtcbiAgICAgIHJlc3VsdHMucHVzaCguLi5iYXRjaFJlc3VsdHMpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgb3BlcmF0aW9uc1xuICAgKi9cbiAgY2xlYXIoKTogdm9pZCB7XG4gICAgdGhpcy5vcGVyYXRpb25zID0gW107XG4gIH1cbn1cblxuLyoqXG4gKiBNZW1vcnktZWZmaWNpZW50IHRlc3QgZGF0YSBnZW5lcmF0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uKiBnZW5lcmF0ZVRlc3REYXRhPFQ+KFxuICBmYWN0b3J5OiAoKSA9PiBULFxuICBjb3VudDogbnVtYmVyXG4pOiBHZW5lcmF0b3I8VCwgdm9pZCwgdW5rbm93bj4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICB5aWVsZCBmYWN0b3J5KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBMYXp5IGxvYWRpbmcgdGVzdCBkYXRhIGhlbHBlclxuICovXG5leHBvcnQgY2xhc3MgTGF6eVRlc3REYXRhPFQ+IHtcbiAgcHJpdmF0ZSBkYXRhOiBUIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgZmFjdG9yeTogKCkgPT4gVCB8IFByb21pc2U8VD47XG5cbiAgY29uc3RydWN0b3IoZmFjdG9yeTogKCkgPT4gVCB8IFByb21pc2U8VD4pIHtcbiAgICB0aGlzLmZhY3RvcnkgPSBmYWN0b3J5O1xuICB9XG5cbiAgYXN5bmMgZ2V0KCk6IFByb21pc2U8VD4ge1xuICAgIGlmICh0aGlzLmRhdGEgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuZGF0YSA9IGF3YWl0IHRoaXMuZmFjdG9yeSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kYXRhO1xuICB9XG5cbiAgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgfVxufSJdLCJuYW1lcyI6WyJCYXRjaE9wZXJhdGlvbnMiLCJMYXp5VGVzdERhdGEiLCJjcmVhdGVQbGFudEluc3RhbmNlUG9vbCIsImNyZWF0ZVBsYW50UG9vbCIsImNyZWF0ZVVzZXJQb29sIiwiZWZmaWNpZW50VGVzdERhdGEiLCJnZW5lcmF0ZVRlc3REYXRhIiwic2V0dXBFZmZpY2llbnRUZXN0RGF0YSIsInNldHVwVHJhbnNhY3Rpb25Jc29sYXRpb24iLCJFZmZpY2llbnRUZXN0RGF0YU1hbmFnZXIiLCJjcmVhdGVQb29sIiwicG9vbE5hbWUiLCJmYWN0b3J5IiwiY2xlYW51cCIsImluaXRpYWxTaXplIiwicG9vbCIsImF2YWlsYWJsZSIsImluVXNlIiwiU2V0IiwiaSIsInB1c2giLCJwb29scyIsInNldCIsImdldEZyb21Qb29sIiwiZ2V0IiwiRXJyb3IiLCJpdGVtIiwibGVuZ3RoIiwicG9wIiwiYWRkIiwicmV0dXJuVG9Qb29sIiwiaGFzIiwiZGVsZXRlIiwiY3JlYXRlVHJhbnNhY3Rpb24iLCJ0ZXN0TmFtZSIsInRyYW5zYWN0aW9uSWQiLCJEYXRlIiwibm93IiwidHJhbnNhY3Rpb24iLCJpZCIsInJvbGxiYWNrIiwiY29uc29sZSIsImxvZyIsImNvbW1pdCIsInRyYW5zYWN0aW9ucyIsInJvbGxiYWNrVHJhbnNhY3Rpb24iLCJhZGRDbGVhbnVwVGFzayIsInRhc2siLCJjbGVhbnVwVGFza3MiLCJleGVjdXRlQ2xlYW51cCIsInN0YXJ0VGltZSIsInBlcmZvcm1hbmNlIiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsIkFycmF5IiwiZnJvbSIsImtleXMiLCJkdXJhdGlvbiIsInRvRml4ZWQiLCJyZXNldCIsImNsZWFyIiwiTWFwIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwiZW1haWwiLCJ1c2VybmFtZSIsImhhc2hlZFBhc3N3b3JkIiwiY3JlYXRlZEF0IiwidXNlciIsImNvbW1vbk5hbWUiLCJzY2llbnRpZmljTmFtZSIsImZhbWlseSIsInVzZXJJZCIsInBsYW50IiwicGxhbnRJZCIsIm5pY2tuYW1lIiwibG9jYXRpb24iLCJjYXJlSGlzdG9yeSIsImluc3RhbmNlIiwiYmVmb3JlQWxsIiwiYWZ0ZXJBbGwiLCJiZWZvcmVFYWNoIiwiZXhwZWN0IiwiZ2V0U3RhdGUiLCJjdXJyZW50VGVzdE5hbWUiLCJhZnRlckVhY2giLCJiYXRjaFNpemUiLCJvcGVyYXRpb25zIiwib3BlcmF0aW9uIiwiZXhlY3V0ZSIsInJlc3VsdHMiLCJiYXRjaCIsInNsaWNlIiwiYmF0Y2hSZXN1bHRzIiwib3AiLCJjb3VudCIsImRhdGEiXSwibWFwcGluZ3MiOiJBQUFBOzs7O0NBSUM7Ozs7Ozs7Ozs7O1FBbVJZQTtlQUFBQTs7UUFxREFDO2VBQUFBOztRQTlHR0M7ZUFBQUE7O1FBdEJBQztlQUFBQTs7UUF0QkFDO2VB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