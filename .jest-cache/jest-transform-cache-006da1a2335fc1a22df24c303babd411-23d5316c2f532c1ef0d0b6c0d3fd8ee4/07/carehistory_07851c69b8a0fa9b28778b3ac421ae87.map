{"version":3,"sources":["/Users/stefanbekker/projects/fancy-planties/src/lib/db/queries/care-history.ts"],"sourcesContent":["import { db } from '@/lib/db';\nimport { careHistory, plantInstances, plants } from '@/lib/db/schema';\nimport { eq, and, desc, asc, gte, lte, inArray, sql, count } from 'drizzle-orm';\nimport type { \n  CareHistory, \n  NewCareHistory, \n  PlantInstance,\n  Plant \n} from '@/lib/db/schema';\nimport type { EnhancedPlantInstance } from '@/lib/types/plant-instance-types';\nimport type { \n  CareFilterInput,\n  CareStatsQueryInput,\n  CareDashboardQueryInput \n} from '@/lib/validation/care-schemas';\nimport type { \n  EnhancedCareHistory,\n  PlantCareStatistics,\n  CareDashboardData,\n  CareType\n} from '@/lib/types/care-types';\nimport { CareCalculator } from '@/lib/services/care-calculator';\nimport { careHelpers } from '@/lib/types/care-types';\n\n/**\n * Database queries for care history management\n */\nexport class CareHistoryQueries {\n  /**\n   * Create a new care history entry\n   */\n  static async createCareHistory(data: NewCareHistory): Promise<CareHistory> {\n    const [careEntry] = await db\n      .insert(careHistory)\n      .values({\n        ...data,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      })\n      .returning();\n\n    return careEntry;\n  }\n\n  /**\n   * Get care history by ID\n   */\n  static async getCareHistoryById(id: number): Promise<CareHistory | null> {\n    const [careEntry] = await db\n      .select()\n      .from(careHistory)\n      .where(eq(careHistory.id, id))\n      .limit(1);\n\n    return careEntry || null;\n  }\n\n  /**\n   * Get care history for a specific plant instance\n   */\n  static async getCareHistoryForPlant(\n    plantInstanceId: number,\n    userId: number,\n    filters?: Partial<CareFilterInput>\n  ): Promise<EnhancedCareHistory[]> {\n    // Build where conditions\n    const conditions = [\n      eq(careHistory.plantInstanceId, plantInstanceId),\n      eq(careHistory.userId, userId)\n    ];\n\n    if (filters?.careType) {\n      conditions.push(eq(careHistory.careType, filters.careType));\n    }\n\n    if (filters?.startDate) {\n      conditions.push(gte(careHistory.careDate, filters.startDate));\n    }\n\n    if (filters?.endDate) {\n      conditions.push(lte(careHistory.careDate, filters.endDate));\n    }\n\n    // Apply sorting\n    const sortField = filters?.sortBy === 'care_type' ? careHistory.careType :\n                     filters?.sortBy === 'created_at' ? careHistory.createdAt :\n                     careHistory.careDate;\n    \n    const sortOrder = filters?.sortOrder === 'asc' ? asc(sortField) : desc(sortField);\n\n    // Build the query\n    let query = db\n      .select({\n        careHistory: careHistory,\n        plantInstance: plantInstances,\n        plant: plants,\n      })\n      .from(careHistory)\n      .leftJoin(plantInstances, eq(careHistory.plantInstanceId, plantInstances.id))\n      .leftJoin(plants, eq(plantInstances.plantId, plants.id))\n      .where(and(...conditions))\n      .orderBy(sortOrder);\n\n    // Apply pagination\n    if (filters?.limit) {\n      query = query.limit(filters.limit) as any;\n    }\n    if (filters?.offset) {\n      query = query.offset(filters.offset) as any;\n    }\n\n    const results = await query;\n\n    return results.map(result => this.enhanceCareHistory(result.careHistory, result.plantInstance, result.plant));\n  }\n\n  /**\n   * Get care history for multiple plant instances (for dashboard)\n   */\n  static async getCareHistoryForPlants(\n    plantInstanceIds: number[],\n    userId: number,\n    filters?: Partial<CareFilterInput>\n  ): Promise<EnhancedCareHistory[]> {\n    if (plantInstanceIds.length === 0) return [];\n\n    // Build where conditions\n    const conditions = [\n      inArray(careHistory.plantInstanceId, plantInstanceIds),\n      eq(careHistory.userId, userId)\n    ];\n\n    if (filters?.careType) {\n      conditions.push(eq(careHistory.careType, filters.careType));\n    }\n\n    if (filters?.startDate) {\n      conditions.push(gte(careHistory.careDate, filters.startDate));\n    }\n\n    if (filters?.endDate) {\n      conditions.push(lte(careHistory.careDate, filters.endDate));\n    }\n\n    // Apply sorting\n    const sortField = filters?.sortBy === 'care_type' ? careHistory.careType :\n                     filters?.sortBy === 'created_at' ? careHistory.createdAt :\n                     careHistory.careDate;\n    \n    const sortOrder = filters?.sortOrder === 'asc' ? asc(sortField) : desc(sortField);\n\n    // Build the query\n    let query = db\n      .select({\n        careHistory: careHistory,\n        plantInstance: plantInstances,\n        plant: plants,\n      })\n      .from(careHistory)\n      .leftJoin(plantInstances, eq(careHistory.plantInstanceId, plantInstances.id))\n      .leftJoin(plants, eq(plantInstances.plantId, plants.id))\n      .where(and(...conditions))\n      .orderBy(sortOrder);\n\n    // Apply pagination\n    if (filters?.limit) {\n      query = query.limit(filters.limit) as any;\n    }\n    if (filters?.offset) {\n      query = query.offset(filters.offset) as any;\n    }\n\n    const results = await query;\n\n    return results.map(result => this.enhanceCareHistory(result.careHistory, result.plantInstance, result.plant));\n  }\n\n  /**\n   * Get recent care history for a user\n   */\n  static async getRecentCareHistory(\n    userId: number,\n    limit: number = 20\n  ): Promise<EnhancedCareHistory[]> {\n    const results = await db\n      .select({\n        careHistory: careHistory,\n        plantInstance: plantInstances,\n        plant: plants,\n      })\n      .from(careHistory)\n      .leftJoin(plantInstances, eq(careHistory.plantInstanceId, plantInstances.id))\n      .leftJoin(plants, eq(plantInstances.plantId, plants.id))\n      .where(eq(careHistory.userId, userId))\n      .orderBy(desc(careHistory.careDate))\n      .limit(limit);\n\n    return results.map(result => this.enhanceCareHistory(result.careHistory, result.plantInstance, result.plant));\n  }\n\n  /**\n   * Update care history entry\n   */\n  static async updateCareHistory(\n    id: number,\n    userId: number,\n    updates: Partial<NewCareHistory>\n  ): Promise<CareHistory | null> {\n    const [updated] = await db\n      .update(careHistory)\n      .set({\n        ...updates,\n        updatedAt: new Date(),\n      })\n      .where(\n        and(\n          eq(careHistory.id, id),\n          eq(careHistory.userId, userId)\n        )\n      )\n      .returning();\n\n    return updated || null;\n  }\n\n  /**\n   * Delete care history entry\n   */\n  static async deleteCareHistory(id: number, userId: number): Promise<boolean> {\n    console.log('Attempting to delete care:', id, 'for user:', userId);\n    \n    // First check if record exists\n    const existing = await db\n      .select()\n      .from(careHistory)\n      .where(eq(careHistory.id, id))\n      .limit(1);\n    \n    console.log('Existing record:', existing);\n    \n    const result = await db\n      .delete(careHistory)\n      .where(\n        and(\n          eq(careHistory.id, id),\n          eq(careHistory.userId, userId)\n        )\n      );\n\n    console.log('Delete result:', result, 'Length:', result.length);\n    return result.length > 0;\n  }\n\n  /**\n   * Get care statistics for a plant instance\n   */\n  static async getPlantCareStatistics(\n    plantInstanceId: number,\n    userId: number\n  ): Promise<PlantCareStatistics | null> {\n    // Get plant instance\n    const [plantInstance] = await db\n      .select()\n      .from(plantInstances)\n      .where(\n        and(\n          eq(plantInstances.id, plantInstanceId),\n          eq(plantInstances.userId, userId)\n        )\n      )\n      .limit(1);\n\n    if (!plantInstance) return null;\n\n    // Get care history\n    const careHistoryData = await db\n      .select()\n      .from(careHistory)\n      .where(\n        and(\n          eq(careHistory.plantInstanceId, plantInstanceId),\n          eq(careHistory.userId, userId)\n        )\n      )\n      .orderBy(asc(careHistory.careDate));\n\n    return CareCalculator.calculatePlantCareStatistics(plantInstance, careHistoryData);\n  }\n\n  /**\n   * Get care statistics for multiple plants\n   */\n  static async getBulkCareStatistics(\n    plantInstanceIds: number[],\n    userId: number\n  ): Promise<PlantCareStatistics[]> {\n    if (plantInstanceIds.length === 0) return [];\n\n    // Get plant instances\n    const plantInstancesData = await db\n      .select()\n      .from(plantInstances)\n      .where(\n        and(\n          inArray(plantInstances.id, plantInstanceIds),\n          eq(plantInstances.userId, userId)\n        )\n      );\n\n    // Get care history for all plants\n    const careHistoryData = await db\n      .select()\n      .from(careHistory)\n      .where(\n        and(\n          inArray(careHistory.plantInstanceId, plantInstanceIds),\n          eq(careHistory.userId, userId)\n        )\n      )\n      .orderBy(asc(careHistory.careDate));\n\n    // Group care history by plant instance\n    const careHistoryByPlant = careHistoryData.reduce((acc, care) => {\n      if (!acc[care.plantInstanceId]) {\n        acc[care.plantInstanceId] = [];\n      }\n      acc[care.plantInstanceId].push(care);\n      return acc;\n    }, {} as Record<number, CareHistory[]>);\n\n    // Calculate statistics for each plant\n    return plantInstancesData.map(plantInstance => \n      CareCalculator.calculatePlantCareStatistics(\n        plantInstance, \n        careHistoryByPlant[plantInstance.id] || []\n      )\n    );\n  }\n\n  /**\n   * Get care dashboard data\n   */\n  static async getCareDashboardData(\n    userId: number,\n    options: Partial<CareDashboardQueryInput> = {}\n  ): Promise<CareDashboardData> {\n    const { includeInactive = false, daysAhead = 7 } = options;\n\n    // Get all plant instances for the user\n    const plantInstancesData = await db\n      .select({\n        plantInstance: plantInstances,\n        plant: plants,\n      })\n      .from(plantInstances)\n      .leftJoin(plants, eq(plantInstances.plantId, plants.id))\n      .where(\n        includeInactive \n          ? eq(plantInstances.userId, userId)\n          : and(\n              eq(plantInstances.userId, userId),\n              eq(plantInstances.isActive, true)\n            )\n      );\n\n    // Get recent care history for statistics\n    const oneWeekAgo = new Date();\n    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);\n\n    const recentCareHistory = await db\n      .select()\n      .from(careHistory)\n      .where(\n        and(\n          eq(careHistory.userId, userId),\n          gte(careHistory.careDate, oneWeekAgo)\n        )\n      );\n\n    // Enhance plant instances with care calculations\n    const enhancedPlants = plantInstancesData.map(({ plantInstance, plant }) => {\n      if (!plant) return null;\n      \n      const careStatus = CareCalculator.calculateCareStatus(plantInstance.fertilizerDue);\n      const careUrgency = CareCalculator.calculateCareUrgency(plantInstance.fertilizerDue);\n      const daysUntilFertilizerDue = CareCalculator.calculateDaysUntilFertilizerDue(plantInstance.fertilizerDue);\n      const daysSinceLastFertilized = CareCalculator.calculateDaysSinceLastFertilized(plantInstance.lastFertilized);\n      const daysSinceLastRepot = CareCalculator.calculateDaysSinceLastRepot(plantInstance.lastRepot);\n      const displayName = plantInstance.nickname || plant.commonName;\n      const primaryImage = plantInstance.images?.[0] || plant.defaultImage || null;\n\n      return {\n        ...plantInstance,\n        plant,\n        careStatus,\n        careUrgency,\n        daysUntilFertilizerDue,\n        daysSinceLastFertilized,\n        daysSinceLastRepot,\n        displayName,\n        primaryImage,\n      };\n    }).filter((plant): plant is EnhancedPlantInstance => plant !== null);\n\n    // Categorize plants by care status\n    const overdue = enhancedPlants.filter(p => p.careStatus === 'overdue');\n    const dueToday = enhancedPlants.filter(p => p.careStatus === 'due_today');\n    const dueSoon = enhancedPlants.filter(p => p.careStatus === 'due_soon');\n    \n    // Get recently cared plants (fertilized in last 3 days)\n    const threeDaysAgo = new Date();\n    threeDaysAgo.setDate(threeDaysAgo.getDate() - 3);\n    const recentlyCared = enhancedPlants.filter(p => \n      p.lastFertilized && p.lastFertilized >= threeDaysAgo\n    );\n\n    // Calculate care streak (consecutive days with proper care)\n    const careStreakDays = this.calculateUserCareStreak(userId, recentCareHistory);\n\n    // Calculate average care consistency across all plants\n    const averageCareConsistency = enhancedPlants.length > 0\n      ? enhancedPlants.reduce((sum, plant) => {\n          // Simplified consistency calculation for dashboard\n          const daysSince = plant.daysSinceLastFertilized || 0;\n          const scheduleDays = careHelpers.parseFertilizerSchedule(plant.fertilizerSchedule);\n          const consistency = Math.max(0, 100 - (daysSince / scheduleDays) * 50);\n          return sum + consistency;\n        }, 0) / enhancedPlants.length\n      : 0;\n\n    return {\n      overdue,\n      dueToday,\n      dueSoon,\n      recentlyCared,\n      statistics: {\n        totalActivePlants: enhancedPlants.length,\n        overdueCount: overdue.length,\n        dueTodayCount: dueToday.length,\n        dueSoonCount: dueSoon.length,\n        careStreakDays,\n        totalCareEventsThisWeek: recentCareHistory.length,\n        averageCareConsistency: Math.round(averageCareConsistency),\n      },\n      quickActions: careHelpers.getDefaultQuickCareActions(),\n    };\n  }\n\n  /**\n   * Get care history count for a plant instance\n   */\n  static async getCareHistoryCount(\n    plantInstanceId: number,\n    userId: number,\n    careType?: CareType\n  ): Promise<number> {\n    const conditions = [\n      eq(careHistory.plantInstanceId, plantInstanceId),\n      eq(careHistory.userId, userId)\n    ];\n\n    if (careType) {\n      conditions.push(eq(careHistory.careType, careType));\n    }\n\n    const [result] = await db\n      .select({ count: count() })\n      .from(careHistory)\n      .where(and(...conditions));\n\n    return result.count;\n  }\n\n  /**\n   * Get last care date for a specific care type\n   */\n  static async getLastCareDate(\n    plantInstanceId: number,\n    userId: number,\n    careType: CareType\n  ): Promise<Date | null> {\n    const [result] = await db\n      .select({ careDate: careHistory.careDate })\n      .from(careHistory)\n      .where(\n        and(\n          eq(careHistory.plantInstanceId, plantInstanceId),\n          eq(careHistory.userId, userId),\n          eq(careHistory.careType, careType)\n        )\n      )\n      .orderBy(desc(careHistory.careDate))\n      .limit(1);\n\n    return result?.careDate || null;\n  }\n\n  /**\n   * Bulk create care history entries\n   */\n  static async bulkCreateCareHistory(entries: NewCareHistory[]): Promise<CareHistory[]> {\n    if (entries.length === 0) return [];\n\n    const entriesWithTimestamps = entries.map(entry => ({\n      ...entry,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    }));\n\n    return await db\n      .insert(careHistory)\n      .values(entriesWithTimestamps)\n      .returning();\n  }\n\n  /**\n   * Private helper to enhance care history with computed properties\n   */\n  private static enhanceCareHistory(\n    care: CareHistory,\n    plantInstance?: PlantInstance | null,\n    plant?: Plant | null\n  ): EnhancedCareHistory {\n    const now = new Date();\n    const daysSinceCare = Math.floor((now.getTime() - care.careDate.getTime()) / (1000 * 60 * 60 * 24));\n    const formattedDate = careHelpers.formatCareDate(care.careDate);\n    const careTypeDisplay = careHelpers.getCareTypeDisplay(care.careType as CareType);\n\n    return {\n      ...care,\n      plantInstance: plantInstance && plant ? { ...plantInstance, plant } : undefined,\n      daysSinceCare,\n      formattedDate,\n      careTypeDisplay,\n    };\n  }\n\n  /**\n   * Private helper to calculate user care streak\n   */\n  private static calculateUserCareStreak(\n    userId: number,\n    recentCareHistory: CareHistory[]\n  ): number {\n    // Simplified care streak calculation\n    // Count consecutive days with at least one care event\n    const careByDate = recentCareHistory.reduce((acc, care) => {\n      const dateKey = care.careDate.toISOString().split('T')[0];\n      acc[dateKey] = true;\n      return acc;\n    }, {} as Record<string, boolean>);\n\n    let streak = 0;\n    const today = new Date();\n    \n    for (let i = 0; i < 30; i++) { // Check last 30 days\n      const checkDate = new Date(today);\n      checkDate.setDate(checkDate.getDate() - i);\n      const dateKey = checkDate.toISOString().split('T')[0];\n      \n      if (careByDate[dateKey]) {\n        streak++;\n      } else if (i > 0) { // Don't break on first day (today) if no care\n        break;\n      }\n    }\n\n    return streak;\n  }\n}"],"names":["CareHistoryQueries","createCareHistory","data","careEntry","db","insert","careHistory","values","createdAt","Date","updatedAt","returning","getCareHistoryById","id","select","from","where","eq","limit","getCareHistoryForPlant","plantInstanceId","userId","filters","conditions","careType","push","startDate","gte","careDate","endDate","lte","sortField","sortBy","sortOrder","asc","desc","query","plantInstance","plantInstances","plant","plants","leftJoin","plantId","and","orderBy","offset","results","map","result","enhanceCareHistory","getCareHistoryForPlants","plantInstanceIds","length","inArray","getRecentCareHistory","updateCareHistory","updates","updated","update","set","deleteCareHistory","console","log","existing","delete","getPlantCareStatistics","careHistoryData","CareCalculator","calculatePlantCareStatistics","getBulkCareStatistics","plantInstancesData","careHistoryByPlant","reduce","acc","care","getCareDashboardData","options","includeInactive","daysAhead","isActive","oneWeekAgo","setDate","getDate","recentCareHistory","enhancedPlants","careStatus","calculateCareStatus","fertilizerDue","careUrgency","calculateCareUrgency","daysUntilFertilizerDue","calculateDaysUntilFertilizerDue","daysSinceLastFertilized","calculateDaysSinceLastFertilized","lastFertilized","daysSinceLastRepot","calculateDaysSinceLastRepot","lastRepot","displayName","nickname","commonName","primaryImage","images","defaultImage","filter","overdue","p","dueToday","dueSoon","threeDaysAgo","recentlyCared","careStreakDays","calculateUserCareStreak","averageCareConsistency","sum","daysSince","scheduleDays","careHelpers","parseFertilizerSchedule","fertilizerSchedule","consistency","Math","max","statistics","totalActivePlants","overdueCount","dueTodayCount","dueSoonCount","totalCareEventsThisWeek","round","quickActions","getDefaultQuickCareActions","getCareHistoryCount","count","getLastCareDate","bulkCreateCareHistory","entries","entriesWithTimestamps","entry","now","daysSinceCare","floor","getTime","formattedDate","formatCareDate","careTypeDisplay","getCareTypeDisplay","undefined","careByDate","dateKey","toISOString","split","streak","today","i","checkDate"],"mappings":"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"}